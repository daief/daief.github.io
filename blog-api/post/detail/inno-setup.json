{"id":"inno-setup","slug":"post/inno-setup","path":"/post/inno-setup","title":"Inno Setup","comments":true,"published":true,"date":"2023-04-07T11:28:06.000Z","updated":"","tags":[],"categories":[{"id":"ad7123e6c402c7d6c71d0a1032463ea3","name":"桌面开发","slug":"categories/桌面开发","path":"/categories/桌面开发","parentId":"","postCount":1,"postIds":[]}],"excerpt":"<p>最近工作上遇到了 Inno Setup，这对于我来说是个新东西，看不懂，那么就学一下吧。</p>\n","more":"\n\n<h1 id=\"安装 &amp; 起步\">安装 &amp; 起步<a name=\"安装 &amp; 起步\" class=\"headerlink\" href=\"#安装 &amp; 起步\"></a></h1><blockquote>\n<p>当前所使用的 Inno Setup 版本是 6.2.2</p>\n</blockquote>\n<p>Inno Setup（后文将简称为 Inno） 是一个开源的安装包制作工具，小巧但强大，官网下载地址：<a href=\"https://jrsoftware.org/isinfo.php\">https://jrsoftware.org/isinfo.php</a>。</p>\n<p>官方文档：<a href=\"https://jrsoftware.org/ishelp/\">https://jrsoftware.org/ishelp/</a></p>\n<p>下载安装之后打开 Inno，实际上是一个编辑器，可以直接编辑脚本，可以编译、运行脚本，生成安装程序。</p>\n<p>选择新建脚本，写入以下内容：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n<span class=\"hljs-attr\">AppVersion</span>=<span class=\"hljs-number\">1.0</span>.<span class=\"hljs-number\">0</span>\n<span class=\"hljs-attr\">DefaultDirName</span>=<span class=\"hljs-string\">&quot;{userdesktop}\\hello&quot;</span></code></pre><p>点击编译（Compile），在对话框中选择保存脚本（比如 hello.iss），之后在脚本的同级会生成一个 <code>Output</code>，里面有一个 <code>mysetup.exe</code>。</p>\n<p>双击 <code>mysetup.exe</code> 就开始安装引导了：</p>\n<p><img alt=\"01-hello-installer.png\" loading=\"lazy\" title=\"01-hello-installer.png\" class=\"post-image \" src=\"/images/d63e5c4d496d5cbc50b06f875ba776b7.01-hello-installer.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n<p>回顾上述脚本：</p>\n<ul>\n<li><code>[Setup]</code>：此部分包含安装程序和卸载程序使用的全局设置，该 <code>Section</code> 是必须的</li>\n<li><code>AppName</code> 和 <code>AppVersion</code> 分别定义应用程序的名称和版本</li>\n<li><code>DefaultDirName</code> 是默认的安装目录，这里使用了一个<strong>常量</strong> <code>userdesktop</code>，表示用户桌面的路径</li>\n</ul>\n<p>根据安装引导的提示完成安装，最终会在指定路径创建一个文件夹，包含如下卸载程序：</p>\n<ul>\n<li>unins000.dat</li>\n<li>unins000.exe</li>\n</ul>\n<p>除了手写脚本，Inno 本身自带可视化的界面去制作安装程序，在可视化界面中一步步进行下去，最后可以将一系列操作保存为一份脚本。可视化的操作很方便易学，不过这里不对可视化操作进行过多介绍了，主要还是学习一下脚本的编写。</p>\n<h1 id=\"脚本学习\">脚本学习<a name=\"脚本学习\" class=\"headerlink\" href=\"#脚本学习\"></a></h1><h2 id=\"iss 脚本概览\">iss 脚本概览<a name=\"iss 脚本概览\" class=\"headerlink\" href=\"#iss 脚本概览\"></a></h2><p>每一个 iss 脚本由若干个 <code>Section</code> 组成，每个 <code>Section</code> 有各自的职责。一个 <code>Section</code> 由方括号 <code>[]</code> 包裹，其中包含 <code>Section</code> 的名称。在每个 <code>Section</code> 内可以包含任意数量的条目。</p>\n<p><code>Section</code> 可以分为两类：</p>\n<ul>\n<li>像 <code>[Setup]</code> 这样，它的条目由指令名称和值（形式为 Directive=Value）构成</li>\n<li>以及像 <code>[Files]</code> 这样，它的条目是由多个键值对通过分号连接而成，这种形式下的键值对又称为参数（Parameter）</li>\n</ul>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n\n<span class=\"hljs-section\">[Files]</span>\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;</span></code></pre><blockquote>\n<p>注意：</p>\n<ul>\n<li>每个 <code>Section</code> 内部的条目可以使用相同的名称</li>\n<li>可以存在多个同名 <code>Section</code></li>\n<li>默认情况下，指令值中的任何前导或尾随空格都将被删除。可以通过在指令值周围加上双引号 <code>&quot;</code> 来避免</li>\n<li>iss 本身大小写不敏感，但是需要注意有些“值”的书写方式，比如应用名称会在某些地方直接展示给用户，故不可随意书写</li>\n</ul>\n</blockquote>\n<p>iss 的注释由 <code>;</code> 开头，<code>[Code]</code> 部分的注释另有两种方式：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-comment\">; AppName 指定应用程序的名称，这是一条注释</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n\n<span class=\"hljs-section\">[Code]</span>\n// 单行注释\n(* 多行注释 *)</code></pre><p>支持类似 C 语言的 <code>#include</code> 指令，它可以将另一个文件中的内容插入到脚本中指令所在的位置。</p>\n<pre class=\"hljs language-c\" hljs-language=\"c\"><code style=\"display:block;\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;filename.txt&quot;</span></span></code></pre><p>如果文件名不是绝对路径，编译器将在 iss 文件所在目录中查找。文件名可以以 <code>compiler:</code> 为前缀，在这种情况下，它会在编译器目录中查找该文件。</p>\n<blockquote>\n<p><code>compiler:</code> 为前缀时，查找编译器目录，指的就是 Inno Setup 的安装目录。</p>\n</blockquote>\n<p>支持 <code>#preproc</code> 指令，该指令指定是否使用内置预处理器（仅支持上述 #include 指令）或使用 Inno 预处理器 (ISPP)，后者支持更多的指令。</p>\n<pre class=\"hljs language-text\" hljs-language=\"text\"><code style=\"display:block;\">#preproc builtin\n#preproc ispp</code></pre><p>默认情况下，iss 脚本使用 ISPP（如果可用），而 .isl 文件使用内置（built-in）预处理器。</p>\n<h2 id=\"多语言\">多语言<a name=\"多语言\" class=\"headerlink\" href=\"#多语言\"></a></h2><p>Inno 官方自带一部分多语言，可以在 Inno 安装目录下的 <code>Languages</code> 文件夹中找到。</p>\n<p>对于官方未支持的多语言（比如中文），可以在 <a href=\"https://jrsoftware.org/files/istrans/\">https://jrsoftware.org/files/istrans/</a> 下载，下载之后保存到 Inno 的 <code>Languages</code> 文件夹中，命名为 <code>ChineseSimplified.isl</code>。</p>\n<blockquote>\n<p>注意：文件格式不能是 UTF-8，需要是 UTF-8 with BOM 或者是 GBK 编码（可能还有其他可行的编码，但没尝试过），否则会出现中文乱码。</p>\n</blockquote>\n<p>针对最开始的脚本，添加中文支持，重新编译并运行：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n<span class=\"hljs-attr\">AppVersion</span>=<span class=\"hljs-number\">1.0</span>.<span class=\"hljs-number\">0</span>\n<span class=\"hljs-attr\">DefaultDirName</span>=<span class=\"hljs-string\">&quot;{userdesktop}\\hello&quot;</span>\n<span class=\"hljs-attr\">WizardStyle</span>=modern\n\n<span class=\"hljs-comment\">; 新增 Languages Section，指定为中文</span>\n<span class=\"hljs-section\">[Languages]</span>\nName: chinesesimp<span class=\"hljs-comment\">; MessagesFile: &quot;compiler:Languages\\ChineseSimplified.isl&quot;</span></code></pre><p><img alt=\"02-hello-installer-chinese.png\" loading=\"lazy\" title=\"02-hello-installer-chinese.png\" class=\"post-image \" src=\"/images/85d0dbbe3d52136ba35b6988deddf206.02-hello-installer-chinese.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n<h2 id=\"常量（Constants）\">常量（Constants）<a name=\"常量（Constants）\" class=\"headerlink\" href=\"#常量（Constants）\"></a></h2><p>前文 <code>DefaultDirName=&quot;{userdesktop}\\hello&quot;</code>、<code>Source: &quot;MYPROG.EXE&quot;; DestDir: &quot;{app}&quot;</code> 中的 <code>userdesktop</code> 和 <code>app</code> 都是常量，安装和卸载的过程中，常量会被替换为用户选择的值或系统配置中的值。</p>\n<p>比如，<code>{app}</code> 常量会被替换为应用程序的安装目录，<code>{userdesktop}</code> 常量会被替换为用户桌面的路径。</p>\n<p>完整的常量列表可以参考官方文档的常量章节。</p>\n<h2 id=\"公共参数（Common Parameters）\">公共参数（Common Parameters）<a name=\"公共参数（Common Parameters）\" class=\"headerlink\" href=\"#公共参数（Common Parameters）\"></a></h2><p>公共参数是指能在所有 <code>Section</code> 中都能被使用的参数，共有三条：</p>\n<ul>\n<li><code>Languages</code></li>\n<li><code>MinVersion</code></li>\n<li><code>OnlyBelowVersion</code></li>\n</ul>\n<blockquote>\n<p>TODO 待完善</p>\n</blockquote>\n<h2 id=\"Components 和 Tasks 参数\">Components 和 Tasks 参数<a name=\"Components 和 Tasks 参数\" class=\"headerlink\" href=\"#Components 和 Tasks 参数\"></a></h2><p>除了 <code>[Types]</code>、<code>[Components]</code> 和 <code>[Tasks]</code>，其他 <code>Section</code> 都支持 <code>Components</code> 和 <code>Tasks</code> 两个可选参数。</p>\n<h3 id=\"Components 参数\">Components 参数<a name=\"Components 参数\" class=\"headerlink\" href=\"#Components 参数\"></a></h3><p>一个由空格分隔的组件名称列表，告诉安装程序该条目属于哪些组件。如果最终用户从此列表中选择了一个组件，则会处理该条目（例如：安装文件）。</p>\n<p>没有 <code>Components</code> 参数的条目始终会被处理，除非有其他参数（比如后文的 Check）指示不应该这样做。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Files]</span>\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Components: main</span>\nSource: &quot;MYPROG.CHM&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Components: help</span>\nSource: &quot;README.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;</span></code></pre><h3 id=\"Tasks 参数\">Tasks 参数<a name=\"Tasks 参数\" class=\"headerlink\" href=\"#Tasks 参数\"></a></h3><p>一个以空格分隔的任务名称列表，告诉安装程序该条目属于哪个任务。如果最终用户从此列表中选择了一个任务，则会处理该条目（例如：安装文件）。</p>\n<p>没有 <code>Tasks</code> 参数的条目始终会被处理，除非其他参数说明不应该这样做。</p>\n<blockquote>\n<p>请注意，在“选择开始菜单文件夹”向导页面上的“不创建开始菜单文件夹”复选框不影响具有 Tasks 参数的 <code>[Icons]</code> 条目，因为它们有自己的复选框。</p>\n</blockquote>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Icons]</span>\nName: &quot;{group}\\My Program&quot;<span class=\"hljs-comment\">; Filename: &quot;{app}\\MyProg.exe&quot;; Components: main; Tasks: startmenu</span>\nName: &quot;{group}\\My Program Help&quot;<span class=\"hljs-comment\">; Filename: &quot;{app}\\MyProg.chm&quot;; Components: help; Tasks: startmenu</span>\nName: &quot;{commondesktop}\\My Program&quot;<span class=\"hljs-comment\">; Filename: &quot;{app}\\MyProg.exe&quot;; Components: main; Tasks: desktopicon</span></code></pre><p>除了空格分隔的列表，还可以将布尔表达式用作组件和任务参数。支持的运算符包括 <code>not</code>、<code>and</code> 和 <code>or</code>。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Components]</span>\nName: a<span class=\"hljs-comment\">; Description: a</span>\nName: b<span class=\"hljs-comment\">; Description: b</span>\n\n<span class=\"hljs-section\">[Tasks]</span>\nName: p<span class=\"hljs-comment\">; Description: a or b; Components: a or b</span>\nName: q<span class=\"hljs-comment\">; Description: a and b; Components: a and b</span>\nName: r<span class=\"hljs-comment\">; Description: not a or b; Components: not a or b</span>\nName: s<span class=\"hljs-comment\">; Description: not (a or b); Components: not (a or b)</span>\nName: t<span class=\"hljs-comment\">; Description: a or b - old style; Components: a b</span></code></pre><h3 id=\"尝试\">尝试<a name=\"尝试\" class=\"headerlink\" href=\"#尝试\"></a></h3><p>上面都是摘自官方的解释，但到底是什么表现呢？</p>\n<p>在脚本中新增 <code>Components</code> 和 <code>Tasks</code> 的相关内容，重新编译并运行：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n<span class=\"hljs-attr\">AppVersion</span>=<span class=\"hljs-number\">1.0</span>.<span class=\"hljs-number\">0</span>\n<span class=\"hljs-attr\">DefaultDirName</span>=<span class=\"hljs-string\">&quot;{userdesktop}\\hello&quot;</span>\n<span class=\"hljs-attr\">WizardStyle</span>=modern\n\n<span class=\"hljs-section\">[Languages]</span>\nName: chinesesimp<span class=\"hljs-comment\">; MessagesFile: &quot;compiler:Languages\\ChineseSimplified.isl&quot;</span>\n\n<span class=\"hljs-section\">[Components]</span>\nName: a<span class=\"hljs-comment\">; Description: a</span>\nName: b<span class=\"hljs-comment\">; Description: b</span>\n\n<span class=\"hljs-section\">[Tasks]</span>\nName: p<span class=\"hljs-comment\">; Description: a or b; Components: a or b</span>\nName: q<span class=\"hljs-comment\">; Description: a and b; Components: a and b</span>\nName: r<span class=\"hljs-comment\">; Description: not a or b; Components: not a or b</span>\nName: s<span class=\"hljs-comment\">; Description: not (a or b); Components: not (a or b)</span>\nName: t<span class=\"hljs-comment\">; Description: a or b - old style; Components: a b</span></code></pre><ul>\n<li><p><img alt=\"03-hello-components-tasks.png\" loading=\"lazy\" title=\"03-hello-components-tasks.png\" class=\"post-image \" src=\"/images/f095aa13400ed3a2b7db95dd6a3938a7.03-hello-components-tasks.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n</li>\n<li><p><img alt=\"04-hello-components-tasks-2.png\" loading=\"lazy\" title=\"04-hello-components-tasks-2.png\" class=\"post-image \" src=\"/images/be4a4d753aca575578d3a2019fe3d009.04-hello-components-tasks-2.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n</li>\n<li><p><img alt=\"05-hello-components-tasks-3.png\" loading=\"lazy\" title=\"05-hello-components-tasks-3.png\" class=\"post-image \" src=\"/images/d1650c75b5fba7e17c4fdc5611d29925.05-hello-components-tasks-3.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n</li>\n<li><p><code>[Components]</code>、<code>[Tasks]</code> 定义了组件和任务（选项）</p>\n</li>\n<li><p><code>Components</code>、<code>Tasks</code> 参数就是根据条件（用户实际的选择组件或任务）来控制条目是否被处理</p>\n</li>\n</ul>\n<h1 id=\"Sections 学习\">Sections 学习<a name=\"Sections 学习\" class=\"headerlink\" href=\"#Sections 学习\"></a></h1><h2 id=\"[Setup]\">[Setup]<a name=\"[Setup]\" class=\"headerlink\" href=\"#[Setup]\"></a></h2><p>文档：<a href=\"https://jrsoftware.org/ishelp/topic_setupsection.htm\">https://jrsoftware.org/ishelp/topic_setupsection.htm</a></p>\n<p><code>[Setup]</code> 包含安装程序和卸载程序使用的全局设置，是必须的。同时 <code>[Setup]</code> 下的 <code>AppName</code>、<code>AppVersion</code> 和 <code>DefaultDirName</code> 指令也是必填的。</p>\n<p><code>[Setup]</code> 包含多达 150+ 的指令，这里只挑几个过一过，实际则用到的时候再对照文档去看了。</p>\n<p>指令大体分为三类：</p>\n<ul>\n<li>编译相关（Compiler-related），可以理解为会影响编译行为的指令，如：<ul>\n<li>Output：可以设置为 <code>yes</code> 或 <code>no</code>，默认为 <code>yes</code>，如果设置为 <code>no</code>，编译器将仅检查脚本中的错误并跳过创建安装文件</li>\n<li>OutputDir：指定输出目录，默认为 <code>Output</code>，可以设置为绝对路径或相对路径</li>\n</ul>\n</li>\n<li>安装相关（Installer-related），影响安装/卸载程序的操作，如：<ul>\n<li>AppName：该指令是必须，指定正在安装的应用程序名称。<strong>不要包括版本号，因为这由 AppVersion 和/或 AppVerName 指令定义</strong>。AppName 会显示在窗口标题、向导页面和对话框中</li>\n<li>AppVerName：该指令包含应用的名称和版本号，默认由 AppName 与 AppVersion 拼接而成，如果未设置 AppVersion 则该指令是必须的</li>\n</ul>\n</li>\n<li>和修饰类（Cosmetic），只影响安装程序的外观，如：<ul>\n<li>SetupIconFile：指定安装/卸载程序的图标，编译器会在源目录中查找图标文件，除非是绝对路径或以 <code>compiler:</code> 开头的路径</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"[Types]\">[Types]<a name=\"[Types]\" class=\"headerlink\" href=\"#[Types]\"></a></h2><p>需要与 <code>[Components]</code> 配合使用，相当于预定义一组集合，方便用户选择组件：</p>\n<p>唯一 Flags 参数的值是 <code>iscustom</code>，表示该类型是自定义类型，如果不定义自定义类型，则只允许用户选择预定义的类型，并且无法再手动选择/取消选择组件。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Types]</span>\nName: &quot;a&quot;<span class=\"hljs-comment\">; Description: &quot;Full installation&quot;</span>\nName: &quot;b&quot;<span class=\"hljs-comment\">; Description: &quot;Compact installation&quot;</span>\nName: &quot;c&quot;<span class=\"hljs-comment\">; Description: &quot;Custom installation&quot;; Flags: iscustom</span></code></pre><h2 id=\"[Components]\">[Components]<a name=\"[Components]\" class=\"headerlink\" href=\"#[Components]\"></a></h2><p>前文已有介绍，这里只说明与 <code>[Types]</code> 配合的使用：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Components]</span>\nName: &quot;c1&quot;<span class=\"hljs-comment\">; Description: &quot;c1&quot;; Types: a b c; Flags: fixed</span>\nName: &quot;c2&quot;<span class=\"hljs-comment\">; Description: &quot;c2&quot;; Types: a b</span>\nName: &quot;c3&quot;<span class=\"hljs-comment\">; Description: &quot;c3&quot;; Types: a</span></code></pre><p>因为定义了 <code>[Types]</code>，组件选择时会有三个选项，分别是 <code>Full installation</code>、<code>Compact installation</code> 和 <code>Custom installation</code>：</p>\n<ul>\n<li>选择 <code>Full installation</code> 会自动勾上 <code>c1</code>、<code>c2</code> 和 <code>c3</code></li>\n<li>选择 <code>Compact installation</code> 会自动勾上 <code>c1</code> 和 <code>c2</code></li>\n<li>若用户选择 <code>Custom installation</code>，则可以手动勾选 <code>c2</code> 和 <code>c3</code></li>\n<li><code>c1</code> 指定了 fixed，因此用户无法手动修改该选项</li>\n</ul>\n<h2 id=\"[Dirs]\">[Dirs]<a name=\"[Dirs]\" class=\"headerlink\" href=\"#[Dirs]\"></a></h2><p><code>[Dirs]</code> 定义了除用户选择的应用程序目录（自动创建）之外，安装程序需要创建的其他目录。在主应用程序目录下创建子目录是该 Section 常见的使用方式。</p>\n<p>请注意，在使用 [Files] 部分安装文件时，不必显式地创建目录，因此该 Section 主要用于创建空目录。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Dirs]</span>\nName: &quot;{app}\\data&quot;\nName: &quot;{app}\\bin&quot;</code></pre><h2 id=\"[Files]\">[Files]<a name=\"[Files]\" class=\"headerlink\" href=\"#[Files]\"></a></h2><p>该 Section 定义了安装程序需要安装的文件。换句话说，就是将定义的 Source 文件打包到安装程序中，安装的时候根据配置分别解压到特定目录。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Files]</span>\nSource: &quot;README.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Flags: isreadme</span>\n<span class=\"hljs-comment\">; 支持通配符</span>\nSource: &quot;subdir\\*&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}\\subdir&quot;; Flags: isreadme</span></code></pre><h2 id=\"[Icons]\">[Icons]<a name=\"[Icons]\" class=\"headerlink\" href=\"#[Icons]\"></a></h2><p>该 Section 定义了安装程序如何在开始菜单或其他位置（如桌面）创建快捷方式。</p>\n<blockquote>\n<p>myapp.exe 是最终的可执行程序，也可以使用 Inno 自带的 demo 程序：<code>Inno 安装目录\\Examples\\MyProg.exe</code>。</p>\n</blockquote>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Icons]</span>\n<span class=\"hljs-comment\">; 创建桌面快捷方式</span>\nName: &quot;{group}\\My Program&quot;<span class=\"hljs-comment\">; Filename: &quot;{app}\\myapp.exe&quot;; WorkingDir: &quot;{app}&quot;</span></code></pre><h2 id=\"[Registry]\">[Registry]<a name=\"[Registry]\" class=\"headerlink\" href=\"#[Registry]\"></a></h2><p>该 Section 定义了安装程序如何在注册表中创建、修改或删除键/值。</p>\n<blockquote>\n<p>默认情况下，安装程序创建的注册表键和值在卸载时不会被删除。如果希望卸载程序的同时删除键或值，则 Flags 中须至少包含 uninsdelete、uninsdeletekeyifempty、uninsdeletevalue 中的一个。</p>\n</blockquote>\n<p>下面是注册伪协议的例子，可通过在浏览器中输入 <code>myapp://</code> 来打开应用程序：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Registry]</span>\nRoot: HKCR<span class=\"hljs-comment\">; SubKey: Myapp; ValueData: &quot;MyappProtocol&quot;; ValueType: string; Flags: createvalueifdoesntexist uninsdeletekey noerror;</span>\nRoot: HKCR<span class=\"hljs-comment\">; SubKey: Myapp; ValueName: &quot;URL Protocol&quot;; ValueData: &quot;{app}\\myapp.exe&quot;; ValueType: string; Flags: createvalueifdoesntexist uninsdeletekey noerror;</span>\nRoot: HKCR<span class=\"hljs-comment\">; SubKey: Myapp\\DefaultIcon; ValueData: &quot;{app}\\myapp.exe&quot;; ValueType: string; Flags: createvalueifdoesntexist uninsdeletekey noerror;</span>\nRoot: HKCR<span class=\"hljs-comment\">; SubKey: Myapp\\shell\\open\\command; ValueData: &quot;{app}\\myapp.exe --open-url=&quot;&quot;%1&quot;&quot;&quot;; Flags: uninsdeletekey noerror; ValueType: string;</span></code></pre><p>Flags 说明：</p>\n<ul>\n<li>createvalueifdoesntexist：注册表中不存在时才创建相应条目</li>\n<li>uninsdeletekey：卸载时删除该键</li>\n<li>noerror：不展示注册表键或值设置失败的信息</li>\n</ul>\n<blockquote>\n<p>官方不建议直接操作注册表 HKCR，而是使用 <code>HKA\\Software\\Classes</code> 作为替代。理由暂时不清楚，同时注册表的相关知识也只了解了零星半点，边学边搞吧。</p>\n</blockquote>\n<h2 id=\"[Run] &amp; [UninstallRun]\">[Run] &amp; [UninstallRun]<a name=\"[Run] &amp; [UninstallRun]\" class=\"headerlink\" href=\"#[Run] &amp; [UninstallRun]\"></a></h2><ul>\n<li><code>[Run]</code> 定义了在安装完成之后需要执行的程序</li>\n<li><code>[UninstallRun]</code> 定义了在卸载第一步需要执行的程序</li>\n</ul>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Run]</span>\n<span class=\"hljs-comment\">; 安装完成最后一步，关闭安装向导后是否允许 myapp.exe</span>\nFilename: &quot;{app}\\myapp.exe&quot;<span class=\"hljs-comment\">; Description: &quot;Run myapp&quot;; Flags: nowait postinstall skipifsilent</span></code></pre><h1 id=\"Pascal 脚本\">Pascal 脚本<a name=\"Pascal 脚本\" class=\"headerlink\" href=\"#Pascal 脚本\"></a></h1><p>除了上面看起来像是”配置式”的内容，Inno 还支持添加脚本（语法为 <a href=\"https://zh.wikipedia.org/zh-sg/Object_Pascal\">Object Pascal</a>）以实现自定义的逻辑，具有更多的创造性，比如：</p>\n<ul>\n<li>支持在自定义条件下中止安装或卸载</li>\n<li>支持在运行时添加自定义引导页面</li>\n<li>支持在安装之前、期间或之后通过 Pascal 脚本来提取、调用 DLL 或其他文件</li>\n<li>支持编写常量，这些常量可以执行普通常量、从注册表读取、从 ini 读取和从命令行读取等操作</li>\n<li>支持在运行时根据自定义条件删除 <code>[Types]</code>、<code>[Components]</code> 或 <code>[Tasks]</code></li>\n<li>基于自定义条件，支持有条件地安装 <code>[Files]</code>、<code>[Registry]</code>、<code>[Run]</code> 等条目</li>\n<li>提供了大量辅助函数，可通过 Pascal 脚本完成 Inno Setup 所能做到的几乎所有事情</li>\n</ul>\n<blockquote>\n<p>注意：从这里开始，若无特殊说明，脚本特指 <code>[Code]</code> 中的 Pascal 脚本，脚本仅在运行时执行，因此不能干涉 iss 本身的编译</p>\n</blockquote>\n<h2 id=\"[Code]\">[Code]<a name=\"[Code]\" class=\"headerlink\" href=\"#[Code]\"></a></h2><p>所有脚本内容的定义需要位于该 Section。</p>\n<h3 id=\"事件函数\">事件函数<a name=\"事件函数\" class=\"headerlink\" href=\"#事件函数\"></a></h3><p>可以在 <code>[Code]</code> 定义事件回调函数，在适当的时机会被执行，例：</p>\n<pre class=\"hljs language-pascal\" hljs-language=\"pascal\"><code style=\"display:block;\">[Code]\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">InitializeSetup</span><span class=\"hljs-params\">()</span>:</span> Boolean;\n  <span class=\"hljs-keyword\">begin</span>\n    <span class=\"hljs-keyword\">if</span> (Msgbox(<span class=\"hljs-string\">&#x27;是否继续安装&#x27;</span>, mbConfirmation, MB_YESNO) = IDYES) <span class=\"hljs-keyword\">then</span>\n      Result := True\n    <span class=\"hljs-keyword\">else</span>\n      Result := False\n    <span class=\"hljs-keyword\">end</span>;\n  <span class=\"hljs-keyword\">end</span>.</code></pre><p>定义事件函数 InitializeSetup，该函数会在安装初始化的时候被调用，返回值为 Boolean，如果返回 True 则继续安装，否则中止安装。上面的例子中，在初始化过程中加入了“弹出确认框”的逻辑，询问用户是否继续安装。</p>\n<p>通常情况下，同一个事件只能定义一个回调函数的实现。但使用事件属性（Event Attributes）可以在脚本中拥有同一事件函数的多个实现。这在包含了实现事件函数的外部脚本中特别有用，以避免与主要脚本发生冲突。</p>\n<p>以下是一个示例脚本，其中包含三个 InitializeWizard 事件函数的实现，每次触发会弹一个提示框，一共会弹三次：</p>\n<pre class=\"hljs language-pascal\" hljs-language=\"pascal\"><code style=\"display:block;\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">procedure</span> <span class=\"hljs-title\">InitializeWizard</span>;</span>\n<span class=\"hljs-keyword\">begin</span>\n  SuppressibleMsgBox(<span class=\"hljs-string\">&#x27;InitializeWizard called 1&#x27;</span>, mbInformation, MB_OK, IDOK);\n<span class=\"hljs-keyword\">end</span>;\n\n&lt;event(<span class=\"hljs-string\">&#x27;InitializeWizard&#x27;</span>)&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">procedure</span> <span class=\"hljs-title\">InitializeWizard2</span>;</span>\n<span class=\"hljs-keyword\">begin</span>\n  SuppressibleMsgBox(<span class=\"hljs-string\">&#x27;InitializeWizard called 2&#x27;</span>, mbInformation, MB_OK, IDOK);\n<span class=\"hljs-keyword\">end</span>;\n\n&lt;event(<span class=\"hljs-string\">&#x27;InitializeWizard&#x27;</span>)&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">procedure</span> <span class=\"hljs-title\">InitializeWizard3</span>;</span>\n<span class=\"hljs-keyword\">begin</span>\n  SuppressibleMsgBox(<span class=\"hljs-string\">&#x27;InitializeWizard called 3&#x27;</span>, mbInformation, MB_OK, IDOK);\n<span class=\"hljs-keyword\">end</span>;</code></pre><p>注意到，第二个定义需要使用了 <code>procedure</code> 关键字，而不是 <code>function</code>，两者都是子程序，但又有区别，简单来说：</p>\n<ul>\n<li><code>procedure</code> 表示过程，不会直接返回值</li>\n<li><code>function</code> 是函数，返回单个值</li>\n</ul>\n<h3 id=\"脚本常量\">脚本常量<a name=\"脚本常量\" class=\"headerlink\" href=\"#脚本常量\"></a></h3><p>这个例子演示了如何在脚本中使用常量，同时脚本中定义的函数也可以在其他地方使用，比如：</p>\n<pre class=\"hljs language-pascal\" hljs-language=\"pascal\"><code style=\"display:block;\">[Setup]\nDefaultDirName=&quot;<span class=\"hljs-comment\">{code:MyConst}</span>&quot;\n\n[Code]\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">MyConst</span><span class=\"hljs-params\">(Param: <span class=\"hljs-keyword\">String</span>)</span>:</span> <span class=\"hljs-keyword\">String</span>;\n<span class=\"hljs-keyword\">begin</span>\n  Result := ExpandConstant(<span class=\"hljs-string\">&#x27;{userdesktop}&#x27;</span>) + <span class=\"hljs-string\">&#x27;/appdest&#x27;</span>;\n<span class=\"hljs-keyword\">end</span>;</code></pre><p>注意，<code>MyConst</code> 函数必须要定义一个参数。</p>\n<p>同时，Inno <a href=\"https://jrsoftware.org/ishelp/topic_scriptfunctions.htm\">内置了许多函数</a>可以被直接使用：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[INI]</span>\n<span class=\"hljs-comment\">; GetShortName</span>\nFileName: &quot;{app}\\MyIni.ini&quot;<span class=\"hljs-comment\">; Section: &quot;MySettings&quot;; Key: &quot;ShortApp&quot;; String: &quot;{code:GetShortName|{app}}&quot;</span></code></pre><h3 id=\"Check 参数\">Check 参数<a name=\"Check 参数\" class=\"headerlink\" href=\"#Check 参数\"></a></h3><p>所有参数形式的 Section 都支持 <code>Check</code> 参数，可以在程序过程中根据条件决定是否生效，比如：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Files]</span>\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Check: MyProgCheck</span>\nSource: &quot;A\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Check: MyDirCheck(ExpandConstant(&#x27;{app}\\A&#x27;))</span>\nSource: &quot;B\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Check: DirExists(ExpandConstant(&#x27;{app}\\B&#x27;))</span>\n\n<span class=\"hljs-section\">[Code]</span>\nvar\n  MyProgChecked: Boolean<span class=\"hljs-comment\">;</span>\n  MyProgCheckResult: Boolean<span class=\"hljs-comment\">;</span>\n\nfunction MyProgCheck(): Boolean<span class=\"hljs-comment\">;</span>\nbegin\n  if not MyProgChecked then begin\n    MyProgCheckResult := MsgBox(&#x27;Do you want to install MyProg.exe to &#x27; + ExtractFilePath(CurrentFileName) + &#x27;?&#x27;, mbConfirmation, MB_YESNO) = idYes<span class=\"hljs-comment\">;</span>\n    MyProgChecked := True<span class=\"hljs-comment\">;</span>\n  end<span class=\"hljs-comment\">;</span>\n  Result := MyProgCheckResult<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span>\n\nfunction MyDirCheck(DirName: String): Boolean<span class=\"hljs-comment\">;</span>\nbegin\n  Result := DirExists(DirName)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span></code></pre><p>注意：</p>\n<ul>\n<li><code>[Files]</code> 中的条目如果包含通配符，<code>Check</code> 会对每一个文件都执行一次，而不是整个条目</li>\n</ul>\n<h3 id=\"BeforeInstall &amp; AfterInstall 参数\">BeforeInstall &amp; AfterInstall 参数<a name=\"BeforeInstall &amp; AfterInstall 参数\" class=\"headerlink\" href=\"#BeforeInstall &amp; AfterInstall 参数\"></a></h3><p>所有参数形式的 Section 也都支持 <code>BeforeInstall</code> 和 <code>AfterInstall</code>，分别是在条目安装之前、之后执行：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Files]</span>\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; BeforeInstall: MyBeforeInstall</span>\nSource: &quot;A\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; BeforeInstall: MyBeforeInstall2(&#x27;{app}\\A\\MYFILE.TXT&#x27;)</span>\nSource: &quot;B\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; BeforeInstall: MyBeforeInstall2(&#x27;{app}\\B\\MYFILE.TXT&#x27;)</span>\nSource: &quot;MYPROG.CHM&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; BeforeInstall: Log(&#x27;Before MYPROG.CHM Install&#x27;)</span>\n\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; AfterInstall: MyAfterInstall</span>\nSource: &quot;A\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; AfterInstall: MyAfterInstall2(&#x27;{app}\\A\\MYFILE.TXT&#x27;)</span>\nSource: &quot;B\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; AfterInstall: MyAfterInstall2(&#x27;{app}\\B\\MYFILE.TXT&#x27;)</span>\nSource: &quot;MYPROG.CHM&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; AfterInstall: Log(&#x27;After MYPROG.CHM Install&#x27;)</span>\n\n<span class=\"hljs-section\">[Code]</span>\nprocedure MyBeforeInstall()<span class=\"hljs-comment\">;</span>\nbegin\n  MsgBox(&#x27;About to install MyProg.exe as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span>\n\nprocedure MyBeforeInstall2(FileName: String)<span class=\"hljs-comment\">;</span>\nbegin\n  MsgBox(&#x27;About to install &#x27; + FileName + &#x27; as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span>\n\nprocedure MyAfterInstall()<span class=\"hljs-comment\">;</span>\nbegin\n  MsgBox(&#x27;Just installed MyProg.exe as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span>\n\nprocedure MyAfterInstall2(FileName: String)<span class=\"hljs-comment\">;</span>\nbegin\n  MsgBox(&#x27;Just installed &#x27; + FileName + &#x27; as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span></code></pre><p>注意：</p>\n<ul>\n<li>所有 BeforeInstall 和 AfterInstall 的函数不应该拥有返回值</li>\n<li>如果安装程序已确定不应处理该条目，则不会调用 BeforeInstall 或 AfterInstall 函数</li>\n<li><code>[Files]</code> 中的条目如果包含通配符，BeforeInstall 和 AfterInstall 会对每一个文件都执行一次，而不是整个条目</li>\n</ul>\n<h3 id=\"调用 DLLs 和 .Net 程序集\">调用 DLLs 和 .Net 程序集<a name=\"调用 DLLs 和 .Net 程序集\" class=\"headerlink\" href=\"#调用 DLLs 和 .Net 程序集\"></a></h3><p>脚本可以调用外部 DLL 中的函数，这包括标准 Windows DLL 中的标准 Win32 API 函数和自定义制作的 DLL 中的自定义函数。此外，还可以调用 .NET 程序集。</p>\n<blockquote>\n<p>先知道有这么个能力吧，实际还没用到过</p>\n</blockquote>\n<h3 id=\"使用 COM Automation Objects\">使用 COM Automation Objects<a name=\"使用 COM Automation Objects\" class=\"headerlink\" href=\"#使用 COM Automation Objects\"></a></h3><blockquote>\n<p>这些概念属实没接触过，感觉上也是能直接调用一些系统或系统库的能力</p>\n</blockquote>\n<p>脚本可以通过 COM Automation 对象支持来访问 COM（也称为 OLE 或 ActiveX）方法和属性。这使得可以访问标准 Windows COM 服务器、自定义 COM 服务器、Visual Basic ActiveX DLL 和 .NET 程序集，可以通过 COM Interop 进行交互。</p>\n<ul>\n<li>IDispatch based COM<ul>\n<li>可通过 CreateOleObject 和 GetActiveOleObject 来初始化基于 IDispatch 的 COM</li>\n</ul>\n</li>\n<li>IUnknown based COM<ul>\n<li>如果对象没有实现 IDispatch 接口，可以使用 CreateComObject 来初始化基于 IUnknown 的 COM</li>\n</ul>\n</li>\n</ul>\n<p>如下是一个通过 WinHttpRequest 发送 HTTP 请求的例子：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Code]</span>\nprocedure SendHttp<span class=\"hljs-comment\">;</span>\n  begin\n    WinHttpReq := CreateOleObject(&#x27;WinHttp.WinHttpRequest.5.1&#x27;)<span class=\"hljs-comment\">;</span>\n    WinHttpReq.Open(&#x27;POST&#x27;, &#x27;https://api.exapmle.com&#x27;, false)<span class=\"hljs-comment\">;</span>\n    WinHttpReq.SetRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)<span class=\"hljs-comment\">;</span>\n    WinHttpReq.Send(&#x27;{&quot;key&quot;:&quot;value&quot;}&#x27;)<span class=\"hljs-comment\">;</span>\n  end<span class=\"hljs-comment\">;</span></code></pre><h1 id=\"结语\">结语<a name=\"结语\" class=\"headerlink\" href=\"#结语\"></a></h1><p>根据文档说明，每个 Section 逐步试验下来，基本上浅浅了解了下 Inno 的各个方面。Inno 本身不难，就是各种指令、参数、Flags 以及内置函数比较多，想要全盘熟悉、用得顺手也不容易。对于 Pascal 语言，虽然没接触过，但有编程经验学点简单的写法很轻松。</p>\n<p>个人而言，最棘手的还是 Windows 平台开发相关的内容，比如注册表的修改，为什么改这个键，为什么设置这个值，这需要查询另外的资料；比如 <code>[Code]</code> 脚本中，可以调用哪些能力，这也需要额外的知识和经验，这些都是我目前未接触的领域。</p>\n<p>总之，Inno 不难，以后随着实际使用再慢慢深入吧。</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li>官方文档：<a href=\"https://jrsoftware.org/ishelp/\">https://jrsoftware.org/ishelp/</a></li>\n<li>Object Pascal：<a href=\"https://zh.wikipedia.org/zh-sg/Object_Pascal\">https://zh.wikipedia.org/zh-sg/Object_Pascal</a></li>\n<li>Pascal 教程：<a href=\"https://www.jc2182.com/pascal/pascal-jiaocheng.html\">https://www.jc2182.com/pascal/pascal-jiaocheng.html</a></li>\n</ul>\n","hash":"0c1c52bbcd5a2832d50b1e78b7b22d17","isArticle":true,"sort":0,"filename":"","raw":"","prev":{"id":"further-knowledge-of-ssh-and-ssh-config","slug":"post/further-knowledge-of-ssh-and-ssh-config","path":"/post/further-knowledge-of-ssh-and-ssh-config","title":"进一步认识 SSH 和 SSH config","comments":true,"published":true,"date":"2022-12-22T10:53:04.000Z","updated":"","tags":[{"id":"765553e6c7ac8592c389acb9878a050a","name":"SSH","postCount":1,"postIds":[]}],"categories":[{"id":"edc9f0a5a5d57797bf68e37364743831","name":"Linux","slug":"categories/Linux","path":"/categories/Linux","parentId":"","postCount":4,"postIds":[]}],"excerpt":"<p>不知道有多少人和我一样，对 SSH key 的接触起始于 Git 的使用，反正是啥也不懂，跟着教程一顿敲：</p>\n<pre class=\"hljs language-bash\" hljs-language=\"bash\"><code style=\"display:block;\">$ ssh-keygen -t rsa -b 2048 -C <span class=\"hljs-string\">&quot;xxxxxxxxxx@qq.com&quot;</span></code></pre><p>一路回车，然后把 <code>id_rsa.pub</code> 的内容填入到 Github/Gitlab 的设置里，就转头去使用 Git 了。</p>\n","more":"","hash":"764b88a83225c7530143ae3dec7d28ee","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""},"next":{"id":"electron-file-association","slug":"post/electron-file-association","path":"/post/electron-file-association","title":"Electron 实现文件关联","comments":true,"published":true,"date":"2023-05-04T11:45:57.000Z","updated":"","tags":[{"id":"ad7123e6c402c7d6c71d0a1032463ea3","name":"桌面开发","postCount":1,"postIds":[]},{"id":"0df2da9cf88450e6758356da45b4d04f","name":"Electron","postCount":1,"postIds":[]},{"id":"9c7fbd4a02af897333481b3df892fddf","name":"Inno Setup","postCount":1,"postIds":[]}],"categories":[],"excerpt":"<p>最近在做一个 Electron 桌面应用，需要实现文件关联，把特定后缀的文件关联到应用上，双击文件可以直接打开应用并读取文件。</p>\n<p>文件关联与操作系统相关性比较大，不同的操作系统实现方式也会不同。不过如果使用 <a href=\"https://www.electron.build/\">electron-builder</a> 进行应用打包，可以直接通过 <a href=\"configuration/configuration.html#overridable-per-platform-options\">fileAssociations</a> 配置来实现文件关联。</p>\n<p>而我这边使用 <a href=\"https://github.com/electron/electron-packager\">electron-packager</a> 打包，不会直接产出安装程序，所以需要自行实现文件关联，同时可以借机进一步了解 Windows 和 Mac 实现文件关联的细节。</p>\n","more":"","hash":"69a815e27e40b55a29f295a0dfa087c3","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""}}