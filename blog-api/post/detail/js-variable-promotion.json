{"id":"js-variable-promotion","slug":"post/js-variable-promotion","path":"/post/js-variable-promotion","title":"JS变量提升","comments":true,"published":true,"date":"2017-12-11T22:26:18.000Z","updated":"","tags":[{"id":"686155af75a60a0f6e9d80c1f7edd3e9","name":"JavaScript","postCount":16,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]},{"id":"686155af75a60a0f6e9d80c1f7edd3e9","name":"JavaScript","slug":"categories/JavaScript","path":"/categories/JavaScript","parentId":"9abfe4a03928eb88a75a5cd95822dfef","postCount":11,"postIds":[]}],"excerpt":"<p>变量提升即将变量声明提升到它所在作用域的最开始的部分，ES6 之前 JS 只有全局作用域和函数作用域，ES6 加入了块级作用域，用一对花括号{}包裹的部分。变量提升会将函数声明和部分变量声明提升到作用域顶端。例子如下：</p>\n","more":"\n\n<pre class=\"hljs language-javascript\" hljs-language=\"javascript\"><code style=\"display:block;\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tt); <span class=\"hljs-comment\">// undefined</span>\n\n<span class=\"hljs-comment\">// 全局变量</span>\n<span class=\"hljs-keyword\">var</span> tt = <span class=\"hljs-string\">&quot;aa&quot;</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tt); <span class=\"hljs-comment\">// undefined</span>\n  <span class=\"hljs-comment\">// 局部变量</span>\n  <span class=\"hljs-keyword\">var</span> tt = <span class=\"hljs-string\">&quot;dd&quot;</span>;\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tt); <span class=\"hljs-comment\">// dd</span>\n}\n\n<span class=\"hljs-title function_\">test</span>();</code></pre><p>解释上述的原因，由于变量提升，代码实际执行如下：</p>\n<pre class=\"hljs language-javascript\" hljs-language=\"javascript\"><code style=\"display:block;\"><span class=\"hljs-comment\">// tt 所在全局作用域，提升到全局域顶部</span>\n<span class=\"hljs-keyword\">var</span> tt;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tt); <span class=\"hljs-comment\">// 所以此处没有报错，打印 undefined</span>\n\n<span class=\"hljs-comment\">// 此处，赋值</span>\ntt = <span class=\"hljs-string\">&quot;aa&quot;</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// 函数作用域，同样变量提升</span>\n  <span class=\"hljs-keyword\">var</span> tt;\n\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tt); <span class=\"hljs-comment\">// 此处为函数作用域内的 tt，所以打印 undefined</span>\n\n  tt = <span class=\"hljs-string\">&quot;dd&quot;</span>;\n\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tt); <span class=\"hljs-comment\">// 此处有值，打印 dd</span>\n}\n\n<span class=\"hljs-title function_\">test</span>();</code></pre><p>ES6 中新增的 <code>let</code> &amp; <code>const</code>，不会产生变量提升现象：</p>\n<pre class=\"hljs language-javascript\" hljs-language=\"javascript\"><code style=\"display:block;\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// Uncaught ReferenceError: a is not defined</span>\n\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-string\">&quot;a&quot;</span>;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// Uncaught ReferenceError: b is not defined</span>\n\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-string\">&quot;b&quot;</span>;</code></pre><ul>\n<li><code>let</code>：用于声明变量，只在 let 所在的作用域内有效</li>\n<li><code>const</code>：用于声明一个常量（只是保证指向的地址不可改变），只能在声明时进行赋值</li>\n</ul>\n","hash":"9f8b1b280ccc51937299876f1ea0d989","isArticle":true,"sort":0,"filename":"","raw":"","prev":{"id":"css-general-knowledge","slug":"post/css-general-knowledge","path":"/post/css-general-knowledge","title":"CSS小知识","comments":true,"published":true,"date":"2017-12-07T16:52:48.000Z","updated":"","tags":[{"id":"2c56c360580420d293172f42d85dfbed","name":"CSS","postCount":1,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]},{"id":"2c56c360580420d293172f42d85dfbed","name":"CSS","slug":"categories/CSS","path":"/categories/CSS","parentId":"9abfe4a03928eb88a75a5cd95822dfef","postCount":1,"postIds":[]}],"excerpt":"<p>记录 CSS 一些有用、易忘的知识。</p>\n","more":"","hash":"2e49d1cdd2381727101e97efa3eabd87","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""},"next":{"id":"catch-js-and-ajax-exception","slug":"post/catch-js-and-ajax-exception","path":"/post/catch-js-and-ajax-exception","title":"前端错误捕获以及ajax监听","comments":true,"published":true,"date":"2017-12-20T20:44:10.000Z","updated":"","tags":[{"id":"686155af75a60a0f6e9d80c1f7edd3e9","name":"JavaScript","postCount":16,"postIds":[]},{"id":"c1a751336da265287229972389952205","name":"前端日志","postCount":1,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]},{"id":"686155af75a60a0f6e9d80c1f7edd3e9","name":"JavaScript","slug":"categories/JavaScript","path":"/categories/JavaScript","parentId":"9abfe4a03928eb88a75a5cd95822dfef","postCount":11,"postIds":[]}],"excerpt":"<p>上线的项目难免会有错误，通过分析日志能够有效、准确地定位、重现并解决错误，从而提升产品体验。以下是根据资料以及目前需求所实现的一个前端日志采集的方案。</p>\n","more":"","hash":"4fde60b5f6d05bd28be27a1768267868","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""}}