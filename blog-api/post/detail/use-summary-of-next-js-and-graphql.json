{"id":"use-summary-of-next-js-and-graphql","slug":"post/use-summary-of-next-js-and-graphql","path":"/post/use-summary-of-next-js-and-graphql","title":"Next.js、GraphQL 使用小结","comments":true,"published":true,"date":"2019-07-03T19:11:51.000Z","updated":"","tags":[{"id":"1c16e694abe7b18f52484174b0aa3c87","name":"SSR","postCount":2,"postIds":[]},{"id":"524de3d2ade4544176f60702b36fbfdf","name":"GraphQL","postCount":1,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<p>近段时间里使用 <a href=\"https://github.com/zeit/next.js\">Next.js</a> 搭建了两个后台，同时还使用了 GraphQL。期间匆匆忙忙，而且项目都是另一个前端老哥搭建的。所以，自己又抽空从头开始搭建了几个 demo，回顾一下知识，同时整理了一下当时遇见的问题、梳理下其中缘由。</p>\n<p>本文主要内容包括三个 demo 的介绍，并记录一些在开发过程中遇到的问题和解决，本文对应 Next.js 版本为 <del>v8.0.3</del>。写的时候发现 Next.js 升级到 v9.0.0 了，自带 TypeScript 支持了，果断把 demo 的版本也升级了。</p>\n<p>上一篇文章（《{% post_link get-a-ssr-demo-step-by-step %}》）介绍了从零搭建 SSR 的过程，并且附带了一些问题的讲解，推荐结合阅读。</p>\n<p>那么，按照惯例就先呈上 demo 地址：<a href=\"https://github.com/daief/react-ssr\">react-ssr</a>。</p>\n","more":"\n\n<h1 id=\"简介\">简介<a name=\"简介\" class=\"headerlink\" href=\"#简介\"></a></h1><p>本节对三个 demo 作个简单介绍。</p>\n<p>正常运行该项目需要配置本地 hosts。</p>\n<pre class=\"hljs language-bash\" hljs-language=\"bash\"><code style=\"display:block;\"><span class=\"hljs-comment\"># hosts</span>\n<span class=\"hljs-comment\"># 模拟 gql-server 的域名</span>\n127.0.0.1            gql-server.example.com\n<span class=\"hljs-comment\"># 模拟应用 account 的域名（nextjs-ssr 或 nextjs-static）</span>\n127.0.0.1            account.example.com\n<span class=\"hljs-comment\"># 模拟应用 customer 的域名（nextjs-ssr 或 nextjs-static）</span>\n127.0.0.1            customer.example.com</code></pre><p>或者在 <code>packages/shared/CONFIG.ts</code> 文件中修改成其他域名配置，然后通过域名 + 端口的形式访问本地开发环境。</p>\n<h2 id=\"nextjs-ssr\">nextjs-ssr<a name=\"nextjs-ssr\" class=\"headerlink\" href=\"#nextjs-ssr\"></a></h2><blockquote>\n<p>地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/nextjs-ssr\">https://github.com/daief/react-ssr/tree/master/packages/nextjs-ssr</a></p>\n</blockquote>\n<p>这第一个 demo 对应业务开发中的第一个后台，该后台是一个对内的、管理各种应用的后台，其中一个功能需要实现各个应用间的<a href=\"https://en.wikipedia.org/wiki/Single_sign-on\">单点登录（SSO）</a>。</p>\n<p>Java 端基于 <a href=\"https://en.wikipedia.org/wiki/JSON_Web_Token\">JWT（Json web token）</a> 实现授权认证，前端应用在请求时需要把 token 加到请求头当中，同时也会将 token 缓存于 localStorage。</p>\n<p>这里的每个应用都有一个不同的二级域名（如 a.example.com、b.example.com），而 localStorage 由于跨域限制，前端应用之间不能共享 token，在这种情况打开新的应用时就会需要重新登录。</p>\n<p>因此，新的方案是把 token 存储在 cookie 里，并设置 Domain 为根域名（.example.com）。如此一来各个应用之间直接就共享 token，而且每个应用不再需要维护 token。</p>\n<p>因为这是一个对内的应用，同时出于对技术的追求，该项目决定试用 SSR，选型 Next.js。同时前端组表示可以用中间层来做 cookie 的维护，而 Java 端一切保持不变。加上了 Node 层之后，又顺理成章地加上了 GraphQL Server。</p>\n<h2 id=\"gql-server\">gql-server<a name=\"gql-server\" class=\"headerlink\" href=\"#gql-server\"></a></h2><blockquote>\n<p>地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/gql-server\">https://github.com/daief/react-ssr/tree/master/packages/gql-server</a></p>\n</blockquote>\n<p>这是一个独立的中间层，主要作用是提供 GraphQL 服务、cookie 管理。</p>\n<p>其实上面选择用 Next.js 做 SSR 的时候就已经添加了一个 Node 服务，但这里还是另外再起了一个服务，依我的想法出于两个原因：Next.js 服务专门负责 SSR，这边专门提供 GraphQL 服务，职责会比较清晰；两者同一个服务时，Next.js 会作为一个中间来件运作，开发调试时若修改服务端部分代码调试工具会自动重启服务，这就会导致 next 部分也重启了、而且得重新编译，很费时间。</p>\n<p>该项目基于 <a href=\"https://www.apollographql.com/docs/\">Apollo GraphQL</a> 系列搭建。</p>\n<p>nextjs-ssr + gql-server + Java 的整体运作情况如下。</p>\n<p><img alt=\"sequence-chart.jpg\" loading=\"lazy\" title=\"sequence-chart.jpg\" class=\"post-image \" src=\"/images/bf96eaf446430d6d7053f2bc6f5bc836.sequence-chart.jpg\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n<h2 id=\"nextjs-static\">nextjs-static<a name=\"nextjs-static\" class=\"headerlink\" href=\"#nextjs-static\"></a></h2><blockquote>\n<p>地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/nextjs-static\">https://github.com/daief/react-ssr/tree/master/packages/nextjs-static</a></p>\n</blockquote>\n<p>该 demo 也使用 Next.js 框架，但依赖的是 Prerender 的功能，最终是静态部署，所以项目中踢除、避免 Server 端的代码。（该 demo 对应第二个后台，只是个常规的管理后台）</p>\n<p>请求部分依旧使用了 GraphQL，不过该项目没有对应的 GraphQL 服务，API 是 REST 形式的。</p>\n<p>通过 <a href=\"https://www.apollographql.com/docs/link/\">apollo-link</a>（可看作是 apollo-client 的中间件）使得 GraphQL 变得十分灵活、不仅仅是依赖于 GraphQL 服务而使用。</p>\n<blockquote>\n<p>apollo-client 是用于发起 GraphQL 请求的一种客户端框架。</p>\n</blockquote>\n<p>这里的主角是 <a href=\"https://www.apollographql.com/docs/link/links/rest/\">apollo-link-rest</a>，让我们很轻易地通过 GraphQL 调用 REST API。</p>\n<p>这样可以在前端实现接口聚合、字段查询（基于真实接口的返回）等 GraphQL 的特色功能。</p>\n<h1 id=\"Next.js 使用问题\">Next.js 使用问题<a name=\"Next.js 使用问题\" class=\"headerlink\" href=\"#Next.js 使用问题\"></a></h1><p>下面把和 Next.js 有关的问题聚合在这一节。</p>\n<h2 id=\"样式文件的处理\">样式文件的处理<a name=\"样式文件的处理\" class=\"headerlink\" href=\"#样式文件的处理\"></a></h2><p>这个应该是使用 SSR 时候的经典问题了，不过有关样式文件在 SSR 中的问题在{% post_link get-a-ssr-demo-step-by-step %}有详细解读，这里只说明该问题在 Next.js 中的具体解决以及和 Next.js 有关的注意点。</p>\n<p>这个问题主要可概括为两点：一是缺少 webpack 对于 CSS、Less 的配置；二是 SSR 项目运行的特点。</p>\n<p>添加相应的 webpack 配置，可使用官方的配置扩展插件：<a href=\"https://github.com/zeit/next-plugins/tree/master/packages/next-css\">@zeit/next-css</a>、<a href=\"https://github.com/zeit/next-plugins/tree/master/packages/next-less\">@zeit/next-less</a>，然后在 <code>next.config.js</code> 中使用：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n<span class=\"hljs-keyword\">const</span> withCSS = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;@zeit/next-css&#x27;</span>);\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-title function_\">withCSS</span>(\n  <span class=\"hljs-title function_\">withLess</span>({\n    <span class=\"hljs-comment\">/* config options here */</span>\n    <span class=\"hljs-attr\">cssModules</span>: <span class=\"hljs-comment\">/* 开启 cssModules */</span> <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">lessLoaderOptions</span>: {\n      <span class=\"hljs-attr\">javascriptEnabled</span>: <span class=\"hljs-literal\">true</span>,\n    },\n    <span class=\"hljs-attr\">cssLoaderOptions</span>: {\n      <span class=\"hljs-attr\">importLoaders</span>: <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-attr\">localIdentName</span>: <span class=\"hljs-string\">&#x27;[local]_[hash:base64:5]&#x27;</span>,\n    },\n  }),\n);</code></pre><p>如此一来，项目中就能正常引用样式文件了。</p>\n<blockquote>\n<p>坑点：引入第三方组件库如 antd 时样式依旧会报错。</p>\n</blockquote>\n<p>最为简单的方式，在 <code>next.config.js</code> 顶部添加：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">require</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>) {\n  <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-property\">extensions</span>[<span class=\"hljs-string\">&#x27;.css&#x27;</span>] = <span class=\"hljs-function\">(<span class=\"hljs-params\">file</span>) =&gt;</span> {};\n  <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-property\">extensions</span>[<span class=\"hljs-string\">&#x27;.less&#x27;</span>] = <span class=\"hljs-function\">(<span class=\"hljs-params\">file</span>) =&gt;</span> {};\n}</code></pre><blockquote>\n<p>坑点：所有的样式文件都开启了 CSS modules；打包时样式依旧报错。</p>\n</blockquote>\n<p>尝试自定义 webpack 的样式配置，简单粗暴之处在于所有（Server &amp; Client）样式都过一遍 loader。在这样的配置下，只要在需要开启 CSS modules 的地方添加 <code>:local()</code> 即可。（以下配置基于 css-loader@^3，顺便一提官方插件所用的是 css-loader@1，两者配置之间会有差异）</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// withStyle.js</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MiniCssExtractPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;mini-css-extract-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">OptimizeCSSAssetsPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">nextConfig = {}</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>({}, nextConfig, {\n    <span class=\"hljs-title function_\">webpack</span>(<span class=\"hljs-params\">config, options</span>) {\n      <span class=\"hljs-keyword\">const</span> { dev, isServer } = options;\n      <span class=\"hljs-keyword\">const</span> {\n        cssLoaderOptions,\n        postcssLoaderOptions,\n        lessLoaderOptions = {},\n      } = nextConfig;\n\n      options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">css</span> = [\n        {\n          <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-title class_\">MiniCssExtractPlugin</span>.<span class=\"hljs-property\">loader</span>,\n        },\n        {\n          <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>,\n          <span class=\"hljs-attr\">options</span>: {\n            <span class=\"hljs-attr\">sourceMap</span>: dev,\n            <span class=\"hljs-attr\">modules</span>: {\n              <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;global&#x27;</span>,\n              <span class=\"hljs-attr\">localIdentName</span>: <span class=\"hljs-string\">&#x27;[local]--[hash:base64:5]&#x27;</span>,\n            },\n            ...cssLoaderOptions,\n          },\n        },\n      ];\n\n      options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">less</span> = [\n        ...options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">css</span>,\n        {\n          <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;less-loader&#x27;</span>,\n          <span class=\"hljs-attr\">options</span>: {\n            <span class=\"hljs-attr\">javascriptEnabled</span>: <span class=\"hljs-literal\">true</span>,\n            ...lessLoaderOptions,\n          },\n        },\n      ];\n\n      config.<span class=\"hljs-property\">module</span>.<span class=\"hljs-property\">rules</span>.<span class=\"hljs-title function_\">push</span>(\n        {\n          <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n          <span class=\"hljs-attr\">use</span>: options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">css</span>,\n        },\n        {\n          <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.less$/</span>,\n          <span class=\"hljs-attr\">use</span>: options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">less</span>,\n        },\n      );\n\n      config.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-title function_\">push</span>(\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MiniCssExtractPlugin</span>({\n          <span class=\"hljs-comment\">// 要加上 static，否则打包后 404</span>\n          <span class=\"hljs-attr\">filename</span>: dev\n            ? <span class=\"hljs-string\">&#x27;static/css/[name].css&#x27;</span>\n            : <span class=\"hljs-string\">&#x27;static/css/[name].[contenthash:8].css&#x27;</span>,\n          <span class=\"hljs-attr\">chunkFilename</span>: dev\n            ? <span class=\"hljs-string\">&#x27;static/css/[name].chunk.css&#x27;</span>\n            : <span class=\"hljs-string\">&#x27;static/css/[name].[contenthash:8].chunk.css&#x27;</span>,\n        }),\n        <span class=\"hljs-keyword\">new</span> (<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;webpack-filter-warnings-plugin&#x27;</span>))({\n          <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/mini-css-extract-plugin[^]*Conflicting order between:/</span>,\n        }),\n      );\n\n      <span class=\"hljs-keyword\">if</span> (!dev &amp;&amp; !isServer) {\n        <span class=\"hljs-comment\">// 构建模式 &amp; Client 才开启压缩</span>\n        config.<span class=\"hljs-property\">optimization</span>.<span class=\"hljs-property\">minimizer</span> = [\n          ...config.<span class=\"hljs-property\">optimization</span>.<span class=\"hljs-property\">minimizer</span>,\n          <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OptimizeCSSAssetsPlugin</span>({}),\n        ];\n      }\n\n      <span class=\"hljs-comment\">// ......</span>\n    },\n  });\n};</code></pre><p>最后再修改 externals 配置，放开 antd 的样式就能支持了。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n<span class=\"hljs-comment\">// 这种配置下就不需要在顶部添加对 require 的处理了</span>\n<span class=\"hljs-keyword\">const</span> withStyle = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;@react-ssr/shared/next-config/withStyle&#x27;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-title function_\">withStyle</span>({\n  <span class=\"hljs-title function_\">webpack</span>(<span class=\"hljs-params\">config, options</span>) {\n    <span class=\"hljs-keyword\">if</span> (isServer) {\n      <span class=\"hljs-comment\">// https://github.com/zeit/next.js/blob/canary/examples/with-ant-design/next.config.js</span>\n      <span class=\"hljs-comment\">// 如果有其他 UI 库的样式，在此补充</span>\n      <span class=\"hljs-keyword\">const</span> antStyles = <span class=\"hljs-regexp\">/antd\\/.*?\\/style.*?/</span>;\n      <span class=\"hljs-keyword\">const</span> origExternals = [...config.<span class=\"hljs-property\">externals</span>];\n      config.<span class=\"hljs-property\">externals</span> = [\n        <span class=\"hljs-function\">(<span class=\"hljs-params\">context, request, callback</span>) =&gt;</span> {\n          <span class=\"hljs-keyword\">if</span> (request.<span class=\"hljs-title function_\">match</span>(antStyles)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">callback</span>();\n          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> origExternals[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;function&#x27;</span>) {\n            origExternals[<span class=\"hljs-number\">0</span>](context, request, callback);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-title function_\">callback</span>();\n          }\n        },\n        ...(<span class=\"hljs-keyword\">typeof</span> origExternals[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;function&#x27;</span> ? [] : origExternals),\n      ];\n    }\n\n    <span class=\"hljs-keyword\">return</span> config;\n  },\n});</code></pre><blockquote>\n<p>坑点：打包后，前端路由切换页面时样式丢失。</p>\n</blockquote>\n<p>这是因为样式在打包后，根据页面被拆分开来。而当第一打开页面时，SSR 渲染的 HTML 文档中只包含当前页面的 CSS 链接，此时在前端切换页面时也不会去加载缺失的样式文件。目前为止的解决方式是将所有的样式打包在一起，添加对应的如下配置。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// withStyle.js</span>\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-function\">() =&gt;</span> ({\n  <span class=\"hljs-title function_\">webpack</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 把所有 css 合并，因为前端路由切换页面的时候不会拉取对应的 css 文件</span>\n    <span class=\"hljs-comment\">// 服务端配置走不走不影响</span>\n    config.<span class=\"hljs-property\">optimization</span>.<span class=\"hljs-property\">splitChunks</span>.<span class=\"hljs-property\">cacheGroups</span>.<span class=\"hljs-property\">styles</span> = {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;styles&#x27;</span>,\n      <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(css|less)$/</span>,\n      <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&#x27;all&#x27;</span>,\n      <span class=\"hljs-attr\">enforce</span>: <span class=\"hljs-literal\">true</span>,\n    };\n    <span class=\"hljs-comment\">// ...</span>\n  },\n});</code></pre><h2 id=\"图片等静态文件处理\">图片等静态文件处理<a name=\"图片等静态文件处理\" class=\"headerlink\" href=\"#图片等静态文件处理\"></a></h2><p>Next.js 对 <a href=\"https://github.com/zeit/next.js#static-file-serving-eg-images\"><code>static/</code> 目录有特殊的支持</a>，推荐将静态资源放在这个目录，通过 <code>/static/some/target.png</code> 的形式进行引用。而且在 v9.0.0 版本在打包时还会自动对 <code>static/</code> 目录内的文件进行压缩。</p>\n<p>但还是存在 <code>import img from &#39;./a.png&#39;</code> 的需求，这时同样进行 webpack 的配置作为支持即可。注意，如下配置 file-loader 实际上对图片处理了两遍，只是输出路径一致最终只有一份。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n\nconfig.<span class=\"hljs-property\">module</span>.<span class=\"hljs-property\">rules</span>.<span class=\"hljs-title function_\">push</span>({\n  <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(jpe?g|png|svg|gif|ico|webp)$/</span>,\n  <span class=\"hljs-attr\">use</span>: [\n    {\n      <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;url-loader&#x27;</span>,\n      <span class=\"hljs-attr\">options</span>: {\n        <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">8192</span>,\n        <span class=\"hljs-attr\">fallback</span>: <span class=\"hljs-string\">&#x27;file-loader&#x27;</span>,\n        <span class=\"hljs-attr\">publicPath</span>: <span class=\"hljs-string\">`/_next/static/images/`</span>,\n        <span class=\"hljs-attr\">outputPath</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${isServer ? <span class=\"hljs-string\">&#x27;../&#x27;</span> : <span class=\"hljs-string\">&#x27;&#x27;</span>}</span>static/images/`</span>,\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;[name]-[hash].[ext]&#x27;</span>,\n      },\n    },\n  ],\n});</code></pre><h2 id=\"Monorepo 中的 Babel 配置\">Monorepo 中的 Babel 配置<a name=\"Monorepo 中的 Babel 配置\" class=\"headerlink\" href=\"#Monorepo 中的 Babel 配置\"></a></h2><p>当项目以 <a href=\"https://en.wikipedia.org/wiki/Monorepo\">Monorepo</a> 方式组织，同时引用其他子包内容时，引用的部分是不会经过 Babel 处理的。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// Next.js 中 webpack 的 Babel 配置</span>\n<span class=\"hljs-comment\">// https://github.com/zeit/next.js/blob/aac4e21d46f300d8433b0bd94a7a0f51e443b7d4/packages/next/build/webpack-config.ts#L394</span>\n[\n  <span class=\"hljs-comment\">// ...</span>\n  {\n    <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(tsx|ts|js|mjs|jsx)$/</span>,\n    <span class=\"hljs-attr\">include</span>: [\n      dir,\n      <span class=\"hljs-regexp\">/next-server[\\\\/]dist[\\\\/]lib/</span>,\n      <span class=\"hljs-regexp\">/next[\\\\/]dist[\\\\/]client/</span>,\n      <span class=\"hljs-regexp\">/next[\\\\/]dist[\\\\/]pages/</span>,\n      <span class=\"hljs-regexp\">/[\\\\/](strip-ansi|ansi-regex)[\\\\/]/</span>,\n    ],\n    <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">path: string</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (\n        <span class=\"hljs-regexp\">/next-server[\\\\/]dist[\\\\/]lib/</span>.<span class=\"hljs-title function_\">test</span>(path) ||\n        <span class=\"hljs-regexp\">/next[\\\\/]dist[\\\\/]client/</span>.<span class=\"hljs-title function_\">test</span>(path) ||\n        <span class=\"hljs-regexp\">/next[\\\\/]dist[\\\\/]pages/</span>.<span class=\"hljs-title function_\">test</span>(path) ||\n        <span class=\"hljs-regexp\">/[\\\\/](strip-ansi|ansi-regex)[\\\\/]/</span>.<span class=\"hljs-title function_\">test</span>(path)\n      ) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n      }\n\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-regexp\">/node_modules/</span>.<span class=\"hljs-title function_\">test</span>(path);\n    },\n    <span class=\"hljs-attr\">use</span>: defaultLoaders.<span class=\"hljs-property\">babel</span>,\n  },\n  <span class=\"hljs-comment\">// ...</span>\n];</code></pre><p>插件 <a href=\"https://www.npmjs.com/package/next-transpile-modules\">next-transpile-modules</a> 可以很方便地解决这个问题。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n<span class=\"hljs-comment\">// https://github.com/zeit/next.js/blob/aac4e21d46f300d8433b0bd94a7a0f51e443b7d4/examples/with-yarn-workspaces/packages/web-app/next.config.js#L1</span>\n\n<span class=\"hljs-keyword\">const</span> withTM = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;next-transpile-modules&#x27;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-title function_\">withTM</span>({\n  <span class=\"hljs-comment\">// `@react-ssr/shared` 是 Monorepo 结构下的其他模块的包名</span>\n  <span class=\"hljs-attr\">transpileModules</span>: [<span class=\"hljs-string\">&#x27;@react-ssr/shared&#x27;</span>],\n});</code></pre><blockquote>\n<p>坑点：虽然经过如上改造，Babel 会对其他子包进行编译，但是发现 Next.js 项目模块下的 Babel 插件配置（.babelrc）对子包范围内的代码并不生效。</p>\n</blockquote>\n<p>其实这一点来源 Babel 7 对于配置的变化，Babel 7 新增了根（root）的概念，默认是当前工作目录，也就是 Next.js 项目模块的级别（packages/nextjs-ssr/），此时 Babel 缺少、也不会去读取他子包的插件配置。</p>\n<p>Babel 推荐在所有 Monorepo 项目的根目录添加 <code>babel.config.js</code>，以此建立了 Babel 的核心概念。但这对于上述问题的解决还不够，在这里我通过设置 <code>rootMode: upward</code> 告诉 Babel 向上级寻找，Babel 会自动寻找 <code>babel.config.js</code> 并将其设置为 root 的值（<a href=\"https://babeljs.io/docs/en/config-files#project-wide-configuration\">更多详细内容可查看官方文章 —— Config Files</a>）。</p>\n<p>具体配置如下。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-title function_\">webpack</span>(<span class=\"hljs-params\">config</span>) {\n    config.<span class=\"hljs-property\">module</span>.<span class=\"hljs-property\">rules</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">rule</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的改动比较暴力，因为 Next.js 没有直接暴露更改内建 loader 参数的地方</span>\n      <span class=\"hljs-keyword\">if</span> (rule.<span class=\"hljs-property\">use</span> &amp;&amp; rule.<span class=\"hljs-property\">use</span>.<span class=\"hljs-property\">loader</span> === <span class=\"hljs-string\">&#x27;next-babel-loader&#x27;</span>) {\n        <span class=\"hljs-comment\">// 设置 babel 向上寻找 babel.config.js，然后将其所在的路径作为根（root）</span>\n        <span class=\"hljs-comment\">// 否则编译其他 package 时不会加载 babel 插件</span>\n        <span class=\"hljs-comment\">// https://babeljs.io/docs/en/config-files#project-wide-configuration</span>\n        rule.<span class=\"hljs-property\">use</span>.<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">rootMode</span> = <span class=\"hljs-string\">&#x27;upward&#x27;</span>;\n      }\n    });\n    <span class=\"hljs-comment\">// ...</span>\n  },\n};</code></pre><p>如此一来，再将 Babel 插件配置在 <code>babel.config.js</code>，那么 Babel 插件在其他模块也会起作用了。</p>\n<h2 id=\"国际化语言渲染问题\">国际化语言渲染问题<a name=\"国际化语言渲染问题\" class=\"headerlink\" href=\"#国际化语言渲染问题\"></a></h2><p>在 <code>nextjs-ssr</code> 中，项目以 SSR 方式运行，在页面请求来临的同时，读取 cookies 就能知晓当前浏览器的语言设置信息，接着就能渲染出对应语言的页面并返回。</p>\n<p>对于用户来说，当选择英文，首屏返回的页面就英文；选择了中文，返回的就是中文页面。</p>\n<p>而对于静态部署的 <code>nextjs-static</code>，并没有动态渲染的能力，页面只有在返回到浏览后才能从 cookies 中读取到语言设置信息，进而将页面切换成对应的语言。</p>\n<p>页面总有个初始语言，可是这样一来打开页面会有个语言切换的现象（默认语言与实际语言不符），但这个也不好避免。所以，<code>nextjs-static</code> 中的操作是一概将 Server 的国际化输出设置成 <code>...</code>，待脚本加载后会自动读取并切换成对应的语言。</p>\n<h1 id=\"其他问题\">其他问题<a name=\"其他问题\" class=\"headerlink\" href=\"#其他问题\"></a></h1><h2 id=\"SSR 部署期间的问题\">SSR 部署期间的问题<a name=\"SSR 部署期间的问题\" class=\"headerlink\" href=\"#SSR 部署期间的问题\"></a></h2><p>在部署期间发生了一个由 <code>host</code> 字段引发的问题，导致 SSR 层的请求发生错误。</p>\n<p>结合开头的时序图可以看到，发起 GraphQL 请求的角色有浏览器和 SSR 层，而 SSR 层发起请求时都来源于一个页面的访问。比如，访问主页 <code>/</code>（不是通过其他前端路由跳转来的），而且主页组件在 <code>getInitialProps</code> 生命周期中有请求，那么该请求会在 SSR 层发起。同样，这个请求需要携带 token、language 标识等信息，这些信息来源于页面请求的 Header，这步操作见代码。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-comment\">// `packages/shared/src/layouts/ApolloWrap/index.tsx`</span>\n\n<span class=\"hljs-keyword\">const</span> authLink = <span class=\"hljs-title function_\">setContext</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, { headers }</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 这里用于添加自定义的 headers 字段</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">reqHeaders</span>: <span class=\"hljs-built_in\">any</span> = process.<span class=\"hljs-property\">browser</span>\n    ? {}\n    : <span class=\"hljs-comment\">// 当在 Server 端的时候，将来自 browser 的 headers 携带过去</span>\n      <span class=\"hljs-comment\">// host 也被包含在内。</span>\n      <span class=\"hljs-title function_\">getProp</span>(<span class=\"hljs-function\">() =&gt;</span> ctx.<span class=\"hljs-property\">req</span>.<span class=\"hljs-property\">headers</span>, {});\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">headers</span>: {\n      ...headers,\n      ...reqHeaders,\n    },\n  };\n});</code></pre><p>这里的 <code>ctx.req</code> 具体指的就是 <code>访问主页 /</code> 这次请求。接着，请求被发往 gql-server。</p>\n<p>这里需要补充一下部署时候的具体情况，<code>nextjs-ssr</code> 和 <code>gql-server</code> 运行于 Docker 容器当中，同时在一个物理机上，通过 Nginx 转发请求。</p>\n<p>那么上述流程会是这样。</p>\n<pre class=\"hljs language-\" hljs-language=\"\"><code style=\"display:block;\">1. 访问主页 `http://customer.example.com/`，发送请求到 `nextjs-ssr`\n    请求内容：\n      url: http://customer.example.com/\n      headers:\n        host:  http://customer.example.com/\n\n\n2. Nginx 将请求转发到 nextjs-ssr，nextjs-ssr 发出 `getInitialProps` 中的请求\n    请求内容：\n      url: http://gql-server.example.com/\n      headers:\n        host:  http://customer.example.com/\n\n3. Nginx 收到请求，发现 host 字段，又将请求转发到 `http://customer.example.com/`\n    Nginx 默认配置在请求 URL 和 host 字段之间会以 host 优先\n\n4. ... 死循环了，最终因为重定向过多，Nginx 返回对应错误码</code></pre><p>上述问题的解决很简单，将 host 置空或设置成正确的值。关于 host 字段的作用，我的认识如下。</p>\n<p>一个域名会被解析成 IP 对应到一台服务器，但这一台服务器上可能存在多个服务，在内部可以通过端口来区分，但出于各种原因，这台服务器往往只对外暴露部分端口，外部访问者这时候就可以额外通过 host 字段告诉服务器想要访问的服务。</p>\n<h1 id=\"GraphQL 服务\">GraphQL 服务<a name=\"GraphQL 服务\" class=\"headerlink\" href=\"#GraphQL 服务\"></a></h1><p>GraphQL 的搭建基本是一个学习的过程，虽然写过一些 Node.js 脚本，但对于 Node.js Server 的应用还是知之甚少。</p>\n<p>在编写完 demo 之后，感觉这个 <code>gql-server</code> 不算复杂，可能因为这个服务做的事情还是比较纯粹，只提供 GraphQL 服务。</p>\n<p>各种框架都有对应的方案，可以是 express、koa 等等，这里选择了 fastify，再结合相应的 apollo-server，最后添加 GraphQL 的 schema 即可。</p>\n<p>以上，都是马后炮 😅。</p>\n<p>不过值得一提的是，这里有一个库，让 GraphQL 和 TypeScript 的结合变得十分美好。不过在介绍之前，先了解一下痛点。</p>\n<p>了解过 GraphQL 之后会知道，GraphQL 的一大特点是强类型依赖，所以需要为服务编写很多的类型定义。</p>\n<p>一开始的时候，老老实实在 graphql 文件中编写 GraphQL 的类型定义。然后，在 TypeScript 中又要写一遍类型定义，显得很重复。而且，写下来后会发现两者十分相似。</p>\n<p>于是，开始寻找优化方案，从而发现了 <a href=\"https://github.com/19majkel94/type-graphql\">type-graphql</a>，结合了两者的使用。</p>\n<blockquote>\n<p>提前说明注意点：该库十分依赖装饰器语法和元数据（Decorator Metadata），两者目前为止都还没成为标准，正式使用需慎重。</p>\n</blockquote>\n<p>在 type-graphql 的基础上，只需要在 TypeScript 中编写 class 即可，class 会被转化为对应的 GraphQL 类型。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-meta\">@ObjectType</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Recipe</span> {\n  <span class=\"hljs-meta\">@Field</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span></span>) =&gt;</span> <span class=\"hljs-variable constant_\">ID</span>)\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-meta\">@Field</span>()\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-meta\">@Field</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span></span>) =&gt;</span> [<span class=\"hljs-title class_\">Rate</span>])\n  <span class=\"hljs-attr\">ratings</span>: <span class=\"hljs-title class_\">Rate</span>[];\n\n  <span class=\"hljs-meta\">@Field</span>({ <span class=\"hljs-attr\">nullable</span>: <span class=\"hljs-literal\">true</span> })\n  averageRating?: <span class=\"hljs-built_in\">number</span>;\n}</code></pre><p>上面的 class 会被转换成如下的类型。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Recipe</span> {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-variable constant_\">ID</span>!\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span>!\n  <span class=\"hljs-attr\">ratings</span>: [<span class=\"hljs-title class_\">Rate</span>!]!\n  <span class=\"hljs-attr\">averageRating</span>: <span class=\"hljs-title class_\">Float</span>\n}</code></pre><p>剩余的、也是主要的工作就是编写 resolvers。</p>\n<h1 id=\"结语\">结语<a name=\"结语\" class=\"headerlink\" href=\"#结语\"></a></h1><p>本文也终于到了结束的时候，总感觉还有遗漏的地方，只怪总结得不够及时。</p>\n<p>本文的 demo 基本是在老大哥（没错，又是那个杰哥）的基础上复刻的，本文最大的意义就是尽可能地将上述内容消化成自己的东西。如果能帮到此时的您，那更是本文的荣幸。</p>\n<p>对于 SSR 感受还是不错的，首屏的体验也是实打实的；如果觉得添加一个 Node.js 有成本，也十分建议尝试 Prerender，同样能享受到首屏的效果。</p>\n<p>对于 GraphQL 中间层的感受就有点爱恨交加了。字段查询、接口聚合、返回体自定义（不用忍受后端 😜）等功能都很好用，但是，得有人去维护一个个接口的对接，这一步也只能前端去做。不过总体而言还是很乐意去使用的。</p>\n<p>本文罗里吧嗦地也写了不少，若发现不当之处，还望斧正，感激不尽！</p>\n<hr>\n<p>参考链接 &amp; 推荐阅读：</p>\n<ul>\n<li><a href=\"https://github.com/zeit/next.js\">Next.js</a><ul>\n<li><a href=\"https://github.com/zeit/next.js/tree/canary/examples\">Next.js 官方 examples，十分推荐</a></li>\n</ul>\n</li>\n<li><a href=\"https://graphql.org/\">GraphQL</a> - <a href=\"https://graphql.cn/\">中文</a></li>\n<li><a href=\"https://www.apollographql.com/docs/\">Apollo GraphQL</a><ul>\n<li><a href=\"https://github.com/apollographql/react-apollo/\">Apollo React</a></li>\n<li><a href=\"https://github.com/apollographql/apollo-client\">Apollo Client</a></li>\n<li><a href=\"https://github.com/apollographql/apollo-server\">Apollo Server</a></li>\n</ul>\n</li>\n<li><a href=\"https://babeljs.io/docs/en/config-files#project-wide-configuration\">Babel - Config Files</a></li>\n<li><a href=\"https://github.com/fastify/fastify\">Fastify</a></li>\n<li><a href=\"https://stackoverflow.com/questions/43156023/what-is-http-host-header\">what-is-http-host-header</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host\">Host - MDN</a></li>\n</ul>\n","hash":"3da5ab4c3075862ff93e4ccf40d1fbbb","isArticle":true,"sort":0,"filename":"","raw":"","prev":{"id":"get-a-ssr-demo-step-by-step","slug":"post/get-a-ssr-demo-step-by-step","path":"/post/get-a-ssr-demo-step-by-step","title":"从零搭建 SSR","comments":true,"published":true,"date":"2019-07-02T17:10:37.000Z","updated":"","tags":[{"id":"1c16e694abe7b18f52484174b0aa3c87","name":"SSR","postCount":2,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<p>在上一季度中接触并使用了 Next.js，实践了一把 SSR。期间遇见了不少问题，详情可见：{% post_link use-summary-of-next-js-and-graphql %}。</p>\n<p>实际上是打算先写那篇文章，但这里还是来写这个了，这样能先从零开始认识 SSR。</p>\n<p>先放上 demo 地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo\">https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo</a>。</p>\n","more":"","hash":"fa0d0cba2d5d35f73989221cb638cf4c","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""},"next":{"id":"troubles-with-web-developing-in-weixin","slug":"post/troubles-with-web-developing-in-weixin","path":"/post/troubles-with-web-developing-in-weixin","title":"微信网页开发踩坑记录","comments":true,"published":true,"date":"2019-09-07T14:51:32.000Z","updated":"","tags":[],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<p>如标题所示，本文用于记录在微信中开发页面时所遇到的坑。</p>\n","more":"","hash":"70d0620b5d217df4184ef01c9afc8c55","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""}}