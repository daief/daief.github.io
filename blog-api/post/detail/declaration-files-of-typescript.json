{"id":"declaration-files-of-typescript","slug":"post/declaration-files-of-typescript","path":"/post/declaration-files-of-typescript","title":"TypeScript 中的声明文件","comments":true,"published":true,"date":"2018-09-04T21:10:44.000Z","updated":"","tags":[{"id":"558b544cf685f39d34e4903e39c38b67","name":"TypeScript","postCount":6,"postIds":[]},{"id":"ebbca6b4fc70d03f049d2857fa3e9489","name":"declaration-files","postCount":1,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]},{"id":"558b544cf685f39d34e4903e39c38b67","name":"TypeScript","slug":"categories/TypeScript","path":"/categories/TypeScript","parentId":"9abfe4a03928eb88a75a5cd95822dfef","postCount":4,"postIds":[]}],"excerpt":"<p>学习 TypeScript 稍微有一段时间了，每次写都会碰到有关声明文件的问题，目前为止暂未完全搞清楚，在此记录一些相关问题，以后碰到能够迅速解决。</p>\n","more":"\n\n<h1 id=\"声明文件（x.d.ts）\">声明文件（x.d.ts）<a name=\"声明文件（x.d.ts）\" class=\"headerlink\" href=\"#声明文件（x.d.ts）\"></a></h1><blockquote>\n<p><a href=\"https://www.cnblogs.com/niklai/p/6095974.html\">TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。</a></p>\n</blockquote>\n<p>在开始描述各种问题之前，列举一下我所知道的声明文件存放的方式（常规配置下）：</p>\n<ol>\n<li><code>src/@types/</code>，在 src 目录新建<code>@types</code>目录，在其中编写<code>.d.ts</code>声明文件，声明文件会自动被识别，可以在此为一些没有声明文件的模块编写自己的声明文件；</li>\n</ol>\n<p><strong>2018-10-31</strong>：实际上在 <code>tsconfig</code> <code>include</code> 字段包含的范围内编写 .d.ts，都将被自动识别。\n2. 在<code>x.js</code>相同目录创建同名声明文件<code>x.d.ts</code>，这样也会被自动识别；\n3. <code>node_modules/@types/</code>下存放各个第三方模块的声明文件，通过<code>yarn add @types/react</code>自动下载到此处，自己编写的声明文件不要放在这里；\n4. 作为 npm 模块发布时，声明文件可捆绑发布，需在<code>package.json</code>中指明<code>&quot;types&quot;: &quot;./types/index.d.ts&quot;</code>；\n5. <code>typings 声明管理器</code>，了解不多，已经不推荐使用；</p>\n<h1 id=\"隐式 any 类型（implicitly has an &#39;any&#39; type）\">隐式 any 类型（implicitly has an &#39;any&#39; type）<a name=\"隐式 any 类型（implicitly has an &#39;any&#39; type）\" class=\"headerlink\" href=\"#隐式 any 类型（implicitly has an &#39;any&#39; type）\"></a></h1><p>当 tsconfig.json 中关闭<code>&quot;noImplicitAny&quot;: false</code>时，可以直接在 TypeScript 中引用 JavaScript（无声明文件）的库，所有的引入都会被默认为<code>any</code>类型。但为了规范编码，总是打开<code>&quot;noImplicitAny&quot;: true</code>，这样当发生上述情况时，编译器会阻止编译，提示我们去加上类型规范。</p>\n<h2 id=\"TS 中导入 JS\">TS 中导入 JS<a name=\"TS 中导入 JS\" class=\"headerlink\" href=\"#TS 中导入 JS\"></a></h2><pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// hello.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">hello</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>)\n\n<span class=\"hljs-comment\">// index.ts</span>\n<span class=\"hljs-keyword\">import</span> {hello} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./hello&#x27;</span>\n<span class=\"hljs-comment\">// 如果使用 vscode，编辑器就会给出错误提示：</span>\n<span class=\"hljs-comment\">// [ts] 无法找到模块“./hello”的声明文件。“src/hello.js”隐式拥有 &quot;any&quot; 类型。</span>\n<span class=\"hljs-title function_\">hello</span>()\n\n<span class=\"hljs-comment\">// 如果执行编译，控制台也会给出同样的错误提示：</span>\n<span class=\"hljs-comment\">// Could not find a declaration file for module &#x27;./hello&#x27;. &#x27;src/hello.js&#x27; implicitly has an &#x27;any&#x27; type.</span></code></pre><p>这就告诉我们，若要在<code>index.ts</code>中使用<code>hello.js</code>，需要先为<code>hello.js</code>编写声明文件。</p>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/questions/35019987/what-does-declare-do-in-export-declare-class-actions\">关于 declare</a></p>\n</blockquote>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// hello.d.ts</span>\n<span class=\"hljs-comment\">// 描述 hello.js</span>\n<span class=\"hljs-keyword\">export</span> declare <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">hello</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">void</span>\n</code></pre><p>另一种书写方式，目前还没完全搞清两者本质区别：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// hello.d.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">as</span> namespace hello;\n\n<span class=\"hljs-keyword\">export</span> = hello;\n\ndeclare namespace hello {\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">hello</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">void</span>;\n}</code></pre><p>实际上，看了一些第三方模块的声明文件，形式也是五花八门，看得一头雾水，学得一头包……</p>\n<h2 id=\"TS 中导入 .png、.json 等\">TS 中导入 .png、.json 等<a name=\"TS 中导入 .png、.json 等\" class=\"headerlink\" href=\"#TS 中导入 .png、.json 等\"></a></h2><p>不止是在 TypeScript 中导入未声明 JavaScript，导入<code>.png</code>、<code>.json</code>等文件时也同样需要去编写声明文件。</p>\n<p>提供一种方式，可以创建一个声明文件<code>src/@types/definition.d.ts</code>（你也可以命名为其他），在其中编写如下声明：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// definition.d.ts</span>\ndeclare <span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">&#x27;*.png&#x27;</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">value</span>: string\n  <span class=\"hljs-keyword\">export</span> = value\n}\n\n<span class=\"hljs-comment\">// index.ts</span>\n<span class=\"hljs-comment\">// 之后在 TS 中导入也不会有问题</span>\n<span class=\"hljs-keyword\">import</span> avatar <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./img/avatar.png&#x27;</span>\n</code></pre><p>或者可以使用<code>require</code>：</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-keyword\">const</span> avatar = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./img/avatar.png&#x27;</span>)\n<span class=\"hljs-comment\">// 可能会提示 require 未定义，有两种方式：</span>\n<span class=\"hljs-comment\">//  1. 自行声明：declare const require: any</span>\n<span class=\"hljs-comment\">//  2. yarn add -D @types/node</span></code></pre><h2 id=\"第三方模块没有可用的声明文件\">第三方模块没有可用的声明文件<a name=\"第三方模块没有可用的声明文件\" class=\"headerlink\" href=\"#第三方模块没有可用的声明文件\"></a></h2><p>一般使用第三方不是 TypeScript 编写的模块时，我们可以直接下载对应的声明文件：<code>yarn add @types/{模块名}</code>。然而有些模块是没有对应的声明文件的，这时候就需要我们自己编写声明文件，以<code>rc-form</code>为例，只需在<code>src/@types/definition.d.ts</code>中添加对应代码即可：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// definition.d.ts</span>\ndeclare <span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">&#x27;*.png&#x27;</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">value</span>: string\n  <span class=\"hljs-keyword\">export</span> = value\n}\n\n<span class=\"hljs-comment\">// 新增部分</span>\ndeclare <span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">&quot;rc-form&quot;</span> {\n  <span class=\"hljs-comment\">// 在此只是简单地进行类型描述</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">createForm</span>: any;\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">createFormField</span>: any;\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">formShape</span>: any;\n}</code></pre><h1 id=\"webpack 别名（aliases）\">webpack 别名（aliases）<a name=\"webpack 别名（aliases）\" class=\"headerlink\" href=\"#webpack 别名（aliases）\"></a></h1><p>当 webpack 中配置了别名，在 TS 中使用时会出现<code>找不到模块</code>：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// webpack.config.js</span>\n<span class=\"hljs-keyword\">const</span> config = {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">aliases</span>: {\n    <span class=\"hljs-comment\">// 公共的工具类、容器和组件</span>\n    <span class=\"hljs-attr\">utils</span>: path.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;../utils&#x27;</span>),\n  },\n  <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-comment\">// index.ts</span>\n<span class=\"hljs-keyword\">import</span> {ua} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;utils/broswer&#x27;</span>\n<span class=\"hljs-comment\">// Cannot find module &#x27;utils/browser&#x27;</span></code></pre><p>只需在 tsconfig.json 添加<code>baseUrl</code>和<code>paths</code>的配置即可：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// tsconfig.json</span>\n{\n  <span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: {\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-string\">&quot;noImplicitAny&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-comment\">// 添加配置</span>\n    <span class=\"hljs-string\">&quot;baseUrl&quot;</span>: <span class=\"hljs-string\">&quot;.&quot;</span>,\n    <span class=\"hljs-string\">&quot;paths&quot;</span>: {\n      <span class=\"hljs-string\">&quot;utils/*&quot;</span>: [<span class=\"hljs-string\">&quot;../utils/*&quot;</span>],\n      <span class=\"hljs-string\">&quot;components/*&quot;</span>: [<span class=\"hljs-string\">&quot;../components/*&quot;</span>]\n    }\n  },\n  <span class=\"hljs-string\">&quot;include&quot;</span>: [<span class=\"hljs-string\">&quot;./src/*&quot;</span>, <span class=\"hljs-string\">&quot;./src/**/*&quot;</span>],\n  <span class=\"hljs-string\">&quot;exclude&quot;</span>: [<span class=\"hljs-string\">&quot;node_modules&quot;</span>]\n}</code></pre><h1 id=\"类型“Window”上不存在属性“X”\">类型“Window”上不存在属性“X”<a name=\"类型“Window”上不存在属性“X”\" class=\"headerlink\" href=\"#类型“Window”上不存在属性“X”\"></a></h1><p>有时候，直接通过 script、src 引入的对象在 window.X 是可以直接访问的，但在 TS 中直接使用时会提示不存在相应属性（The property &#39;X&#39; does not exist on value of type &#39;window&#39;），这时候需要对 window 进行扩展，直接在<code>src/@types/definition.d.ts</code>中扩展。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// definition.d.ts</span>\ninterface <span class=\"hljs-title class_\">Window</span> {\n  <span class=\"hljs-attr\">X</span>: any\n}\n\n<span class=\"hljs-comment\">// index.ts</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">X</span>) <span class=\"hljs-comment\">// success</span></code></pre><p>我在使用时，想复用一些类型，从其他文件导入了一些内容，这时候出现了问题：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// definition.d.ts</span>\n<span class=\"hljs-keyword\">import</span> {<span class=\"hljs-title class_\">IPerson</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./interfaces/index.ts&#x27;</span>\n\n<span class=\"hljs-comment\">// ...</span>\n\ninterface <span class=\"hljs-title class_\">Window</span> {\n  <span class=\"hljs-attr\">X</span>: any\n}\n\n\n<span class=\"hljs-comment\">// index.ts</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">X</span>) <span class=\"hljs-comment\">// fail: 类型“Window”上不存在属性“X”</span></code></pre><p>然后发现，套一层<code>global</code>又能恢复正常，但没有<code>import</code>语句时，使用<code>declare global</code>会提示错误：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// definition.d.ts</span>\n<span class=\"hljs-keyword\">import</span> {<span class=\"hljs-title class_\">IPerson</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./interfaces/index.ts&#x27;</span>\n\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-comment\">// global 包裹</span>\ndeclare <span class=\"hljs-variable language_\">global</span> {\n  interface <span class=\"hljs-title class_\">Window</span> {\n    <span class=\"hljs-attr\">X</span>: any\n  }\n}\n\n\n<span class=\"hljs-comment\">// index.ts</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">X</span>) <span class=\"hljs-comment\">// success</span></code></pre><hr>\n<p>未完，不定期补充。\n如有错误，欢迎指出；若能给予几句指导，不胜感激。😀</p>\n","hash":"e141cb5859a76e7ee025e59250a7c4ff","isArticle":true,"sort":0,"filename":"","raw":"","prev":{"id":"10-things-you-will-eventually-learn-about-javascript-projects","slug":"post/10-things-you-will-eventually-learn-about-javascript-projects","path":"/post/10-things-you-will-eventually-learn-about-javascript-projects","title":"[译] 前端编程中 10 条你需要了解的原则","comments":true,"published":true,"date":"2018-09-01T14:44:29.000Z","updated":"","tags":[{"id":"8b3607d0f4181a3cb6ffdccf7185f09b","name":"翻译","postCount":1,"postIds":[]}],"categories":[{"id":"8b3607d0f4181a3cb6ffdccf7185f09b","name":"翻译","slug":"categories/翻译","path":"/categories/翻译","parentId":"","postCount":1,"postIds":[]}],"excerpt":"<blockquote>\n<p>原文：<a href=\"https://blog.usejournal.com/10-things-you-will-eventually-learn-about-javascript-projects-efd7646b958a\">10 things you will eventually learn about javascript projects</a>\n翻译仅供学习</p>\n</blockquote>\n","more":"","hash":"7413f39f94d169699de9f370f997ab0a","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""},"next":{"id":"version-control-of-dependencies-in-package-json","slug":"post/version-control-of-dependencies-in-package-json","path":"/post/version-control-of-dependencies-in-package-json","title":"package.json 中依赖包的版本控制","comments":true,"published":true,"date":"2018-09-16T16:51:33.000Z","updated":"","tags":[{"id":"bb30e85411b56df41296726ab445dc8f","name":"npm","postCount":2,"postIds":[]},{"id":"b9cfc7f2cdf78a7f4b91a753d10865a2","name":"package.json","postCount":1,"postIds":[]},{"id":"7cbe8a17d291fd2ee3a83d2bd6ab023c","name":"语义化版本","postCount":1,"postIds":[]}],"categories":[{"id":"3b2819dd4c24eda2faf2052eef449551","name":"Node.js","slug":"categories/Node.js","path":"/categories/Node.js","parentId":"","postCount":2,"postIds":[]},{"id":"bb30e85411b56df41296726ab445dc8f","name":"npm","slug":"categories/npm","path":"/categories/npm","parentId":"3b2819dd4c24eda2faf2052eef449551","postCount":1,"postIds":[]}],"excerpt":"<p>在<code>package.json</code>中对依赖包的版本使用<code>^</code>、<code>~</code>等时需要注意的地方。\n<a href=\"https://docs.npmjs.com/files/package.json\">package.json 详细说明</a></p>\n","more":"","hash":"277d03204c743b8c2d27a4222af15ce9","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""}}