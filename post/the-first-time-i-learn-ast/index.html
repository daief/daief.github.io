<!DOCTYPE html>
<html  data-head-attrs="">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>初识 AST | daief的个人日志</title><meta property="og:title" content="初识 AST | daief的个人日志"><meta property="author" content="daief"><meta name="head:count" content="2">
<script>window.__INITIAL_STATE__={"global":{"site":{"postCount":51,"tagCount":42,"categoryCount":16,"site_pv":0,"page_pv":0,"site_uv":0},"indexPostPagination":{"current":1,"pageSize":10,"totalPages":0,"result":[]},"postDetail":{"post":{"id":"the-first-time-i-learn-ast","slug":"post/the-first-time-i-learn-ast","path":"/post/the-first-time-i-learn-ast","title":"初识 AST","comments":true,"published":true,"date":"2019-02-01T15:58:47.000Z","updated":"","tags":[{"id":"686155af75a60a0f6e9d80c1f7edd3e9","name":"JavaScript","postCount":16,"postIds":[]},{"id":"558b544cf685f39d34e4903e39c38b67","name":"TypeScript","postCount":6,"postIds":[]},{"id":"c77bb0f69e2a80e046a8dc7f0da9320f","name":"AST","postCount":1,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<blockquote>\n<p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>\n</blockquote>\n<p>Babel、UglifyJS2、ESLint、Webpack、TypeScript 等我们熟知的工具都包含 AST 的应用，实现了强大的功能。本文主要记录学习、应用 AST 的过程，主要内容：1. 解读 <a href=\"https://github.com/gaearon/react-hot-loader/blob/master/src/babel.dev.js\">react-hot-loader dev 环境下的 Babel 插件</a>；2. 编写对应的 TypeScript transformer 尽可能实现相同的功能。</p>\n","more":"\n\n<p><a href=\"https://github.com/gaearon/react-hot-loader#getting-started\">react-hot-loader/babel 是一个 Babel 插件</a>，用于帮助 RHL（reac-hot-loader）更好地工作。对于 TS 用户，官方的建议是使用 Babel 来进行 TS 的编译以发挥插件作用。但这可能会使 TS 用户感到困扰，因此尝试编写相应的 TS transformer 来实现相同的功能。</p>\n<h2 id=\"AST\">AST<a name=\"AST\" class=\"headerlink\" href=\"#AST\"></a></h2><p>顾名思义，AST 是一棵树，由一个个节点（Node）组成，每个节点拥有 Type 标识以表示各自的类型。</p>\n<p>Babel、TypeScript 的运行会经历以下流程（极简概括）：code ~&gt; AST ~&gt; code；同时他们开放了对应的 API 允许我们去操纵 AST，最终输出我们期望的结果。</p>\n<p>因为 AST 的节点类型很多，想要全部记住是十分困难的，推荐使用 <a href=\"https://astexplorer.net/\">AST explorer</a> 实时地查看，注意选择语言和相应的 parser。</p>\n<p>简单来说，操作 AST 的过程就是遍历 AST，当发现符合条件的节点时进行编辑，最终返回一棵新的 AST。</p>\n<h2 id=\"react-hot-loader/babel\">react-hot-loader/babel<a name=\"react-hot-loader/babel\" class=\"headerlink\" href=\"#react-hot-loader/babel\"></a></h2><h3 id=\"作用\">作用<a name=\"作用\" class=\"headerlink\" href=\"#作用\"></a></h3><p>让我们先简要了解该插件实际的表现：</p>\n<ul>\n<li>将默认导出声明 =&gt; 默认导出语句</li>\n<li>在每个文件模块顶部、底部插入内容</li>\n<li>在符合条件的类声明中插入名为 __reactstandin__regenerateByEval 的自定义方法</li>\n</ul>\n<p>具体例子，原代码内容：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-keyword\">import</span> P, { Q } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;left-pad&quot;</span>;\n<span class=\"hljs-keyword\">const</span> A = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">B</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">R</span>(<span class=\"hljs-params\"></span>) {}\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">S</span> {}\n  <span class=\"hljs-keyword\">const</span> T = <span class=\"hljs-number\">42</span>;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> {\n  <span class=\"hljs-title function_\">U</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">V</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">W</span> {}\n    }\n  }\n}\n<span class=\"hljs-keyword\">const</span> D = <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">X</span> {};\n<span class=\"hljs-keyword\">let</span> E = D;\n<span class=\"hljs-keyword\">var</span> Y = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;left-pad&quot;</span>);\n<span class=\"hljs-keyword\">var</span> { Z } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;left-pad&quot;</span>);\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createClass</span>({});</code></pre><p>经过转换的代码，该结果还包含降级为 ES5 的内容，注意区分：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-meta\">&quot;use strict&quot;</span>;\n\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(<span class=\"hljs-built_in\">exports</span>, <span class=\"hljs-string\">&quot;__esModule&quot;</span>, {\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">true</span>\n});\n<span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">C</span> = <span class=\"hljs-literal\">undefined</span>;\n\n<span class=\"hljs-keyword\">var</span> _createClass = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) { <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">defineProperties</span>(<span class=\"hljs-params\">target, props</span>) { <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; props.<span class=\"hljs-property\">length</span>; i++) { <span class=\"hljs-keyword\">var</span> descriptor = props[i]; descriptor.<span class=\"hljs-property\">enumerable</span> = descriptor.<span class=\"hljs-property\">enumerable</span> || <span class=\"hljs-literal\">false</span>; descriptor.<span class=\"hljs-property\">configurable</span> = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;value&quot;</span> <span class=\"hljs-keyword\">in</span> descriptor) descriptor.<span class=\"hljs-property\">writable</span> = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(target, descriptor.<span class=\"hljs-property\">key</span>, descriptor); } } <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Constructor, protoProps, staticProps</span>) { <span class=\"hljs-keyword\">if</span> (protoProps) <span class=\"hljs-title function_\">defineProperties</span>(<span class=\"hljs-title class_\">Constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, protoProps); <span class=\"hljs-keyword\">if</span> (staticProps) <span class=\"hljs-title function_\">defineProperties</span>(<span class=\"hljs-title class_\">Constructor</span>, staticProps); <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Constructor</span>; }; }();\n\n<span class=\"hljs-keyword\">var</span> _leftPad = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;left-pad&quot;</span>);\n\n<span class=\"hljs-keyword\">var</span> _leftPad2 = <span class=\"hljs-title function_\">_interopRequireDefault</span>(_leftPad);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_interopRequireDefault</span>(<span class=\"hljs-params\">obj</span>) { <span class=\"hljs-keyword\">return</span> obj &amp;&amp; obj.<span class=\"hljs-property\">__esModule</span> ? obj : { <span class=\"hljs-attr\">default</span>: obj }; }\n\n<span class=\"hljs-comment\">/* ---------- 顶部内容 */</span>\n(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">var</span> enterModule = (<span class=\"hljs-keyword\">typeof</span> reactHotLoaderGlobal !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> ? reactHotLoaderGlobal : <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;react-hot-loader&#x27;</span>)).<span class=\"hljs-property\">enterModule</span>;\n  enterModule &amp;&amp; <span class=\"hljs-title function_\">enterModule</span>(<span class=\"hljs-variable language_\">module</span>);\n})();\n<span class=\"hljs-comment\">/* ---------- 顶部内容 end */</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_classCallCheck</span>(<span class=\"hljs-params\">instance, Constructor</span>) { <span class=\"hljs-keyword\">if</span> (!(instance <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Constructor</span>)) { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&quot;Cannot call a class as a function&quot;</span>); } }\n\n<span class=\"hljs-keyword\">var</span> A = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">B</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">R</span>(<span class=\"hljs-params\"></span>) {}\n\n  <span class=\"hljs-keyword\">var</span> S = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">S</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">_classCallCheck</span>(<span class=\"hljs-variable language_\">this</span>, S);\n  };\n\n  <span class=\"hljs-keyword\">var</span> T = <span class=\"hljs-number\">42</span>;\n}\n\n<span class=\"hljs-keyword\">var</span> C = <span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">C</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">C</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">_classCallCheck</span>(<span class=\"hljs-variable language_\">this</span>, C);\n  }\n\n  <span class=\"hljs-title function_\">_createClass</span>(C, [{\n    <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&quot;U&quot;</span>,\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">U</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">V</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">var</span> W = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">W</span>(<span class=\"hljs-params\"></span>) {\n          <span class=\"hljs-title function_\">_classCallCheck</span>(<span class=\"hljs-variable language_\">this</span>, W);\n        };\n      }\n    }\n  }, {\n    <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&quot;__reactstandin__regenerateByEval&quot;</span>,\n    <span class=\"hljs-comment\">// @ts-ignore</span>\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">__reactstandin__regenerateByEval</span>(<span class=\"hljs-params\">key, code</span>) {\n      <span class=\"hljs-comment\">// @ts-ignore</span>\n      <span class=\"hljs-variable language_\">this</span>[key] = <span class=\"hljs-built_in\">eval</span>(code);\n    }\n  }]);\n\n  <span class=\"hljs-keyword\">return</span> C;\n}();\n\n<span class=\"hljs-keyword\">var</span> D = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">X</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">_classCallCheck</span>(<span class=\"hljs-variable language_\">this</span>, X);\n};\n<span class=\"hljs-keyword\">var</span> E = D;\n<span class=\"hljs-keyword\">var</span> Y = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;left-pad&quot;</span>);\n\n<span class=\"hljs-keyword\">var</span> _require = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;left-pad&quot;</span>),\n    Z = _require.<span class=\"hljs-property\">Z</span>;\n\n<span class=\"hljs-keyword\">var</span> _default = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createClass</span>({\n  <span class=\"hljs-attr\">displayName</span>: <span class=\"hljs-string\">&quot;_default&quot;</span>\n});\n\n<span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">default</span> = _default;\n;\n\n<span class=\"hljs-comment\">/* ---------- 底部内容 */</span>\n(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">var</span> reactHotLoader = (<span class=\"hljs-keyword\">typeof</span> reactHotLoaderGlobal !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> ? reactHotLoaderGlobal : <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;react-hot-loader&#x27;</span>)).<span class=\"hljs-property\">default</span>;\n\n  <span class=\"hljs-keyword\">if</span> (!reactHotLoader) {\n    <span class=\"hljs-keyword\">return</span>;\n  }\n\n  reactHotLoader.<span class=\"hljs-title function_\">register</span>(A, <span class=\"hljs-string\">&quot;A&quot;</span>, __FILENAME__);\n  reactHotLoader.<span class=\"hljs-title function_\">register</span>(B, <span class=\"hljs-string\">&quot;B&quot;</span>, __FILENAME__);\n  reactHotLoader.<span class=\"hljs-title function_\">register</span>(C, <span class=\"hljs-string\">&quot;C&quot;</span>, __FILENAME__);\n  reactHotLoader.<span class=\"hljs-title function_\">register</span>(D, <span class=\"hljs-string\">&quot;D&quot;</span>, __FILENAME__);\n  reactHotLoader.<span class=\"hljs-title function_\">register</span>(E, <span class=\"hljs-string\">&quot;E&quot;</span>, __FILENAME__);\n  reactHotLoader.<span class=\"hljs-title function_\">register</span>(_default, <span class=\"hljs-string\">&quot;default&quot;</span>, __FILENAME__);\n})();\n\n;\n\n(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">var</span> leaveModule = (<span class=\"hljs-keyword\">typeof</span> reactHotLoaderGlobal !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> ? reactHotLoaderGlobal : <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;react-hot-loader&#x27;</span>)).<span class=\"hljs-property\">leaveModule</span>;\n  leaveModule &amp;&amp; <span class=\"hljs-title function_\">leaveModule</span>(<span class=\"hljs-variable language_\">module</span>);\n})();\n<span class=\"hljs-comment\">/* ---------- 底部内容 end */</span></code></pre><h3 id=\"实现\">实现<a name=\"实现\" class=\"headerlink\" href=\"#实现\"></a></h3><p>源码：<a href=\"https://github.com/gaearon/react-hot-loader/blob/master/src/babel.dev.js。\">https://github.com/gaearon/react-hot-loader/blob/master/src/babel.dev.js。</a></p>\n<p>可以看到插件实际上是一个方法，形如：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">plugin</span>(<span class=\"hljs-params\">args, options = {}</span>) {\n  <span class=\"hljs-keyword\">const</span> { types, template } = args;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">visitor</span>: {\n      <span class=\"hljs-title class_\">ExportDefaultDeclaration</span>(path, state) {\n        <span class=\"hljs-comment\">// ...</span>\n      },\n      <span class=\"hljs-title class_\">Program</span>: {\n        <span class=\"hljs-title function_\">enter</span>(<span class=\"hljs-params\">{ scope }, state</span>) {\n          <span class=\"hljs-comment\">// ...</span>\n        },\n        <span class=\"hljs-title function_\">exit</span>(<span class=\"hljs-params\">{ node }, state</span>) {\n          <span class=\"hljs-comment\">// ...</span>\n        },\n      },\n      <span class=\"hljs-title class_\">Class</span>(path) {\n        <span class=\"hljs-comment\">// ...</span>\n      },\n    },\n  }\n}</code></pre><p>插件方法返回了一个对象，包含一个 visitor 对象，而 visitor 对象中又定义了 ExportDefaultDeclaration、Program 和 Class 的内容。这是一个用于遍历 AST 的访问者模式，当这样定义后，每当遍历到 ExportDefaultDeclaration 节点，就会调用相应的 ExportDefaultDeclaration 方法；而对于树节点的访问，会在进入、离开共发生两次，默认在进入节点时调用，也可以通过 enter、exit 进行指定调用时机，其他定义的节点同理。</p>\n<p>插件的第一个参数中可以拿到 <code>types</code>、<code>template</code> 两个对象，分别对应 <a href=\"https://babeljs.io/docs/en/babel-types\">@babel/types</a>、<a href=\"https://babeljs.io/docs/en/babel-template\">@babel/template</a>。这是两个十分有用的对象，详情可参照链接及插件源码，以下作简单说明：</p>\n<blockquote>\n<p>@babel/types\n是一个用于 AST 节点的工具库，包含了构造、验证以及变换 AST 节点的方法。该工具库包含考虑周到的工具方法，对编写处理AST逻辑非常有用。</p>\n</blockquote>\n<blockquote>\n<p>@babel/template\n让编写字符串形式且带有占位符的代码来代替手动编码，尤其是生成的大规模 AST 的时候。在计算机科学中，这种能力被称为准引用（quasiquotes）。</p>\n</blockquote>\n<p>visitor 中的每个函数接收 <code>path</code> 和 <code>state</code> 两个参数。</p>\n<blockquote>\n<p>path\n表示两个节点之间的连接，通过这个对象我们可以访问到节点、父节点以及进行一系列跟节点操作相关的方法（类似 DOM 的操作）。</p>\n</blockquote>\n<p>关于 state，没能找到比较好的概念说明，目前为止只了解到一些相关的作用：1. 在 state 中可以拿到插件接收的 options；2. 可以通过 state 对象在不同 visitor 函数中进行数据传递。</p>\n<p>最后来看看 Class 节点遍历中做了什么：</p>\n<blockquote>\n<p>Class 类型是别名，包括 classDeclaration、classExpression。</p>\n</blockquote>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// 以下的 t 即上文提及的 @babel/types</span>\n{\n  <span class=\"hljs-title class_\">Class</span>(classPath) {\n    <span class=\"hljs-comment\">// 拿到 class 声明的 body</span>\n    <span class=\"hljs-keyword\">const</span> classBody = classPath.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;body&#x27;</span>)\n\n    <span class=\"hljs-comment\">// 以下两个变量用于后面判断该 class 节点是否需要注入方法</span>\n    <span class=\"hljs-keyword\">let</span> hasRegenerateMethod = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">let</span> hasMethods = <span class=\"hljs-literal\">false</span>\n\n    <span class=\"hljs-comment\">// 遍历 classBody 判断注入的必要性</span>\n    classBody.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;body&#x27;</span>).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">path</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> { node } = path\n\n      <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">static</span>) {\n        <span class=\"hljs-keyword\">return</span>\n      }\n\n      <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">key</span>.<span class=\"hljs-property\">name</span> !== <span class=\"hljs-variable constant_\">REGENERATE_METHOD</span>) {\n        hasMethods = <span class=\"hljs-literal\">true</span>\n      } <span class=\"hljs-keyword\">else</span> {\n        hasRegenerateMethod = <span class=\"hljs-literal\">true</span>\n      }\n    })\n\n    <span class=\"hljs-comment\">// 符合条件时，注入方法</span>\n    <span class=\"hljs-keyword\">if</span> (hasMethods &amp;&amp; !hasRegenerateMethod) {\n      <span class=\"hljs-comment\">// 创建一个类方法</span>\n      <span class=\"hljs-keyword\">const</span> regenerateMethod = t.<span class=\"hljs-title function_\">classMethod</span>(\n        <span class=\"hljs-string\">&#x27;method&#x27;</span>,\n        t.<span class=\"hljs-title function_\">identifier</span>(<span class=\"hljs-variable constant_\">REGENERATE_METHOD</span>),\n        [t.<span class=\"hljs-title function_\">identifier</span>(<span class=\"hljs-string\">&#x27;key&#x27;</span>), t.<span class=\"hljs-title function_\">identifier</span>(<span class=\"hljs-string\">&#x27;code&#x27;</span>)],\n        t.<span class=\"hljs-title function_\">blockStatement</span>([\n          <span class=\"hljs-comment\">// 将字符串代码转换为 AST</span>\n          <span class=\"hljs-title function_\">template</span>(<span class=\"hljs-string\">&#x27;this[key]=eval(code);&#x27;</span>, templateOptions)()\n        ]),\n      )\n\n      <span class=\"hljs-comment\">// 将新建的类方法插入 classBody</span>\n      classBody.<span class=\"hljs-title function_\">pushContainer</span>(<span class=\"hljs-string\">&#x27;body&#x27;</span>, regenerateMethod)\n\n      <span class=\"hljs-comment\">// 最后在插入的方法内外添加两条注释</span>\n      classBody.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;body&#x27;</span>).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">path</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">const</span> { node } = path\n\n        <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">key</span>.<span class=\"hljs-property\">name</span> === <span class=\"hljs-variable constant_\">REGENERATE_METHOD</span>) {\n          path.<span class=\"hljs-title function_\">addComment</span>(<span class=\"hljs-string\">&#x27;leading&#x27;</span>, <span class=\"hljs-string\">&#x27; @ts-ignore&#x27;</span>, <span class=\"hljs-literal\">true</span>)\n          path\n            .<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;body&#x27;</span>)\n            .<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;body&#x27;</span>)[<span class=\"hljs-number\">0</span>]\n            .<span class=\"hljs-title function_\">addComment</span>(<span class=\"hljs-string\">&#x27;leading&#x27;</span>, <span class=\"hljs-string\">&#x27; @ts-ignore&#x27;</span>, <span class=\"hljs-literal\">true</span>)\n        }\n      })\n    }\n  },\n}</code></pre><h2 id=\"ts-rhl-transformer\">ts-rhl-transformer<a name=\"ts-rhl-transformer\" class=\"headerlink\" href=\"#ts-rhl-transformer\"></a></h2><p>TypeScript 在编译时也会产生一棵 AST，我们同样可以借助相应的 API 去操作这棵树，以实现期望的效果。编写 TS 的 transformer 与 Babel 插件有不少相同的地方，同样通过 visitor 对象去遍历节点。需要注意的是，两者在书写方式和节点类型上有许多不同。这里介绍的 TS transformer 是基于 Webpack 环境下运行的，使用方法可参照 <a href=\"https://github.com/Igorbek/typescript-plugin-styled-components#integration-with-webpack\">typescript-plugin-styled-components</a>。</p>\n<p>首先来看 transformer 的整体情况：</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> ts <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;typescript&#x27;</span>;\n\n<span class=\"hljs-comment\">// 插件也是一个方法，该方法返回一个 transformer 对象</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createTransformer</span>(<span class=\"hljs-params\"></span>) {\n\n  <span class=\"hljs-comment\">// transformer 对象</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">transformer</span>: ts.<span class=\"hljs-property\">TransformerFactory</span>&lt;ts.<span class=\"hljs-property\">SourceFile</span>&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">context</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">transformerNode</span> =&gt;</span> {\n\n      <span class=\"hljs-comment\">// 自定义 visitor</span>\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">visitorClassLike</span>: ts.<span class=\"hljs-property\">Visitor</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (ts.<span class=\"hljs-title function_\">isClassLike</span>(node)) {\n          <span class=\"hljs-comment\">// 当节点类型符合条件时执行逻辑</span>\n\n          <span class=\"hljs-comment\">// ...</span>\n\n          <span class=\"hljs-comment\">// 如果需要递归遍历，一定要返回 ts.visitEachChild</span>\n          <span class=\"hljs-keyword\">return</span> ts.<span class=\"hljs-title function_\">visitEachChild</span>(node, visitorClassLike, context);\n        }\n        <span class=\"hljs-keyword\">return</span> ts.<span class=\"hljs-title function_\">visitEachChild</span>(node, visitorClassLike, context);\n      }; <span class=\"hljs-comment\">// ------- 自定义 visitor end</span>\n\n      <span class=\"hljs-comment\">// 这里的 transformerNode 又称之为 SourceFile，是根节点</span>\n      <span class=\"hljs-keyword\">return</span> ts.<span class=\"hljs-title function_\">visitNode</span>(transformerNode, visitorClassLike);\n    }\n  };\n\n  <span class=\"hljs-keyword\">return</span> transformer;\n}</code></pre><p>在 TS transformer 的编写中，我们能用的 API 基本都在 ts 对象中。下面，来看看如何在此同样实现在类声明中插入自定义方法。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-comment\">/**\n * 自定义 class visitor，用于访问 class 并注入自定义方法\n */</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">visitorClassLike</span>: ts.<span class=\"hljs-property\">Visitor</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> {\n  <span class=\"hljs-comment\">// isClassLike 类似于 babel 中的 class 别名，包括 ClassDeclaration、ClassExpression 两者情况</span>\n  <span class=\"hljs-comment\">// 此判断确保只对该类型节点进行操作</span>\n  <span class=\"hljs-keyword\">if</span> (ts.<span class=\"hljs-title function_\">isClassLike</span>(node)) {\n    <span class=\"hljs-comment\">// 同样的两个用于判断的变量</span>\n    <span class=\"hljs-keyword\">let</span> hasRegenerateMethod = <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-keyword\">let</span> hasMethods = <span class=\"hljs-literal\">false</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 遍历类成员进行判断\n     */</span>\n    node.<span class=\"hljs-property\">members</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">classEle</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">let</span> hasStatic = <span class=\"hljs-literal\">false</span>;\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> ele <span class=\"hljs-keyword\">of</span> classEle.<span class=\"hljs-property\">modifiers</span> || []) {\n        <span class=\"hljs-keyword\">if</span> (ele.<span class=\"hljs-property\">kind</span> === ts.<span class=\"hljs-property\">SyntaxKind</span>.<span class=\"hljs-property\">StaticKeyword</span>) {\n          hasStatic = <span class=\"hljs-literal\">true</span>;\n          <span class=\"hljs-keyword\">break</span>;\n        }\n      }\n\n      <span class=\"hljs-keyword\">if</span> (hasStatic) {\n        <span class=\"hljs-keyword\">return</span>;\n      }\n\n      <span class=\"hljs-comment\">// notice node type check</span>\n      <span class=\"hljs-keyword\">if</span> (\n        ts.<span class=\"hljs-title function_\">isMethodDeclaration</span>(classEle) ||\n        ts.<span class=\"hljs-title function_\">isPropertyDeclaration</span>(classEle) ||\n        ts.<span class=\"hljs-title function_\">isConstructorDeclaration</span>(classEle)\n      ) {\n        <span class=\"hljs-keyword\">const</span> propName = classEle.<span class=\"hljs-property\">name</span> ? classEle.<span class=\"hljs-property\">name</span>.<span class=\"hljs-title function_\">getText</span>() : <span class=\"hljs-string\">&#x27;constructor&#x27;</span>;\n        hasMethods = propName !== <span class=\"hljs-variable constant_\">REGENERATE_METHOD</span>;\n        hasRegenerateMethod = propName === <span class=\"hljs-variable constant_\">REGENERATE_METHOD</span>;\n      }\n    });\n\n    <span class=\"hljs-keyword\">if</span> (hasMethods &amp;&amp; !hasRegenerateMethod) {\n      <span class=\"hljs-comment\">/**\n       * 符合条件，新建类方法\n       */</span>\n      <span class=\"hljs-keyword\">const</span> method = ts.<span class=\"hljs-title function_\">createMethod</span>(\n        <span class=\"hljs-literal\">undefined</span>,\n        <span class=\"hljs-literal\">undefined</span>,\n        <span class=\"hljs-literal\">undefined</span>,\n        <span class=\"hljs-comment\">// method name</span>\n        <span class=\"hljs-variable constant_\">REGENERATE_METHOD</span>,\n        <span class=\"hljs-literal\">undefined</span>,\n        <span class=\"hljs-literal\">undefined</span>,\n        <span class=\"hljs-comment\">// parameters -- 方法参数</span>\n        [\n          ts.<span class=\"hljs-title function_\">createParameter</span>(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">&#x27;key&#x27;</span>),\n          ts.<span class=\"hljs-title function_\">createParameter</span>(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">&#x27;code&#x27;</span>),\n        ],\n        <span class=\"hljs-literal\">undefined</span>,\n        <span class=\"hljs-comment\">// method body -- 方法体内容</span>\n        ts.<span class=\"hljs-title function_\">createBlock</span>([\n          ts.<span class=\"hljs-title function_\">createExpressionStatement</span>(ts.<span class=\"hljs-title function_\">createIdentifier</span>(<span class=\"hljs-string\">&#x27;this[key] = eval(code)&#x27;</span>)),\n        ])\n      );\n\n      <span class=\"hljs-comment\">// 通过 update 为前缀的方法更新节点，将当前 node 进行更新</span>\n      <span class=\"hljs-comment\">// 并进行递归访问</span>\n      <span class=\"hljs-comment\">// 因为实际上有两种类声明方式，这里做了下区分</span>\n      <span class=\"hljs-keyword\">return</span> ts.<span class=\"hljs-title function_\">visitEachChild</span>(\n        ts.<span class=\"hljs-title function_\">isClassDeclaration</span>(node)\n          ? ts.<span class=\"hljs-title function_\">updateClassDeclaration</span>(\n              node,\n              node.<span class=\"hljs-property\">decorators</span>,\n              node.<span class=\"hljs-property\">modifiers</span>,\n              node.<span class=\"hljs-property\">name</span>,\n              node.<span class=\"hljs-property\">typeParameters</span>,\n              node.<span class=\"hljs-property\">heritageClauses</span>,\n              node.<span class=\"hljs-property\">members</span>.<span class=\"hljs-title function_\">concat</span>([method])\n            )\n          : ts.<span class=\"hljs-title function_\">updateClassExpression</span>(\n              node,\n              node.<span class=\"hljs-property\">modifiers</span>,\n              node.<span class=\"hljs-property\">name</span>,\n              node.<span class=\"hljs-property\">typeParameters</span>,\n              node.<span class=\"hljs-property\">heritageClauses</span>,\n              node.<span class=\"hljs-property\">members</span>.<span class=\"hljs-title function_\">concat</span>([method])\n            ),\n        visitorClassLike,\n        context\n      );\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> ts.<span class=\"hljs-title function_\">visitEachChild</span>(node, visitorClassLike, context);\n};</code></pre><p><code>ts.createIdentifier</code> 可实现与 @babel/template 相似的功能，只是没那么强大，缺少占位符替换等功能。</p>\n<p><a href=\"https://github.com/daief/jugg/blob/master/packages/jugg-plugin-react/src/ts-rhl-transformer/ts-rhl-transformer.dev.ts\">完整源码查看这里</a>。编写过程中参照了不少大佬 <a href=\"https://github.com/Jetsly\">@Jetsly</a> 的实现，获得了不小的帮助，感谢大佬（<a href=\"https://github.com/Jetsly/ts-react-hot-transformer\">大佬的仓库</a>）。</p>\n<p>本节最后来看看该插件实现的效果，前后代码转换对比（本过程不涉及 ES 降级）：</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-comment\">/* --------------- 原始代码 --------------- */</span>\n<span class=\"hljs-keyword\">import</span> P, { Q } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;left-pad&quot;</span>;\n<span class=\"hljs-keyword\">const</span> A = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">B</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">R</span>(<span class=\"hljs-params\"></span>) {}\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">S</span> {}\n  <span class=\"hljs-keyword\">const</span> T = <span class=\"hljs-number\">42</span>;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> {\n  <span class=\"hljs-title function_\">U</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">V</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">W</span> {}\n    }\n  }\n}\n<span class=\"hljs-keyword\">const</span> D = <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">X</span> {};\n<span class=\"hljs-keyword\">let</span> E = D;\n<span class=\"hljs-keyword\">var</span> Y = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;left-pad&quot;</span>);\n<span class=\"hljs-keyword\">var</span> { Z } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;left-pad&quot;</span>);\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createClass</span>({});\n\n\n<span class=\"hljs-comment\">/* --------------- 转换结果 --------------- */</span>\n(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">var</span> enterModule = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;react-hot-loader&#x27;</span>).<span class=\"hljs-property\">enterModule</span>;\n  enterModule &amp;&amp; <span class=\"hljs-title function_\">enterModule</span>(<span class=\"hljs-variable language_\">module</span>);\n}())\n;\n\n\n;\n<span class=\"hljs-keyword\">import</span> P, { Q } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;left-p&quot;</span>;\n<span class=\"hljs-keyword\">const</span> A = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">B</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">R</span>(<span class=\"hljs-params\"></span>) { }\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">S</span> {\n    }\n    <span class=\"hljs-keyword\">const</span> T = <span class=\"hljs-number\">42</span>;\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> {\n    <span class=\"hljs-title function_\">U</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">V</span>(<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">W</span> {\n            }\n        }\n    }\n    <span class=\"hljs-title function_\">__reactstandin__regenerateByEval</span>(<span class=\"hljs-params\">key, code</span>) { <span class=\"hljs-variable language_\">this</span>[key] = <span class=\"hljs-built_in\">eval</span>(code); }\n}\n<span class=\"hljs-keyword\">const</span> D = <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">X</span> {\n};\n<span class=\"hljs-keyword\">let</span> E = D;\n<span class=\"hljs-keyword\">var</span> Y = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;left-pad&quot;</span>);\n<span class=\"hljs-keyword\">var</span> { Z } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;left-pad&quot;</span>);\n<span class=\"hljs-keyword\">const</span> _default_1 = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createClass</span>({})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> _default_1;\n\n\n;\n(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n<span class=\"hljs-keyword\">var</span> reactHotLoader = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;react-hot-loader&#x27;</span>).<span class=\"hljs-property\">default</span>;\n<span class=\"hljs-keyword\">var</span> leaveModule = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;react-hot-loader&#x27;</span>).<span class=\"hljs-property\">leaveModule</span>;\n<span class=\"hljs-keyword\">if</span> (!reactHotLoader) {\n  <span class=\"hljs-keyword\">return</span>;\n}\n; reactHotLoader.<span class=\"hljs-title function_\">register</span>(A, <span class=\"hljs-string\">&quot;A&quot;</span>, <span class=\"hljs-string\">&quot;bindings.js&quot;</span>);\n; reactHotLoader.<span class=\"hljs-title function_\">register</span>(B, <span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-string\">&quot;bindings.js&quot;</span>);\n; reactHotLoader.<span class=\"hljs-title function_\">register</span>(C, <span class=\"hljs-string\">&quot;C&quot;</span>, <span class=\"hljs-string\">&quot;bindings.js&quot;</span>);\n; reactHotLoader.<span class=\"hljs-title function_\">register</span>(D, <span class=\"hljs-string\">&quot;D&quot;</span>, <span class=\"hljs-string\">&quot;bindings.js&quot;</span>);\n; reactHotLoader.<span class=\"hljs-title function_\">register</span>(E, <span class=\"hljs-string\">&quot;E&quot;</span>, <span class=\"hljs-string\">&quot;bindings.js&quot;</span>);\n; reactHotLoader.<span class=\"hljs-title function_\">register</span>(_default_1, <span class=\"hljs-string\">&quot;default&quot;</span>, <span class=\"hljs-string\">&quot;bindings.js&quot;</span>);\n; <span class=\"hljs-title function_\">leaveModule</span>(<span class=\"hljs-variable language_\">module</span>); }());</code></pre><h2 id=\"结语\">结语<a name=\"结语\" class=\"headerlink\" href=\"#结语\"></a></h2><p>修改 AST 的时候一定要十分小心，注意涉及范围的节点类型、作用域等内容，不要影响了无辜的代码。树的节点类型很多，极其建议在编写时结合 AST explorer 等可视化工具进行查看。</p>\n<p>通过 AST 可以实现各种各样强大、有趣的功能，用来解决、优化日常的编程。</p>\n<p>只要有想法，就能玩出花。</p>\n<p>完。</p>\n<hr>\n<p>参考链接 &amp; 推荐阅读：</p>\n<ul>\n<li><a href=\"https://dev.doctorevidence.com/how-to-write-a-typescript-transform-plugin-fc5308fdd943\">How to Write a TypeScript Transform (Plugin)</a></li>\n<li><a href=\"https://astexplorer.net/\">AST explorer</a></li>\n<li><a href=\"https://juejin.im/post/5a0a54425188253edc7f6e79\">手把手教写 TypeScript Transformer Plugin</a></li>\n<li><a href=\"https://blog.kevinyang.net/2018/08/17/typescript-compiler/\">[TypeScript] Compiler API 第一次接觸</a></li>\n<li><a href=\"https://juejin.im/post/5ab9f2f3f265da239b4174f0\">babel插件入门-AST（抽象语法树）</a></li>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md\">Babel 插件手册</a></li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md\">TypeScript Language Specification</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md\">babel-parser ast spec</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/32189701\">AST in Modern JavaScript</a></li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/\">深入理解 TypeScript</a></li>\n<li><a href=\"https://babeljs.io/docs/en/\">Babel Doc</a></li>\n<li><a href=\"http://taobaofed.org/blog/2016/09/30/babel-plugins/\">理解 Babel 插件</a></li>\n<li><a href=\"https://github.com/Igorbek/typescript-plugin-styled-components\">typescript-plugin-styled-components</a></li>\n<li><a href=\"https://github.com/gaearon/react-hot-loader/blob/master/src/babel.dev.js\">react-hot-loader@4.x/babel</a></li>\n<li><a href=\"https://github.com/Jetsly/ts-react-hot-transformer\">ts-react-hot-transformer</a></li>\n<li><a href=\"https://github.com/daief/jugg/tree/master/packages/jugg-plugin-react/src/ts-rhl-transformer\">@axew/jugg-plugin-react/lib/ts-rhl-transformer</a></li>\n</ul>\n","hash":"02f7d4aab4ea924a95a4911037728cce","isArticle":true,"sort":0,"filename":"","raw":"","prev":{"id":"try-to-improve-spa-load-performance","slug":"post/try-to-improve-spa-load-performance","path":"/post/try-to-improve-spa-load-performance","title":"记一次单页应用的加载优化","comments":true,"published":true,"date":"2018-12-25T23:54:23.000Z","updated":"","tags":[{"id":"aa491df98d63f0894f18087bb142d472","name":"SPA","postCount":1,"postIds":[]},{"id":"c05f6c233521207f6fe311afef550c3c","name":"performance","postCount":1,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<p>如今的前端页面越来越丰富了，承载着各种功能。而随之增长的则是相应的代码量，加上三方 SDK 的接入以及单页应用（SPA）的特性，一次页面访问会出现慢的感觉，是时候来关注页面的加载优化了。</p>\n<p>本文简略描述关于 React 单页应用的加载优化，下文所指加载一般包括下载、执行两个步骤。</p>\n","more":"","hash":"841f07f21ec8a4a0ad4e99cd03c03680","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""},"next":{"id":"happy-vue-with-typescript","slug":"post/happy-vue-with-typescript","path":"/post/happy-vue-with-typescript","title":"用 TypeScript 来写 Vue！","comments":true,"published":true,"date":"2019-02-12T17:25:59.000Z","updated":"","tags":[{"id":"2d8ec58babcec05d3fe8f712968de749","name":"Vue","postCount":5,"postIds":[]},{"id":"558b544cf685f39d34e4903e39c38b67","name":"TypeScript","postCount":6,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]},{"id":"558b544cf685f39d34e4903e39c38b67","name":"TypeScript","slug":"categories/TypeScript","path":"/categories/TypeScript","parentId":"9abfe4a03928eb88a75a5cd95822dfef","postCount":4,"postIds":[]}],"excerpt":"<p>本文不说明 webpack 的配置，简单介绍如何使用 TypeScript 来书写 Vue，阅读本文应同时对 TypeScript 和 Vue 有一定的了解。</p>\n","more":"","hash":"51210fa84cdec43a85618dcc63453245","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""}}},"tocHtml":"","simplePages":[{"id":"41a3cc43f8af362b82fbe2aa97817528","slug":"resume","path":"/resume"},{"id":"fabb5629b694584be9ff314ab8187577","slug":"resume-v2","path":"/resume-v2"},{"id":"34787f8e18c76ce0f4c3cc680ab728ef","slug":"resume-v1","path":"/resume-v1"},{"id":"ac298b1fdf5a34ac83bb9376ccdde006","slug":"about","path":"/about"}],"simplePageDetail":{"post":null}},"labels":{"labels":[],"postPagination":{"current":1,"pageSize":10,"totalPages":0,"result":[]}}}</script>
    <script>
      if (/MSIE \d|Trident.*rv:/.test(navigator.userAgent)) {
        // redirect IE to Edge
        // This browser is no longer supported
        window.location.href = 'microsoft-edge:' + window.location.href;
        alert('请使用 Chrome/Edge/Firefox/Safari 等现代浏览器。');
        throw new Error('请使用 Chrome/Edge/Firefox/Safari 等现代浏览器。');
      }
    </script>
    <script type="module" crossorigin src="/assets/index.bf8c73c6.js"></script>
    <link rel="stylesheet" href="/assets/index.48ca4a1c.css">
  </head>
  <body  data-head-attrs="">
    <div id="app"><!--[--><div class="m-4 max-w-screen-xl flex flex-wrap md:m-6 xl:mx-auto md:flex-nowrap"><div class="w-full flex-shrink-0 self-start md:sticky md:top-6 md:w-48"><div class="blog-base-area-box py-6 mb-4"><img class="block w-24 h-24 rounded-full mx-auto" src="https://avatars.githubusercontent.com/u/19222089?v=4"><div class="mt-5 px-3 text-center"><h1 class="text-c-title font-normal"><a href="" class="unset">daief的个人日志</a></h1><p class="mt-2 text-sm text-c-secondary break-words">遇见你，遇见幸运💫</p><div class="mt-3 text-xs flex justify-center"><a href="/" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-wenzhang" data-v-43154e2c></use></svg>(51) </a><span class="mx-1 text-c-secondary">|</span><a href="/tags" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg>(42) </a><span class="mx-1 text-c-secondary">|</span><a href="/categories" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-category" data-v-43154e2c></use></svg>(16) </a></div><div class="mt-6 flex justify-center"><a to="https://github.com/daief" replace="false" href="https://github.com/daief" target="_blank" class="unset cursor-pointer"><!--[--><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-github" data-v-43154e2c></use></svg><!--]--></a><span class="mx-2"></span><a to="mailto:defeng_mail@163.com" replace="false" href="mailto:defeng_mail@163.com" target="_blank" class="unset cursor-pointer"><!--[--><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-email" data-v-43154e2c></use></svg><!--]--></a></div></div><div class="mt-6"><div class="text-center" data-v-73630894><!--[--><a href="/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>首页</a><a href="/categories/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>分类</a><a href="/tags/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>标签</a><a href="/about/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>关于</a><!--]--></div></div></div><div class="hidden md:block mt-2"><div class="footer text-center text-sm" data-v-8b3f10e8><div data-v-8b3f10e8><div data-v-8b3f10e8>© 2017-2025</div></div><div class="flex items-center justify-center" data-v-8b3f10e8>By <a href="https://github.com/daief/blog/tree/master/packages/gugu" target="_blank" data-v-8b3f10e8>gugu</a>  &amp; daief - <span class="picker-wrap" data-v-7aa3923e data-v-8b3f10e8><span data-v-7aa3923e></span></span></div><!----><!----><div data-v-8b3f10e8><a href="/sitemap.xml" target="_blank" data-v-8b3f10e8>站点地图</a></div></div></div></div><div class="w-full md:w-0 md:flex-grow md:mx-5"><div><!--[--><div class="blog-base-area-box px-4 py-8 md:px-8"><div><h1 class="text-2xl font-normal break-words">初识 AST</h1><div class="my-4 text-xs text-c-secondary"><div class="flex items-center flex-wrap"><!----><!----><div class="whitespace-nowrap"><svg class="if-icon text-c-secondary mx-1 text-c-secondary mx-1" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-calendar" data-v-43154e2c></use></svg>2019-02-01</div><!--[--><span class="mx-1">|</span><div class="whitespace-nowrap"><svg class="if-icon text-c-secondary mx-1 text-c-secondary mx-1" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-folder" data-v-43154e2c></use></svg><!--[--><!--[--><a href="/categories/前端" class="unset">前端</a><span></span><!--]--><!--]--></div><!--]--><!----></div></div><!-- content --><div class="markdown-body text-sm text-gray-800 leading-loose"><blockquote>
<p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
</blockquote>
<p>Babel、UglifyJS2、ESLint、Webpack、TypeScript 等我们熟知的工具都包含 AST 的应用，实现了强大的功能。本文主要记录学习、应用 AST 的过程，主要内容：1. 解读 <a href="https://github.com/gaearon/react-hot-loader/blob/master/src/babel.dev.js">react-hot-loader dev 环境下的 Babel 插件</a>；2. 编写对应的 TypeScript transformer 尽可能实现相同的功能。</p>

<a id="more" class="h-0 mt-3 block"></a>


<p><a href="https://github.com/gaearon/react-hot-loader#getting-started">react-hot-loader/babel 是一个 Babel 插件</a>，用于帮助 RHL（reac-hot-loader）更好地工作。对于 TS 用户，官方的建议是使用 Babel 来进行 TS 的编译以发挥插件作用。但这可能会使 TS 用户感到困扰，因此尝试编写相应的 TS transformer 来实现相同的功能。</p>
<h2 id="AST">AST<a name="AST" class="headerlink" href="#AST"></a></h2><p>顾名思义，AST 是一棵树，由一个个节点（Node）组成，每个节点拥有 Type 标识以表示各自的类型。</p>
<p>Babel、TypeScript 的运行会经历以下流程（极简概括）：code ~&gt; AST ~&gt; code；同时他们开放了对应的 API 允许我们去操纵 AST，最终输出我们期望的结果。</p>
<p>因为 AST 的节点类型很多，想要全部记住是十分困难的，推荐使用 <a href="https://astexplorer.net/">AST explorer</a> 实时地查看，注意选择语言和相应的 parser。</p>
<p>简单来说，操作 AST 的过程就是遍历 AST，当发现符合条件的节点时进行编辑，最终返回一棵新的 AST。</p>
<h2 id="react-hot-loader/babel">react-hot-loader/babel<a name="react-hot-loader/babel" class="headerlink" href="#react-hot-loader/babel"></a></h2><h3 id="作用">作用<a name="作用" class="headerlink" href="#作用"></a></h3><p>让我们先简要了解该插件实际的表现：</p>
<ul>
<li>将默认导出声明 =&gt; 默认导出语句</li>
<li>在每个文件模块顶部、底部插入内容</li>
<li>在符合条件的类声明中插入名为 __reactstandin__regenerateByEval 的自定义方法</li>
</ul>
<p>具体例子，原代码内容：</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-keyword">import</span> P, { Q } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;left-pad&quot;</span>;
<span class="hljs-keyword">const</span> A = <span class="hljs-number">42</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">R</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> {}
  <span class="hljs-keyword">const</span> T = <span class="hljs-number">42</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-title function_">U</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">V</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">class</span> <span class="hljs-title class_">W</span> {}
    }
  }
}
<span class="hljs-keyword">const</span> D = <span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {};
<span class="hljs-keyword">let</span> E = D;
<span class="hljs-keyword">var</span> Y = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;left-pad&quot;</span>);
<span class="hljs-keyword">var</span> { Z } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;left-pad&quot;</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({});</code></pre><p>经过转换的代码，该结果还包含降级为 ES5 的内容，注意区分：</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-meta">&quot;use strict&quot;</span>;

<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, {
  <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>
});
<span class="hljs-built_in">exports</span>.<span class="hljs-property">C</span> = <span class="hljs-literal">undefined</span>;

<span class="hljs-keyword">var</span> _createClass = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-keyword">function</span> <span class="hljs-title function_">defineProperties</span>(<span class="hljs-params">target, props</span>) { <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; props.<span class="hljs-property">length</span>; i++) { <span class="hljs-keyword">var</span> descriptor = props[i]; descriptor.<span class="hljs-property">enumerable</span> = descriptor.<span class="hljs-property">enumerable</span> || <span class="hljs-literal">false</span>; descriptor.<span class="hljs-property">configurable</span> = <span class="hljs-literal">true</span>; <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-keyword">in</span> descriptor) descriptor.<span class="hljs-property">writable</span> = <span class="hljs-literal">true</span>; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, descriptor.<span class="hljs-property">key</span>, descriptor); } } <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">Constructor, protoProps, staticProps</span>) { <span class="hljs-keyword">if</span> (protoProps) <span class="hljs-title function_">defineProperties</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, protoProps); <span class="hljs-keyword">if</span> (staticProps) <span class="hljs-title function_">defineProperties</span>(<span class="hljs-title class_">Constructor</span>, staticProps); <span class="hljs-keyword">return</span> <span class="hljs-title class_">Constructor</span>; }; }();

<span class="hljs-keyword">var</span> _leftPad = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;left-pad&quot;</span>);

<span class="hljs-keyword">var</span> _leftPad2 = <span class="hljs-title function_">_interopRequireDefault</span>(_leftPad);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) { <span class="hljs-keyword">return</span> obj &amp;&amp; obj.<span class="hljs-property">__esModule</span> ? obj : { <span class="hljs-attr">default</span>: obj }; }

<span class="hljs-comment">/* ---------- 顶部内容 */</span>
(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> enterModule = (<span class="hljs-keyword">typeof</span> reactHotLoaderGlobal !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? reactHotLoaderGlobal : <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-hot-loader&#x27;</span>)).<span class="hljs-property">enterModule</span>;
  enterModule &amp;&amp; <span class="hljs-title function_">enterModule</span>(<span class="hljs-variable language_">module</span>);
})();
<span class="hljs-comment">/* ---------- 顶部内容 end */</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) { <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Constructor</span>)) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Cannot call a class as a function&quot;</span>); } }

<span class="hljs-keyword">var</span> A = <span class="hljs-number">42</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">R</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-keyword">var</span> S = <span class="hljs-keyword">function</span> <span class="hljs-title function_">S</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, S);
  };

  <span class="hljs-keyword">var</span> T = <span class="hljs-number">42</span>;
}

<span class="hljs-keyword">var</span> C = <span class="hljs-built_in">exports</span>.<span class="hljs-property">C</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, C);
  }

  <span class="hljs-title function_">_createClass</span>(C, [{
    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;U&quot;</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">U</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">V</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> W = <span class="hljs-keyword">function</span> <span class="hljs-title function_">W</span>(<span class="hljs-params"></span>) {
          <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, W);
        };
      }
    }
  }, {
    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;__reactstandin__regenerateByEval&quot;</span>,
    <span class="hljs-comment">// @ts-ignore</span>
    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">__reactstandin__regenerateByEval</span>(<span class="hljs-params">key, code</span>) {
      <span class="hljs-comment">// @ts-ignore</span>
      <span class="hljs-variable language_">this</span>[key] = <span class="hljs-built_in">eval</span>(code);
    }
  }]);

  <span class="hljs-keyword">return</span> C;
}();

<span class="hljs-keyword">var</span> D = <span class="hljs-keyword">function</span> <span class="hljs-title function_">X</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, X);
};
<span class="hljs-keyword">var</span> E = D;
<span class="hljs-keyword">var</span> Y = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;left-pad&quot;</span>);

<span class="hljs-keyword">var</span> _require = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;left-pad&quot;</span>),
    Z = _require.<span class="hljs-property">Z</span>;

<span class="hljs-keyword">var</span> _default = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({
  <span class="hljs-attr">displayName</span>: <span class="hljs-string">&quot;_default&quot;</span>
});

<span class="hljs-built_in">exports</span>.<span class="hljs-property">default</span> = _default;
;

<span class="hljs-comment">/* ---------- 底部内容 */</span>
(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> reactHotLoader = (<span class="hljs-keyword">typeof</span> reactHotLoaderGlobal !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? reactHotLoaderGlobal : <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-hot-loader&#x27;</span>)).<span class="hljs-property">default</span>;

  <span class="hljs-keyword">if</span> (!reactHotLoader) {
    <span class="hljs-keyword">return</span>;
  }

  reactHotLoader.<span class="hljs-title function_">register</span>(A, <span class="hljs-string">&quot;A&quot;</span>, __FILENAME__);
  reactHotLoader.<span class="hljs-title function_">register</span>(B, <span class="hljs-string">&quot;B&quot;</span>, __FILENAME__);
  reactHotLoader.<span class="hljs-title function_">register</span>(C, <span class="hljs-string">&quot;C&quot;</span>, __FILENAME__);
  reactHotLoader.<span class="hljs-title function_">register</span>(D, <span class="hljs-string">&quot;D&quot;</span>, __FILENAME__);
  reactHotLoader.<span class="hljs-title function_">register</span>(E, <span class="hljs-string">&quot;E&quot;</span>, __FILENAME__);
  reactHotLoader.<span class="hljs-title function_">register</span>(_default, <span class="hljs-string">&quot;default&quot;</span>, __FILENAME__);
})();

;

(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> leaveModule = (<span class="hljs-keyword">typeof</span> reactHotLoaderGlobal !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? reactHotLoaderGlobal : <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-hot-loader&#x27;</span>)).<span class="hljs-property">leaveModule</span>;
  leaveModule &amp;&amp; <span class="hljs-title function_">leaveModule</span>(<span class="hljs-variable language_">module</span>);
})();
<span class="hljs-comment">/* ---------- 底部内容 end */</span></code></pre><h3 id="实现">实现<a name="实现" class="headerlink" href="#实现"></a></h3><p>源码：<a href="https://github.com/gaearon/react-hot-loader/blob/master/src/babel.dev.js。">https://github.com/gaearon/react-hot-loader/blob/master/src/babel.dev.js。</a></p>
<p>可以看到插件实际上是一个方法，形如：</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">plugin</span>(<span class="hljs-params">args, options = {}</span>) {
  <span class="hljs-keyword">const</span> { types, template } = args;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">visitor</span>: {
      <span class="hljs-title class_">ExportDefaultDeclaration</span>(path, state) {
        <span class="hljs-comment">// ...</span>
      },
      <span class="hljs-title class_">Program</span>: {
        <span class="hljs-title function_">enter</span>(<span class="hljs-params">{ scope }, state</span>) {
          <span class="hljs-comment">// ...</span>
        },
        <span class="hljs-title function_">exit</span>(<span class="hljs-params">{ node }, state</span>) {
          <span class="hljs-comment">// ...</span>
        },
      },
      <span class="hljs-title class_">Class</span>(path) {
        <span class="hljs-comment">// ...</span>
      },
    },
  }
}</code></pre><p>插件方法返回了一个对象，包含一个 visitor 对象，而 visitor 对象中又定义了 ExportDefaultDeclaration、Program 和 Class 的内容。这是一个用于遍历 AST 的访问者模式，当这样定义后，每当遍历到 ExportDefaultDeclaration 节点，就会调用相应的 ExportDefaultDeclaration 方法；而对于树节点的访问，会在进入、离开共发生两次，默认在进入节点时调用，也可以通过 enter、exit 进行指定调用时机，其他定义的节点同理。</p>
<p>插件的第一个参数中可以拿到 <code>types</code>、<code>template</code> 两个对象，分别对应 <a href="https://babeljs.io/docs/en/babel-types">@babel/types</a>、<a href="https://babeljs.io/docs/en/babel-template">@babel/template</a>。这是两个十分有用的对象，详情可参照链接及插件源码，以下作简单说明：</p>
<blockquote>
<p>@babel/types
是一个用于 AST 节点的工具库，包含了构造、验证以及变换 AST 节点的方法。该工具库包含考虑周到的工具方法，对编写处理AST逻辑非常有用。</p>
</blockquote>
<blockquote>
<p>@babel/template
让编写字符串形式且带有占位符的代码来代替手动编码，尤其是生成的大规模 AST 的时候。在计算机科学中，这种能力被称为准引用（quasiquotes）。</p>
</blockquote>
<p>visitor 中的每个函数接收 <code>path</code> 和 <code>state</code> 两个参数。</p>
<blockquote>
<p>path
表示两个节点之间的连接，通过这个对象我们可以访问到节点、父节点以及进行一系列跟节点操作相关的方法（类似 DOM 的操作）。</p>
</blockquote>
<p>关于 state，没能找到比较好的概念说明，目前为止只了解到一些相关的作用：1. 在 state 中可以拿到插件接收的 options；2. 可以通过 state 对象在不同 visitor 函数中进行数据传递。</p>
<p>最后来看看 Class 节点遍历中做了什么：</p>
<blockquote>
<p>Class 类型是别名，包括 classDeclaration、classExpression。</p>
</blockquote>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// 以下的 t 即上文提及的 @babel/types</span>
{
  <span class="hljs-title class_">Class</span>(classPath) {
    <span class="hljs-comment">// 拿到 class 声明的 body</span>
    <span class="hljs-keyword">const</span> classBody = classPath.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;body&#x27;</span>)

    <span class="hljs-comment">// 以下两个变量用于后面判断该 class 节点是否需要注入方法</span>
    <span class="hljs-keyword">let</span> hasRegenerateMethod = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> hasMethods = <span class="hljs-literal">false</span>

    <span class="hljs-comment">// 遍历 classBody 判断注入的必要性</span>
    classBody.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> { node } = path

      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">static</span>) {
        <span class="hljs-keyword">return</span>
      }

      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">key</span>.<span class="hljs-property">name</span> !== <span class="hljs-variable constant_">REGENERATE_METHOD</span>) {
        hasMethods = <span class="hljs-literal">true</span>
      } <span class="hljs-keyword">else</span> {
        hasRegenerateMethod = <span class="hljs-literal">true</span>
      }
    })

    <span class="hljs-comment">// 符合条件时，注入方法</span>
    <span class="hljs-keyword">if</span> (hasMethods &amp;&amp; !hasRegenerateMethod) {
      <span class="hljs-comment">// 创建一个类方法</span>
      <span class="hljs-keyword">const</span> regenerateMethod = t.<span class="hljs-title function_">classMethod</span>(
        <span class="hljs-string">&#x27;method&#x27;</span>,
        t.<span class="hljs-title function_">identifier</span>(<span class="hljs-variable constant_">REGENERATE_METHOD</span>),
        [t.<span class="hljs-title function_">identifier</span>(<span class="hljs-string">&#x27;key&#x27;</span>), t.<span class="hljs-title function_">identifier</span>(<span class="hljs-string">&#x27;code&#x27;</span>)],
        t.<span class="hljs-title function_">blockStatement</span>([
          <span class="hljs-comment">// 将字符串代码转换为 AST</span>
          <span class="hljs-title function_">template</span>(<span class="hljs-string">&#x27;this[key]=eval(code);&#x27;</span>, templateOptions)()
        ]),
      )

      <span class="hljs-comment">// 将新建的类方法插入 classBody</span>
      classBody.<span class="hljs-title function_">pushContainer</span>(<span class="hljs-string">&#x27;body&#x27;</span>, regenerateMethod)

      <span class="hljs-comment">// 最后在插入的方法内外添加两条注释</span>
      classBody.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> { node } = path

        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">key</span>.<span class="hljs-property">name</span> === <span class="hljs-variable constant_">REGENERATE_METHOD</span>) {
          path.<span class="hljs-title function_">addComment</span>(<span class="hljs-string">&#x27;leading&#x27;</span>, <span class="hljs-string">&#x27; @ts-ignore&#x27;</span>, <span class="hljs-literal">true</span>)
          path
            .<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;body&#x27;</span>)
            .<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;body&#x27;</span>)[<span class="hljs-number">0</span>]
            .<span class="hljs-title function_">addComment</span>(<span class="hljs-string">&#x27;leading&#x27;</span>, <span class="hljs-string">&#x27; @ts-ignore&#x27;</span>, <span class="hljs-literal">true</span>)
        }
      })
    }
  },
}</code></pre><h2 id="ts-rhl-transformer">ts-rhl-transformer<a name="ts-rhl-transformer" class="headerlink" href="#ts-rhl-transformer"></a></h2><p>TypeScript 在编译时也会产生一棵 AST，我们同样可以借助相应的 API 去操作这棵树，以实现期望的效果。编写 TS 的 transformer 与 Babel 插件有不少相同的地方，同样通过 visitor 对象去遍历节点。需要注意的是，两者在书写方式和节点类型上有许多不同。这里介绍的 TS transformer 是基于 Webpack 环境下运行的，使用方法可参照 <a href="https://github.com/Igorbek/typescript-plugin-styled-components#integration-with-webpack">typescript-plugin-styled-components</a>。</p>
<p>首先来看 transformer 的整体情况：</p>
<pre class="hljs language-ts" hljs-language="ts"><code style="display:block;"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ts <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typescript&#x27;</span>;

<span class="hljs-comment">// 插件也是一个方法，该方法返回一个 transformer 对象</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createTransformer</span>(<span class="hljs-params"></span>) {

  <span class="hljs-comment">// transformer 对象</span>
  <span class="hljs-keyword">const</span> <span class="hljs-attr">transformer</span>: ts.<span class="hljs-property">TransformerFactory</span>&lt;ts.<span class="hljs-property">SourceFile</span>&gt; = <span class="hljs-function">(<span class="hljs-params">context</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">transformerNode</span> =&gt;</span> {

      <span class="hljs-comment">// 自定义 visitor</span>
      <span class="hljs-keyword">const</span> <span class="hljs-attr">visitorClassLike</span>: ts.<span class="hljs-property">Visitor</span> = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (ts.<span class="hljs-title function_">isClassLike</span>(node)) {
          <span class="hljs-comment">// 当节点类型符合条件时执行逻辑</span>

          <span class="hljs-comment">// ...</span>

          <span class="hljs-comment">// 如果需要递归遍历，一定要返回 ts.visitEachChild</span>
          <span class="hljs-keyword">return</span> ts.<span class="hljs-title function_">visitEachChild</span>(node, visitorClassLike, context);
        }
        <span class="hljs-keyword">return</span> ts.<span class="hljs-title function_">visitEachChild</span>(node, visitorClassLike, context);
      }; <span class="hljs-comment">// ------- 自定义 visitor end</span>

      <span class="hljs-comment">// 这里的 transformerNode 又称之为 SourceFile，是根节点</span>
      <span class="hljs-keyword">return</span> ts.<span class="hljs-title function_">visitNode</span>(transformerNode, visitorClassLike);
    }
  };

  <span class="hljs-keyword">return</span> transformer;
}</code></pre><p>在 TS transformer 的编写中，我们能用的 API 基本都在 ts 对象中。下面，来看看如何在此同样实现在类声明中插入自定义方法。</p>
<pre class="hljs language-ts" hljs-language="ts"><code style="display:block;"><span class="hljs-comment">/**
 * 自定义 class visitor，用于访问 class 并注入自定义方法
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">visitorClassLike</span>: ts.<span class="hljs-property">Visitor</span> = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
  <span class="hljs-comment">// isClassLike 类似于 babel 中的 class 别名，包括 ClassDeclaration、ClassExpression 两者情况</span>
  <span class="hljs-comment">// 此判断确保只对该类型节点进行操作</span>
  <span class="hljs-keyword">if</span> (ts.<span class="hljs-title function_">isClassLike</span>(node)) {
    <span class="hljs-comment">// 同样的两个用于判断的变量</span>
    <span class="hljs-keyword">let</span> hasRegenerateMethod = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> hasMethods = <span class="hljs-literal">false</span>;

    <span class="hljs-comment">/**
     * 遍历类成员进行判断
     */</span>
    node.<span class="hljs-property">members</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">classEle</span> =&gt;</span> {
      <span class="hljs-keyword">let</span> hasStatic = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> ele <span class="hljs-keyword">of</span> classEle.<span class="hljs-property">modifiers</span> || []) {
        <span class="hljs-keyword">if</span> (ele.<span class="hljs-property">kind</span> === ts.<span class="hljs-property">SyntaxKind</span>.<span class="hljs-property">StaticKeyword</span>) {
          hasStatic = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">break</span>;
        }
      }

      <span class="hljs-keyword">if</span> (hasStatic) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-comment">// notice node type check</span>
      <span class="hljs-keyword">if</span> (
        ts.<span class="hljs-title function_">isMethodDeclaration</span>(classEle) ||
        ts.<span class="hljs-title function_">isPropertyDeclaration</span>(classEle) ||
        ts.<span class="hljs-title function_">isConstructorDeclaration</span>(classEle)
      ) {
        <span class="hljs-keyword">const</span> propName = classEle.<span class="hljs-property">name</span> ? classEle.<span class="hljs-property">name</span>.<span class="hljs-title function_">getText</span>() : <span class="hljs-string">&#x27;constructor&#x27;</span>;
        hasMethods = propName !== <span class="hljs-variable constant_">REGENERATE_METHOD</span>;
        hasRegenerateMethod = propName === <span class="hljs-variable constant_">REGENERATE_METHOD</span>;
      }
    });

    <span class="hljs-keyword">if</span> (hasMethods &amp;&amp; !hasRegenerateMethod) {
      <span class="hljs-comment">/**
       * 符合条件，新建类方法
       */</span>
      <span class="hljs-keyword">const</span> method = ts.<span class="hljs-title function_">createMethod</span>(
        <span class="hljs-literal">undefined</span>,
        <span class="hljs-literal">undefined</span>,
        <span class="hljs-literal">undefined</span>,
        <span class="hljs-comment">// method name</span>
        <span class="hljs-variable constant_">REGENERATE_METHOD</span>,
        <span class="hljs-literal">undefined</span>,
        <span class="hljs-literal">undefined</span>,
        <span class="hljs-comment">// parameters -- 方法参数</span>
        [
          ts.<span class="hljs-title function_">createParameter</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;key&#x27;</span>),
          ts.<span class="hljs-title function_">createParameter</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;code&#x27;</span>),
        ],
        <span class="hljs-literal">undefined</span>,
        <span class="hljs-comment">// method body -- 方法体内容</span>
        ts.<span class="hljs-title function_">createBlock</span>([
          ts.<span class="hljs-title function_">createExpressionStatement</span>(ts.<span class="hljs-title function_">createIdentifier</span>(<span class="hljs-string">&#x27;this[key] = eval(code)&#x27;</span>)),
        ])
      );

      <span class="hljs-comment">// 通过 update 为前缀的方法更新节点，将当前 node 进行更新</span>
      <span class="hljs-comment">// 并进行递归访问</span>
      <span class="hljs-comment">// 因为实际上有两种类声明方式，这里做了下区分</span>
      <span class="hljs-keyword">return</span> ts.<span class="hljs-title function_">visitEachChild</span>(
        ts.<span class="hljs-title function_">isClassDeclaration</span>(node)
          ? ts.<span class="hljs-title function_">updateClassDeclaration</span>(
              node,
              node.<span class="hljs-property">decorators</span>,
              node.<span class="hljs-property">modifiers</span>,
              node.<span class="hljs-property">name</span>,
              node.<span class="hljs-property">typeParameters</span>,
              node.<span class="hljs-property">heritageClauses</span>,
              node.<span class="hljs-property">members</span>.<span class="hljs-title function_">concat</span>([method])
            )
          : ts.<span class="hljs-title function_">updateClassExpression</span>(
              node,
              node.<span class="hljs-property">modifiers</span>,
              node.<span class="hljs-property">name</span>,
              node.<span class="hljs-property">typeParameters</span>,
              node.<span class="hljs-property">heritageClauses</span>,
              node.<span class="hljs-property">members</span>.<span class="hljs-title function_">concat</span>([method])
            ),
        visitorClassLike,
        context
      );
    }
  }

  <span class="hljs-keyword">return</span> ts.<span class="hljs-title function_">visitEachChild</span>(node, visitorClassLike, context);
};</code></pre><p><code>ts.createIdentifier</code> 可实现与 @babel/template 相似的功能，只是没那么强大，缺少占位符替换等功能。</p>
<p><a href="https://github.com/daief/jugg/blob/master/packages/jugg-plugin-react/src/ts-rhl-transformer/ts-rhl-transformer.dev.ts">完整源码查看这里</a>。编写过程中参照了不少大佬 <a href="https://github.com/Jetsly">@Jetsly</a> 的实现，获得了不小的帮助，感谢大佬（<a href="https://github.com/Jetsly/ts-react-hot-transformer">大佬的仓库</a>）。</p>
<p>本节最后来看看该插件实现的效果，前后代码转换对比（本过程不涉及 ES 降级）：</p>
<pre class="hljs language-ts" hljs-language="ts"><code style="display:block;"><span class="hljs-comment">/* --------------- 原始代码 --------------- */</span>
<span class="hljs-keyword">import</span> P, { Q } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;left-pad&quot;</span>;
<span class="hljs-keyword">const</span> A = <span class="hljs-number">42</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">R</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> {}
  <span class="hljs-keyword">const</span> T = <span class="hljs-number">42</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-title function_">U</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">V</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">class</span> <span class="hljs-title class_">W</span> {}
    }
  }
}
<span class="hljs-keyword">const</span> D = <span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {};
<span class="hljs-keyword">let</span> E = D;
<span class="hljs-keyword">var</span> Y = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;left-pad&quot;</span>);
<span class="hljs-keyword">var</span> { Z } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;left-pad&quot;</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({});


<span class="hljs-comment">/* --------------- 转换结果 --------------- */</span>
(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> enterModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-hot-loader&#x27;</span>).<span class="hljs-property">enterModule</span>;
  enterModule &amp;&amp; <span class="hljs-title function_">enterModule</span>(<span class="hljs-variable language_">module</span>);
}())
;


;
<span class="hljs-keyword">import</span> P, { Q } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;left-p&quot;</span>;
<span class="hljs-keyword">const</span> A = <span class="hljs-number">42</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">R</span>(<span class="hljs-params"></span>) { }
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> {
    }
    <span class="hljs-keyword">const</span> T = <span class="hljs-number">42</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-title function_">U</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">V</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">class</span> <span class="hljs-title class_">W</span> {
            }
        }
    }
    <span class="hljs-title function_">__reactstandin__regenerateByEval</span>(<span class="hljs-params">key, code</span>) { <span class="hljs-variable language_">this</span>[key] = <span class="hljs-built_in">eval</span>(code); }
}
<span class="hljs-keyword">const</span> D = <span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {
};
<span class="hljs-keyword">let</span> E = D;
<span class="hljs-keyword">var</span> Y = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;left-pad&quot;</span>);
<span class="hljs-keyword">var</span> { Z } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;left-pad&quot;</span>);
<span class="hljs-keyword">const</span> _default_1 = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> _default_1;


;
(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
<span class="hljs-keyword">var</span> reactHotLoader = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-hot-loader&#x27;</span>).<span class="hljs-property">default</span>;
<span class="hljs-keyword">var</span> leaveModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-hot-loader&#x27;</span>).<span class="hljs-property">leaveModule</span>;
<span class="hljs-keyword">if</span> (!reactHotLoader) {
  <span class="hljs-keyword">return</span>;
}
; reactHotLoader.<span class="hljs-title function_">register</span>(A, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;bindings.js&quot;</span>);
; reactHotLoader.<span class="hljs-title function_">register</span>(B, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;bindings.js&quot;</span>);
; reactHotLoader.<span class="hljs-title function_">register</span>(C, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;bindings.js&quot;</span>);
; reactHotLoader.<span class="hljs-title function_">register</span>(D, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;bindings.js&quot;</span>);
; reactHotLoader.<span class="hljs-title function_">register</span>(E, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;bindings.js&quot;</span>);
; reactHotLoader.<span class="hljs-title function_">register</span>(_default_1, <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;bindings.js&quot;</span>);
; <span class="hljs-title function_">leaveModule</span>(<span class="hljs-variable language_">module</span>); }());</code></pre><h2 id="结语">结语<a name="结语" class="headerlink" href="#结语"></a></h2><p>修改 AST 的时候一定要十分小心，注意涉及范围的节点类型、作用域等内容，不要影响了无辜的代码。树的节点类型很多，极其建议在编写时结合 AST explorer 等可视化工具进行查看。</p>
<p>通过 AST 可以实现各种各样强大、有趣的功能，用来解决、优化日常的编程。</p>
<p>只要有想法，就能玩出花。</p>
<p>完。</p>
<hr>
<p>参考链接 &amp; 推荐阅读：</p>
<ul>
<li><a href="https://dev.doctorevidence.com/how-to-write-a-typescript-transform-plugin-fc5308fdd943">How to Write a TypeScript Transform (Plugin)</a></li>
<li><a href="https://astexplorer.net/">AST explorer</a></li>
<li><a href="https://juejin.im/post/5a0a54425188253edc7f6e79">手把手教写 TypeScript Transformer Plugin</a></li>
<li><a href="https://blog.kevinyang.net/2018/08/17/typescript-compiler/">[TypeScript] Compiler API 第一次接觸</a></li>
<li><a href="https://juejin.im/post/5ab9f2f3f265da239b4174f0">babel插件入门-AST（抽象语法树）</a></li>
<li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md">Babel 插件手册</a></li>
<li><a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md">TypeScript Language Specification</a></li>
<li><a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md">babel-parser ast spec</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32189701">AST in Modern JavaScript</a></li>
<li><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a></li>
<li><a href="https://babeljs.io/docs/en/">Babel Doc</a></li>
<li><a href="http://taobaofed.org/blog/2016/09/30/babel-plugins/">理解 Babel 插件</a></li>
<li><a href="https://github.com/Igorbek/typescript-plugin-styled-components">typescript-plugin-styled-components</a></li>
<li><a href="https://github.com/gaearon/react-hot-loader/blob/master/src/babel.dev.js">react-hot-loader@4.x/babel</a></li>
<li><a href="https://github.com/Jetsly/ts-react-hot-transformer">ts-react-hot-transformer</a></li>
<li><a href="https://github.com/daief/jugg/tree/master/packages/jugg-plugin-react/src/ts-rhl-transformer">@axew/jugg-plugin-react/lib/ts-rhl-transformer</a></li>
</ul>
</div><div class="mt-6 has-child mt-6 mt-6" data-v-3adb2250><!--[-->☘️<!--]--></div><div class="flex flex-wrap justify-center text-c-secondary text-sm mt-6"><!--[--><a href="/tags/JavaScript" class="unset block my-1 mx-2"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg> JavaScript</a><a href="/tags/TypeScript" class="unset block my-1 mx-2"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg> TypeScript</a><a href="/tags/AST" class="unset block my-1 mx-2"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg> AST</a><!--]--></div></div></div><!-- 上下篇 --><div class="blog-base-area-box px-4 py-4 my-8 flex justify-between md:px-8"><!--[--><div class="pr-3 w-0 flex-grow break-words"><!--[--><div class="text-c-secondary text-xs mb-1">上一篇 </div><div class="text-sm"><a href="/post/try-to-improve-spa-load-performance" class="unset">记一次单页应用的加载优化</a></div><!--]--></div><div class="text-right pl-3 w-0 flex-grow break-words"><!--[--><div class="text-c-secondary text-xs mb-1">下一篇 </div><div class="text-sm"><a href="/post/happy-vue-with-typescript" class="unset">用 TypeScript 来写 Vue！</a></div><!--]--></div><!--]--></div><!-- 评论 --><div id="comment" class="blog-base-area-box p-4 my-8 md:px-8"><h1 class="text-c-title text-xl block font-normal mb-5"><a href="#comment" class="unset text-c-title hover:text-c-title hover:underline"> 留言板 </a></h1><div class="utterances"></div></div><!--]--></div></div><div class="blog-base-area-box hidden md:block w-48 sticky top-6"><div style="display:none;" class="site-toc-wrap leading-6 break-all text-sm p-3"></div></div></div><div class="block mb-4 md:hidden"><div class="footer text-center text-sm" data-v-8b3f10e8><div data-v-8b3f10e8><div data-v-8b3f10e8>© 2017-2025</div></div><div class="flex items-center justify-center" data-v-8b3f10e8>By <a href="https://github.com/daief/blog/tree/master/packages/gugu" target="_blank" data-v-8b3f10e8>gugu</a>  &amp; daief - <span class="picker-wrap" data-v-7aa3923e data-v-8b3f10e8><span data-v-7aa3923e></span></span></div><!----><!----><div data-v-8b3f10e8><a href="/sitemap.xml" target="_blank" data-v-8b3f10e8>站点地图</a></div></div></div><div class="fixed z-100 right-8 bottom-14" data-v-49aec8bc><div class="blog-base-area-box action-btn opacity-0 pointer-events-none" data-v-49aec8bc><svg class="if-icon" aria-hidden="true" data-v-43154e2c data-v-49aec8bc><use xlink:href="#if-top" data-v-43154e2c></use></svg></div></div><!--]--></div>
    
  </body>
</html>
