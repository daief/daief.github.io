<!DOCTYPE html>
<html  data-head-attrs="">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Inno Setup | daief的个人日志</title><meta property="og:title" content="Inno Setup | daief的个人日志"><meta property="author" content="daief"><meta name="head:count" content="2">
<script>window.__INITIAL_STATE__={"global":{"site":{"postCount":51,"tagCount":42,"categoryCount":16,"site_pv":0,"page_pv":0,"site_uv":0},"indexPostPagination":{"current":1,"pageSize":10,"totalPages":0,"result":[]},"postDetail":{"post":{"id":"inno-setup","slug":"post/inno-setup","path":"/post/inno-setup","title":"Inno Setup","comments":true,"published":true,"date":"2023-04-07T11:28:06.000Z","updated":"","tags":[],"categories":[{"id":"ad7123e6c402c7d6c71d0a1032463ea3","name":"桌面开发","slug":"categories/桌面开发","path":"/categories/桌面开发","parentId":"","postCount":1,"postIds":[]}],"excerpt":"<p>最近工作上遇到了 Inno Setup，这对于我来说是个新东西，看不懂，那么就学一下吧。</p>\n","more":"\n\n<h1 id=\"安装 &amp; 起步\">安装 &amp; 起步<a name=\"安装 &amp; 起步\" class=\"headerlink\" href=\"#安装 &amp; 起步\"></a></h1><blockquote>\n<p>当前所使用的 Inno Setup 版本是 6.2.2</p>\n</blockquote>\n<p>Inno Setup（后文将简称为 Inno） 是一个开源的安装包制作工具，小巧但强大，官网下载地址：<a href=\"https://jrsoftware.org/isinfo.php\">https://jrsoftware.org/isinfo.php</a>。</p>\n<p>官方文档：<a href=\"https://jrsoftware.org/ishelp/\">https://jrsoftware.org/ishelp/</a></p>\n<p>下载安装之后打开 Inno，实际上是一个编辑器，可以直接编辑脚本，可以编译、运行脚本，生成安装程序。</p>\n<p>选择新建脚本，写入以下内容：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n<span class=\"hljs-attr\">AppVersion</span>=<span class=\"hljs-number\">1.0</span>.<span class=\"hljs-number\">0</span>\n<span class=\"hljs-attr\">DefaultDirName</span>=<span class=\"hljs-string\">&quot;{userdesktop}\\hello&quot;</span></code></pre><p>点击编译（Compile），在对话框中选择保存脚本（比如 hello.iss），之后在脚本的同级会生成一个 <code>Output</code>，里面有一个 <code>mysetup.exe</code>。</p>\n<p>双击 <code>mysetup.exe</code> 就开始安装引导了：</p>\n<p><img alt=\"01-hello-installer.png\" loading=\"lazy\" title=\"01-hello-installer.png\" class=\"post-image \" src=\"/images/d63e5c4d496d5cbc50b06f875ba776b7.01-hello-installer.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n<p>回顾上述脚本：</p>\n<ul>\n<li><code>[Setup]</code>：此部分包含安装程序和卸载程序使用的全局设置，该 <code>Section</code> 是必须的</li>\n<li><code>AppName</code> 和 <code>AppVersion</code> 分别定义应用程序的名称和版本</li>\n<li><code>DefaultDirName</code> 是默认的安装目录，这里使用了一个<strong>常量</strong> <code>userdesktop</code>，表示用户桌面的路径</li>\n</ul>\n<p>根据安装引导的提示完成安装，最终会在指定路径创建一个文件夹，包含如下卸载程序：</p>\n<ul>\n<li>unins000.dat</li>\n<li>unins000.exe</li>\n</ul>\n<p>除了手写脚本，Inno 本身自带可视化的界面去制作安装程序，在可视化界面中一步步进行下去，最后可以将一系列操作保存为一份脚本。可视化的操作很方便易学，不过这里不对可视化操作进行过多介绍了，主要还是学习一下脚本的编写。</p>\n<h1 id=\"脚本学习\">脚本学习<a name=\"脚本学习\" class=\"headerlink\" href=\"#脚本学习\"></a></h1><h2 id=\"iss 脚本概览\">iss 脚本概览<a name=\"iss 脚本概览\" class=\"headerlink\" href=\"#iss 脚本概览\"></a></h2><p>每一个 iss 脚本由若干个 <code>Section</code> 组成，每个 <code>Section</code> 有各自的职责。一个 <code>Section</code> 由方括号 <code>[]</code> 包裹，其中包含 <code>Section</code> 的名称。在每个 <code>Section</code> 内可以包含任意数量的条目。</p>\n<p><code>Section</code> 可以分为两类：</p>\n<ul>\n<li>像 <code>[Setup]</code> 这样，它的条目由指令名称和值（形式为 Directive=Value）构成</li>\n<li>以及像 <code>[Files]</code> 这样，它的条目是由多个键值对通过分号连接而成，这种形式下的键值对又称为参数（Parameter）</li>\n</ul>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n\n<span class=\"hljs-section\">[Files]</span>\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;</span></code></pre><blockquote>\n<p>注意：</p>\n<ul>\n<li>每个 <code>Section</code> 内部的条目可以使用相同的名称</li>\n<li>可以存在多个同名 <code>Section</code></li>\n<li>默认情况下，指令值中的任何前导或尾随空格都将被删除。可以通过在指令值周围加上双引号 <code>&quot;</code> 来避免</li>\n<li>iss 本身大小写不敏感，但是需要注意有些“值”的书写方式，比如应用名称会在某些地方直接展示给用户，故不可随意书写</li>\n</ul>\n</blockquote>\n<p>iss 的注释由 <code>;</code> 开头，<code>[Code]</code> 部分的注释另有两种方式：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-comment\">; AppName 指定应用程序的名称，这是一条注释</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n\n<span class=\"hljs-section\">[Code]</span>\n// 单行注释\n(* 多行注释 *)</code></pre><p>支持类似 C 语言的 <code>#include</code> 指令，它可以将另一个文件中的内容插入到脚本中指令所在的位置。</p>\n<pre class=\"hljs language-c\" hljs-language=\"c\"><code style=\"display:block;\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;filename.txt&quot;</span></span></code></pre><p>如果文件名不是绝对路径，编译器将在 iss 文件所在目录中查找。文件名可以以 <code>compiler:</code> 为前缀，在这种情况下，它会在编译器目录中查找该文件。</p>\n<blockquote>\n<p><code>compiler:</code> 为前缀时，查找编译器目录，指的就是 Inno Setup 的安装目录。</p>\n</blockquote>\n<p>支持 <code>#preproc</code> 指令，该指令指定是否使用内置预处理器（仅支持上述 #include 指令）或使用 Inno 预处理器 (ISPP)，后者支持更多的指令。</p>\n<pre class=\"hljs language-text\" hljs-language=\"text\"><code style=\"display:block;\">#preproc builtin\n#preproc ispp</code></pre><p>默认情况下，iss 脚本使用 ISPP（如果可用），而 .isl 文件使用内置（built-in）预处理器。</p>\n<h2 id=\"多语言\">多语言<a name=\"多语言\" class=\"headerlink\" href=\"#多语言\"></a></h2><p>Inno 官方自带一部分多语言，可以在 Inno 安装目录下的 <code>Languages</code> 文件夹中找到。</p>\n<p>对于官方未支持的多语言（比如中文），可以在 <a href=\"https://jrsoftware.org/files/istrans/\">https://jrsoftware.org/files/istrans/</a> 下载，下载之后保存到 Inno 的 <code>Languages</code> 文件夹中，命名为 <code>ChineseSimplified.isl</code>。</p>\n<blockquote>\n<p>注意：文件格式不能是 UTF-8，需要是 UTF-8 with BOM 或者是 GBK 编码（可能还有其他可行的编码，但没尝试过），否则会出现中文乱码。</p>\n</blockquote>\n<p>针对最开始的脚本，添加中文支持，重新编译并运行：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n<span class=\"hljs-attr\">AppVersion</span>=<span class=\"hljs-number\">1.0</span>.<span class=\"hljs-number\">0</span>\n<span class=\"hljs-attr\">DefaultDirName</span>=<span class=\"hljs-string\">&quot;{userdesktop}\\hello&quot;</span>\n<span class=\"hljs-attr\">WizardStyle</span>=modern\n\n<span class=\"hljs-comment\">; 新增 Languages Section，指定为中文</span>\n<span class=\"hljs-section\">[Languages]</span>\nName: chinesesimp<span class=\"hljs-comment\">; MessagesFile: &quot;compiler:Languages\\ChineseSimplified.isl&quot;</span></code></pre><p><img alt=\"02-hello-installer-chinese.png\" loading=\"lazy\" title=\"02-hello-installer-chinese.png\" class=\"post-image \" src=\"/images/85d0dbbe3d52136ba35b6988deddf206.02-hello-installer-chinese.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n<h2 id=\"常量（Constants）\">常量（Constants）<a name=\"常量（Constants）\" class=\"headerlink\" href=\"#常量（Constants）\"></a></h2><p>前文 <code>DefaultDirName=&quot;{userdesktop}\\hello&quot;</code>、<code>Source: &quot;MYPROG.EXE&quot;; DestDir: &quot;{app}&quot;</code> 中的 <code>userdesktop</code> 和 <code>app</code> 都是常量，安装和卸载的过程中，常量会被替换为用户选择的值或系统配置中的值。</p>\n<p>比如，<code>{app}</code> 常量会被替换为应用程序的安装目录，<code>{userdesktop}</code> 常量会被替换为用户桌面的路径。</p>\n<p>完整的常量列表可以参考官方文档的常量章节。</p>\n<h2 id=\"公共参数（Common Parameters）\">公共参数（Common Parameters）<a name=\"公共参数（Common Parameters）\" class=\"headerlink\" href=\"#公共参数（Common Parameters）\"></a></h2><p>公共参数是指能在所有 <code>Section</code> 中都能被使用的参数，共有三条：</p>\n<ul>\n<li><code>Languages</code></li>\n<li><code>MinVersion</code></li>\n<li><code>OnlyBelowVersion</code></li>\n</ul>\n<blockquote>\n<p>TODO 待完善</p>\n</blockquote>\n<h2 id=\"Components 和 Tasks 参数\">Components 和 Tasks 参数<a name=\"Components 和 Tasks 参数\" class=\"headerlink\" href=\"#Components 和 Tasks 参数\"></a></h2><p>除了 <code>[Types]</code>、<code>[Components]</code> 和 <code>[Tasks]</code>，其他 <code>Section</code> 都支持 <code>Components</code> 和 <code>Tasks</code> 两个可选参数。</p>\n<h3 id=\"Components 参数\">Components 参数<a name=\"Components 参数\" class=\"headerlink\" href=\"#Components 参数\"></a></h3><p>一个由空格分隔的组件名称列表，告诉安装程序该条目属于哪些组件。如果最终用户从此列表中选择了一个组件，则会处理该条目（例如：安装文件）。</p>\n<p>没有 <code>Components</code> 参数的条目始终会被处理，除非有其他参数（比如后文的 Check）指示不应该这样做。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Files]</span>\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Components: main</span>\nSource: &quot;MYPROG.CHM&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Components: help</span>\nSource: &quot;README.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;</span></code></pre><h3 id=\"Tasks 参数\">Tasks 参数<a name=\"Tasks 参数\" class=\"headerlink\" href=\"#Tasks 参数\"></a></h3><p>一个以空格分隔的任务名称列表，告诉安装程序该条目属于哪个任务。如果最终用户从此列表中选择了一个任务，则会处理该条目（例如：安装文件）。</p>\n<p>没有 <code>Tasks</code> 参数的条目始终会被处理，除非其他参数说明不应该这样做。</p>\n<blockquote>\n<p>请注意，在“选择开始菜单文件夹”向导页面上的“不创建开始菜单文件夹”复选框不影响具有 Tasks 参数的 <code>[Icons]</code> 条目，因为它们有自己的复选框。</p>\n</blockquote>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Icons]</span>\nName: &quot;{group}\\My Program&quot;<span class=\"hljs-comment\">; Filename: &quot;{app}\\MyProg.exe&quot;; Components: main; Tasks: startmenu</span>\nName: &quot;{group}\\My Program Help&quot;<span class=\"hljs-comment\">; Filename: &quot;{app}\\MyProg.chm&quot;; Components: help; Tasks: startmenu</span>\nName: &quot;{commondesktop}\\My Program&quot;<span class=\"hljs-comment\">; Filename: &quot;{app}\\MyProg.exe&quot;; Components: main; Tasks: desktopicon</span></code></pre><p>除了空格分隔的列表，还可以将布尔表达式用作组件和任务参数。支持的运算符包括 <code>not</code>、<code>and</code> 和 <code>or</code>。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Components]</span>\nName: a<span class=\"hljs-comment\">; Description: a</span>\nName: b<span class=\"hljs-comment\">; Description: b</span>\n\n<span class=\"hljs-section\">[Tasks]</span>\nName: p<span class=\"hljs-comment\">; Description: a or b; Components: a or b</span>\nName: q<span class=\"hljs-comment\">; Description: a and b; Components: a and b</span>\nName: r<span class=\"hljs-comment\">; Description: not a or b; Components: not a or b</span>\nName: s<span class=\"hljs-comment\">; Description: not (a or b); Components: not (a or b)</span>\nName: t<span class=\"hljs-comment\">; Description: a or b - old style; Components: a b</span></code></pre><h3 id=\"尝试\">尝试<a name=\"尝试\" class=\"headerlink\" href=\"#尝试\"></a></h3><p>上面都是摘自官方的解释，但到底是什么表现呢？</p>\n<p>在脚本中新增 <code>Components</code> 和 <code>Tasks</code> 的相关内容，重新编译并运行：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Setup]</span>\n<span class=\"hljs-attr\">AppName</span>=My Program\n<span class=\"hljs-attr\">AppVersion</span>=<span class=\"hljs-number\">1.0</span>.<span class=\"hljs-number\">0</span>\n<span class=\"hljs-attr\">DefaultDirName</span>=<span class=\"hljs-string\">&quot;{userdesktop}\\hello&quot;</span>\n<span class=\"hljs-attr\">WizardStyle</span>=modern\n\n<span class=\"hljs-section\">[Languages]</span>\nName: chinesesimp<span class=\"hljs-comment\">; MessagesFile: &quot;compiler:Languages\\ChineseSimplified.isl&quot;</span>\n\n<span class=\"hljs-section\">[Components]</span>\nName: a<span class=\"hljs-comment\">; Description: a</span>\nName: b<span class=\"hljs-comment\">; Description: b</span>\n\n<span class=\"hljs-section\">[Tasks]</span>\nName: p<span class=\"hljs-comment\">; Description: a or b; Components: a or b</span>\nName: q<span class=\"hljs-comment\">; Description: a and b; Components: a and b</span>\nName: r<span class=\"hljs-comment\">; Description: not a or b; Components: not a or b</span>\nName: s<span class=\"hljs-comment\">; Description: not (a or b); Components: not (a or b)</span>\nName: t<span class=\"hljs-comment\">; Description: a or b - old style; Components: a b</span></code></pre><ul>\n<li><p><img alt=\"03-hello-components-tasks.png\" loading=\"lazy\" title=\"03-hello-components-tasks.png\" class=\"post-image \" src=\"/images/f095aa13400ed3a2b7db95dd6a3938a7.03-hello-components-tasks.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n</li>\n<li><p><img alt=\"04-hello-components-tasks-2.png\" loading=\"lazy\" title=\"04-hello-components-tasks-2.png\" class=\"post-image \" src=\"/images/be4a4d753aca575578d3a2019fe3d009.04-hello-components-tasks-2.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n</li>\n<li><p><img alt=\"05-hello-components-tasks-3.png\" loading=\"lazy\" title=\"05-hello-components-tasks-3.png\" class=\"post-image \" src=\"/images/d1650c75b5fba7e17c4fdc5611d29925.05-hello-components-tasks-3.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n</li>\n<li><p><code>[Components]</code>、<code>[Tasks]</code> 定义了组件和任务（选项）</p>\n</li>\n<li><p><code>Components</code>、<code>Tasks</code> 参数就是根据条件（用户实际的选择组件或任务）来控制条目是否被处理</p>\n</li>\n</ul>\n<h1 id=\"Sections 学习\">Sections 学习<a name=\"Sections 学习\" class=\"headerlink\" href=\"#Sections 学习\"></a></h1><h2 id=\"[Setup]\">[Setup]<a name=\"[Setup]\" class=\"headerlink\" href=\"#[Setup]\"></a></h2><p>文档：<a href=\"https://jrsoftware.org/ishelp/topic_setupsection.htm\">https://jrsoftware.org/ishelp/topic_setupsection.htm</a></p>\n<p><code>[Setup]</code> 包含安装程序和卸载程序使用的全局设置，是必须的。同时 <code>[Setup]</code> 下的 <code>AppName</code>、<code>AppVersion</code> 和 <code>DefaultDirName</code> 指令也是必填的。</p>\n<p><code>[Setup]</code> 包含多达 150+ 的指令，这里只挑几个过一过，实际则用到的时候再对照文档去看了。</p>\n<p>指令大体分为三类：</p>\n<ul>\n<li>编译相关（Compiler-related），可以理解为会影响编译行为的指令，如：<ul>\n<li>Output：可以设置为 <code>yes</code> 或 <code>no</code>，默认为 <code>yes</code>，如果设置为 <code>no</code>，编译器将仅检查脚本中的错误并跳过创建安装文件</li>\n<li>OutputDir：指定输出目录，默认为 <code>Output</code>，可以设置为绝对路径或相对路径</li>\n</ul>\n</li>\n<li>安装相关（Installer-related），影响安装/卸载程序的操作，如：<ul>\n<li>AppName：该指令是必须，指定正在安装的应用程序名称。<strong>不要包括版本号，因为这由 AppVersion 和/或 AppVerName 指令定义</strong>。AppName 会显示在窗口标题、向导页面和对话框中</li>\n<li>AppVerName：该指令包含应用的名称和版本号，默认由 AppName 与 AppVersion 拼接而成，如果未设置 AppVersion 则该指令是必须的</li>\n</ul>\n</li>\n<li>和修饰类（Cosmetic），只影响安装程序的外观，如：<ul>\n<li>SetupIconFile：指定安装/卸载程序的图标，编译器会在源目录中查找图标文件，除非是绝对路径或以 <code>compiler:</code> 开头的路径</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"[Types]\">[Types]<a name=\"[Types]\" class=\"headerlink\" href=\"#[Types]\"></a></h2><p>需要与 <code>[Components]</code> 配合使用，相当于预定义一组集合，方便用户选择组件：</p>\n<p>唯一 Flags 参数的值是 <code>iscustom</code>，表示该类型是自定义类型，如果不定义自定义类型，则只允许用户选择预定义的类型，并且无法再手动选择/取消选择组件。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Types]</span>\nName: &quot;a&quot;<span class=\"hljs-comment\">; Description: &quot;Full installation&quot;</span>\nName: &quot;b&quot;<span class=\"hljs-comment\">; Description: &quot;Compact installation&quot;</span>\nName: &quot;c&quot;<span class=\"hljs-comment\">; Description: &quot;Custom installation&quot;; Flags: iscustom</span></code></pre><h2 id=\"[Components]\">[Components]<a name=\"[Components]\" class=\"headerlink\" href=\"#[Components]\"></a></h2><p>前文已有介绍，这里只说明与 <code>[Types]</code> 配合的使用：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Components]</span>\nName: &quot;c1&quot;<span class=\"hljs-comment\">; Description: &quot;c1&quot;; Types: a b c; Flags: fixed</span>\nName: &quot;c2&quot;<span class=\"hljs-comment\">; Description: &quot;c2&quot;; Types: a b</span>\nName: &quot;c3&quot;<span class=\"hljs-comment\">; Description: &quot;c3&quot;; Types: a</span></code></pre><p>因为定义了 <code>[Types]</code>，组件选择时会有三个选项，分别是 <code>Full installation</code>、<code>Compact installation</code> 和 <code>Custom installation</code>：</p>\n<ul>\n<li>选择 <code>Full installation</code> 会自动勾上 <code>c1</code>、<code>c2</code> 和 <code>c3</code></li>\n<li>选择 <code>Compact installation</code> 会自动勾上 <code>c1</code> 和 <code>c2</code></li>\n<li>若用户选择 <code>Custom installation</code>，则可以手动勾选 <code>c2</code> 和 <code>c3</code></li>\n<li><code>c1</code> 指定了 fixed，因此用户无法手动修改该选项</li>\n</ul>\n<h2 id=\"[Dirs]\">[Dirs]<a name=\"[Dirs]\" class=\"headerlink\" href=\"#[Dirs]\"></a></h2><p><code>[Dirs]</code> 定义了除用户选择的应用程序目录（自动创建）之外，安装程序需要创建的其他目录。在主应用程序目录下创建子目录是该 Section 常见的使用方式。</p>\n<p>请注意，在使用 [Files] 部分安装文件时，不必显式地创建目录，因此该 Section 主要用于创建空目录。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Dirs]</span>\nName: &quot;{app}\\data&quot;\nName: &quot;{app}\\bin&quot;</code></pre><h2 id=\"[Files]\">[Files]<a name=\"[Files]\" class=\"headerlink\" href=\"#[Files]\"></a></h2><p>该 Section 定义了安装程序需要安装的文件。换句话说，就是将定义的 Source 文件打包到安装程序中，安装的时候根据配置分别解压到特定目录。</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Files]</span>\nSource: &quot;README.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Flags: isreadme</span>\n<span class=\"hljs-comment\">; 支持通配符</span>\nSource: &quot;subdir\\*&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}\\subdir&quot;; Flags: isreadme</span></code></pre><h2 id=\"[Icons]\">[Icons]<a name=\"[Icons]\" class=\"headerlink\" href=\"#[Icons]\"></a></h2><p>该 Section 定义了安装程序如何在开始菜单或其他位置（如桌面）创建快捷方式。</p>\n<blockquote>\n<p>myapp.exe 是最终的可执行程序，也可以使用 Inno 自带的 demo 程序：<code>Inno 安装目录\\Examples\\MyProg.exe</code>。</p>\n</blockquote>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Icons]</span>\n<span class=\"hljs-comment\">; 创建桌面快捷方式</span>\nName: &quot;{group}\\My Program&quot;<span class=\"hljs-comment\">; Filename: &quot;{app}\\myapp.exe&quot;; WorkingDir: &quot;{app}&quot;</span></code></pre><h2 id=\"[Registry]\">[Registry]<a name=\"[Registry]\" class=\"headerlink\" href=\"#[Registry]\"></a></h2><p>该 Section 定义了安装程序如何在注册表中创建、修改或删除键/值。</p>\n<blockquote>\n<p>默认情况下，安装程序创建的注册表键和值在卸载时不会被删除。如果希望卸载程序的同时删除键或值，则 Flags 中须至少包含 uninsdelete、uninsdeletekeyifempty、uninsdeletevalue 中的一个。</p>\n</blockquote>\n<p>下面是注册伪协议的例子，可通过在浏览器中输入 <code>myapp://</code> 来打开应用程序：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Registry]</span>\nRoot: HKCR<span class=\"hljs-comment\">; SubKey: Myapp; ValueData: &quot;MyappProtocol&quot;; ValueType: string; Flags: createvalueifdoesntexist uninsdeletekey noerror;</span>\nRoot: HKCR<span class=\"hljs-comment\">; SubKey: Myapp; ValueName: &quot;URL Protocol&quot;; ValueData: &quot;{app}\\myapp.exe&quot;; ValueType: string; Flags: createvalueifdoesntexist uninsdeletekey noerror;</span>\nRoot: HKCR<span class=\"hljs-comment\">; SubKey: Myapp\\DefaultIcon; ValueData: &quot;{app}\\myapp.exe&quot;; ValueType: string; Flags: createvalueifdoesntexist uninsdeletekey noerror;</span>\nRoot: HKCR<span class=\"hljs-comment\">; SubKey: Myapp\\shell\\open\\command; ValueData: &quot;{app}\\myapp.exe --open-url=&quot;&quot;%1&quot;&quot;&quot;; Flags: uninsdeletekey noerror; ValueType: string;</span></code></pre><p>Flags 说明：</p>\n<ul>\n<li>createvalueifdoesntexist：注册表中不存在时才创建相应条目</li>\n<li>uninsdeletekey：卸载时删除该键</li>\n<li>noerror：不展示注册表键或值设置失败的信息</li>\n</ul>\n<blockquote>\n<p>官方不建议直接操作注册表 HKCR，而是使用 <code>HKA\\Software\\Classes</code> 作为替代。理由暂时不清楚，同时注册表的相关知识也只了解了零星半点，边学边搞吧。</p>\n</blockquote>\n<h2 id=\"[Run] &amp; [UninstallRun]\">[Run] &amp; [UninstallRun]<a name=\"[Run] &amp; [UninstallRun]\" class=\"headerlink\" href=\"#[Run] &amp; [UninstallRun]\"></a></h2><ul>\n<li><code>[Run]</code> 定义了在安装完成之后需要执行的程序</li>\n<li><code>[UninstallRun]</code> 定义了在卸载第一步需要执行的程序</li>\n</ul>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Run]</span>\n<span class=\"hljs-comment\">; 安装完成最后一步，关闭安装向导后是否允许 myapp.exe</span>\nFilename: &quot;{app}\\myapp.exe&quot;<span class=\"hljs-comment\">; Description: &quot;Run myapp&quot;; Flags: nowait postinstall skipifsilent</span></code></pre><h1 id=\"Pascal 脚本\">Pascal 脚本<a name=\"Pascal 脚本\" class=\"headerlink\" href=\"#Pascal 脚本\"></a></h1><p>除了上面看起来像是”配置式”的内容，Inno 还支持添加脚本（语法为 <a href=\"https://zh.wikipedia.org/zh-sg/Object_Pascal\">Object Pascal</a>）以实现自定义的逻辑，具有更多的创造性，比如：</p>\n<ul>\n<li>支持在自定义条件下中止安装或卸载</li>\n<li>支持在运行时添加自定义引导页面</li>\n<li>支持在安装之前、期间或之后通过 Pascal 脚本来提取、调用 DLL 或其他文件</li>\n<li>支持编写常量，这些常量可以执行普通常量、从注册表读取、从 ini 读取和从命令行读取等操作</li>\n<li>支持在运行时根据自定义条件删除 <code>[Types]</code>、<code>[Components]</code> 或 <code>[Tasks]</code></li>\n<li>基于自定义条件，支持有条件地安装 <code>[Files]</code>、<code>[Registry]</code>、<code>[Run]</code> 等条目</li>\n<li>提供了大量辅助函数，可通过 Pascal 脚本完成 Inno Setup 所能做到的几乎所有事情</li>\n</ul>\n<blockquote>\n<p>注意：从这里开始，若无特殊说明，脚本特指 <code>[Code]</code> 中的 Pascal 脚本，脚本仅在运行时执行，因此不能干涉 iss 本身的编译</p>\n</blockquote>\n<h2 id=\"[Code]\">[Code]<a name=\"[Code]\" class=\"headerlink\" href=\"#[Code]\"></a></h2><p>所有脚本内容的定义需要位于该 Section。</p>\n<h3 id=\"事件函数\">事件函数<a name=\"事件函数\" class=\"headerlink\" href=\"#事件函数\"></a></h3><p>可以在 <code>[Code]</code> 定义事件回调函数，在适当的时机会被执行，例：</p>\n<pre class=\"hljs language-pascal\" hljs-language=\"pascal\"><code style=\"display:block;\">[Code]\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">InitializeSetup</span><span class=\"hljs-params\">()</span>:</span> Boolean;\n  <span class=\"hljs-keyword\">begin</span>\n    <span class=\"hljs-keyword\">if</span> (Msgbox(<span class=\"hljs-string\">&#x27;是否继续安装&#x27;</span>, mbConfirmation, MB_YESNO) = IDYES) <span class=\"hljs-keyword\">then</span>\n      Result := True\n    <span class=\"hljs-keyword\">else</span>\n      Result := False\n    <span class=\"hljs-keyword\">end</span>;\n  <span class=\"hljs-keyword\">end</span>.</code></pre><p>定义事件函数 InitializeSetup，该函数会在安装初始化的时候被调用，返回值为 Boolean，如果返回 True 则继续安装，否则中止安装。上面的例子中，在初始化过程中加入了“弹出确认框”的逻辑，询问用户是否继续安装。</p>\n<p>通常情况下，同一个事件只能定义一个回调函数的实现。但使用事件属性（Event Attributes）可以在脚本中拥有同一事件函数的多个实现。这在包含了实现事件函数的外部脚本中特别有用，以避免与主要脚本发生冲突。</p>\n<p>以下是一个示例脚本，其中包含三个 InitializeWizard 事件函数的实现，每次触发会弹一个提示框，一共会弹三次：</p>\n<pre class=\"hljs language-pascal\" hljs-language=\"pascal\"><code style=\"display:block;\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">procedure</span> <span class=\"hljs-title\">InitializeWizard</span>;</span>\n<span class=\"hljs-keyword\">begin</span>\n  SuppressibleMsgBox(<span class=\"hljs-string\">&#x27;InitializeWizard called 1&#x27;</span>, mbInformation, MB_OK, IDOK);\n<span class=\"hljs-keyword\">end</span>;\n\n&lt;event(<span class=\"hljs-string\">&#x27;InitializeWizard&#x27;</span>)&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">procedure</span> <span class=\"hljs-title\">InitializeWizard2</span>;</span>\n<span class=\"hljs-keyword\">begin</span>\n  SuppressibleMsgBox(<span class=\"hljs-string\">&#x27;InitializeWizard called 2&#x27;</span>, mbInformation, MB_OK, IDOK);\n<span class=\"hljs-keyword\">end</span>;\n\n&lt;event(<span class=\"hljs-string\">&#x27;InitializeWizard&#x27;</span>)&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">procedure</span> <span class=\"hljs-title\">InitializeWizard3</span>;</span>\n<span class=\"hljs-keyword\">begin</span>\n  SuppressibleMsgBox(<span class=\"hljs-string\">&#x27;InitializeWizard called 3&#x27;</span>, mbInformation, MB_OK, IDOK);\n<span class=\"hljs-keyword\">end</span>;</code></pre><p>注意到，第二个定义需要使用了 <code>procedure</code> 关键字，而不是 <code>function</code>，两者都是子程序，但又有区别，简单来说：</p>\n<ul>\n<li><code>procedure</code> 表示过程，不会直接返回值</li>\n<li><code>function</code> 是函数，返回单个值</li>\n</ul>\n<h3 id=\"脚本常量\">脚本常量<a name=\"脚本常量\" class=\"headerlink\" href=\"#脚本常量\"></a></h3><p>这个例子演示了如何在脚本中使用常量，同时脚本中定义的函数也可以在其他地方使用，比如：</p>\n<pre class=\"hljs language-pascal\" hljs-language=\"pascal\"><code style=\"display:block;\">[Setup]\nDefaultDirName=&quot;<span class=\"hljs-comment\">{code:MyConst}</span>&quot;\n\n[Code]\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">MyConst</span><span class=\"hljs-params\">(Param: <span class=\"hljs-keyword\">String</span>)</span>:</span> <span class=\"hljs-keyword\">String</span>;\n<span class=\"hljs-keyword\">begin</span>\n  Result := ExpandConstant(<span class=\"hljs-string\">&#x27;{userdesktop}&#x27;</span>) + <span class=\"hljs-string\">&#x27;/appdest&#x27;</span>;\n<span class=\"hljs-keyword\">end</span>;</code></pre><p>注意，<code>MyConst</code> 函数必须要定义一个参数。</p>\n<p>同时，Inno <a href=\"https://jrsoftware.org/ishelp/topic_scriptfunctions.htm\">内置了许多函数</a>可以被直接使用：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[INI]</span>\n<span class=\"hljs-comment\">; GetShortName</span>\nFileName: &quot;{app}\\MyIni.ini&quot;<span class=\"hljs-comment\">; Section: &quot;MySettings&quot;; Key: &quot;ShortApp&quot;; String: &quot;{code:GetShortName|{app}}&quot;</span></code></pre><h3 id=\"Check 参数\">Check 参数<a name=\"Check 参数\" class=\"headerlink\" href=\"#Check 参数\"></a></h3><p>所有参数形式的 Section 都支持 <code>Check</code> 参数，可以在程序过程中根据条件决定是否生效，比如：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Files]</span>\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Check: MyProgCheck</span>\nSource: &quot;A\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Check: MyDirCheck(ExpandConstant(&#x27;{app}\\A&#x27;))</span>\nSource: &quot;B\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; Check: DirExists(ExpandConstant(&#x27;{app}\\B&#x27;))</span>\n\n<span class=\"hljs-section\">[Code]</span>\nvar\n  MyProgChecked: Boolean<span class=\"hljs-comment\">;</span>\n  MyProgCheckResult: Boolean<span class=\"hljs-comment\">;</span>\n\nfunction MyProgCheck(): Boolean<span class=\"hljs-comment\">;</span>\nbegin\n  if not MyProgChecked then begin\n    MyProgCheckResult := MsgBox(&#x27;Do you want to install MyProg.exe to &#x27; + ExtractFilePath(CurrentFileName) + &#x27;?&#x27;, mbConfirmation, MB_YESNO) = idYes<span class=\"hljs-comment\">;</span>\n    MyProgChecked := True<span class=\"hljs-comment\">;</span>\n  end<span class=\"hljs-comment\">;</span>\n  Result := MyProgCheckResult<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span>\n\nfunction MyDirCheck(DirName: String): Boolean<span class=\"hljs-comment\">;</span>\nbegin\n  Result := DirExists(DirName)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span></code></pre><p>注意：</p>\n<ul>\n<li><code>[Files]</code> 中的条目如果包含通配符，<code>Check</code> 会对每一个文件都执行一次，而不是整个条目</li>\n</ul>\n<h3 id=\"BeforeInstall &amp; AfterInstall 参数\">BeforeInstall &amp; AfterInstall 参数<a name=\"BeforeInstall &amp; AfterInstall 参数\" class=\"headerlink\" href=\"#BeforeInstall &amp; AfterInstall 参数\"></a></h3><p>所有参数形式的 Section 也都支持 <code>BeforeInstall</code> 和 <code>AfterInstall</code>，分别是在条目安装之前、之后执行：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Files]</span>\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; BeforeInstall: MyBeforeInstall</span>\nSource: &quot;A\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; BeforeInstall: MyBeforeInstall2(&#x27;{app}\\A\\MYFILE.TXT&#x27;)</span>\nSource: &quot;B\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; BeforeInstall: MyBeforeInstall2(&#x27;{app}\\B\\MYFILE.TXT&#x27;)</span>\nSource: &quot;MYPROG.CHM&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; BeforeInstall: Log(&#x27;Before MYPROG.CHM Install&#x27;)</span>\n\nSource: &quot;MYPROG.EXE&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; AfterInstall: MyAfterInstall</span>\nSource: &quot;A\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; AfterInstall: MyAfterInstall2(&#x27;{app}\\A\\MYFILE.TXT&#x27;)</span>\nSource: &quot;B\\MYFILE.TXT&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; AfterInstall: MyAfterInstall2(&#x27;{app}\\B\\MYFILE.TXT&#x27;)</span>\nSource: &quot;MYPROG.CHM&quot;<span class=\"hljs-comment\">; DestDir: &quot;{app}&quot;; AfterInstall: Log(&#x27;After MYPROG.CHM Install&#x27;)</span>\n\n<span class=\"hljs-section\">[Code]</span>\nprocedure MyBeforeInstall()<span class=\"hljs-comment\">;</span>\nbegin\n  MsgBox(&#x27;About to install MyProg.exe as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span>\n\nprocedure MyBeforeInstall2(FileName: String)<span class=\"hljs-comment\">;</span>\nbegin\n  MsgBox(&#x27;About to install &#x27; + FileName + &#x27; as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span>\n\nprocedure MyAfterInstall()<span class=\"hljs-comment\">;</span>\nbegin\n  MsgBox(&#x27;Just installed MyProg.exe as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span>\n\nprocedure MyAfterInstall2(FileName: String)<span class=\"hljs-comment\">;</span>\nbegin\n  MsgBox(&#x27;Just installed &#x27; + FileName + &#x27; as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class=\"hljs-comment\">;</span>\nend<span class=\"hljs-comment\">;</span></code></pre><p>注意：</p>\n<ul>\n<li>所有 BeforeInstall 和 AfterInstall 的函数不应该拥有返回值</li>\n<li>如果安装程序已确定不应处理该条目，则不会调用 BeforeInstall 或 AfterInstall 函数</li>\n<li><code>[Files]</code> 中的条目如果包含通配符，BeforeInstall 和 AfterInstall 会对每一个文件都执行一次，而不是整个条目</li>\n</ul>\n<h3 id=\"调用 DLLs 和 .Net 程序集\">调用 DLLs 和 .Net 程序集<a name=\"调用 DLLs 和 .Net 程序集\" class=\"headerlink\" href=\"#调用 DLLs 和 .Net 程序集\"></a></h3><p>脚本可以调用外部 DLL 中的函数，这包括标准 Windows DLL 中的标准 Win32 API 函数和自定义制作的 DLL 中的自定义函数。此外，还可以调用 .NET 程序集。</p>\n<blockquote>\n<p>先知道有这么个能力吧，实际还没用到过</p>\n</blockquote>\n<h3 id=\"使用 COM Automation Objects\">使用 COM Automation Objects<a name=\"使用 COM Automation Objects\" class=\"headerlink\" href=\"#使用 COM Automation Objects\"></a></h3><blockquote>\n<p>这些概念属实没接触过，感觉上也是能直接调用一些系统或系统库的能力</p>\n</blockquote>\n<p>脚本可以通过 COM Automation 对象支持来访问 COM（也称为 OLE 或 ActiveX）方法和属性。这使得可以访问标准 Windows COM 服务器、自定义 COM 服务器、Visual Basic ActiveX DLL 和 .NET 程序集，可以通过 COM Interop 进行交互。</p>\n<ul>\n<li>IDispatch based COM<ul>\n<li>可通过 CreateOleObject 和 GetActiveOleObject 来初始化基于 IDispatch 的 COM</li>\n</ul>\n</li>\n<li>IUnknown based COM<ul>\n<li>如果对象没有实现 IDispatch 接口，可以使用 CreateComObject 来初始化基于 IUnknown 的 COM</li>\n</ul>\n</li>\n</ul>\n<p>如下是一个通过 WinHttpRequest 发送 HTTP 请求的例子：</p>\n<pre class=\"hljs language-ini\" hljs-language=\"ini\"><code style=\"display:block;\"><span class=\"hljs-section\">[Code]</span>\nprocedure SendHttp<span class=\"hljs-comment\">;</span>\n  begin\n    WinHttpReq := CreateOleObject(&#x27;WinHttp.WinHttpRequest.5.1&#x27;)<span class=\"hljs-comment\">;</span>\n    WinHttpReq.Open(&#x27;POST&#x27;, &#x27;https://api.exapmle.com&#x27;, false)<span class=\"hljs-comment\">;</span>\n    WinHttpReq.SetRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)<span class=\"hljs-comment\">;</span>\n    WinHttpReq.Send(&#x27;{&quot;key&quot;:&quot;value&quot;}&#x27;)<span class=\"hljs-comment\">;</span>\n  end<span class=\"hljs-comment\">;</span></code></pre><h1 id=\"结语\">结语<a name=\"结语\" class=\"headerlink\" href=\"#结语\"></a></h1><p>根据文档说明，每个 Section 逐步试验下来，基本上浅浅了解了下 Inno 的各个方面。Inno 本身不难，就是各种指令、参数、Flags 以及内置函数比较多，想要全盘熟悉、用得顺手也不容易。对于 Pascal 语言，虽然没接触过，但有编程经验学点简单的写法很轻松。</p>\n<p>个人而言，最棘手的还是 Windows 平台开发相关的内容，比如注册表的修改，为什么改这个键，为什么设置这个值，这需要查询另外的资料；比如 <code>[Code]</code> 脚本中，可以调用哪些能力，这也需要额外的知识和经验，这些都是我目前未接触的领域。</p>\n<p>总之，Inno 不难，以后随着实际使用再慢慢深入吧。</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li>官方文档：<a href=\"https://jrsoftware.org/ishelp/\">https://jrsoftware.org/ishelp/</a></li>\n<li>Object Pascal：<a href=\"https://zh.wikipedia.org/zh-sg/Object_Pascal\">https://zh.wikipedia.org/zh-sg/Object_Pascal</a></li>\n<li>Pascal 教程：<a href=\"https://www.jc2182.com/pascal/pascal-jiaocheng.html\">https://www.jc2182.com/pascal/pascal-jiaocheng.html</a></li>\n</ul>\n","hash":"0c1c52bbcd5a2832d50b1e78b7b22d17","isArticle":true,"sort":0,"filename":"","raw":"","prev":{"id":"further-knowledge-of-ssh-and-ssh-config","slug":"post/further-knowledge-of-ssh-and-ssh-config","path":"/post/further-knowledge-of-ssh-and-ssh-config","title":"进一步认识 SSH 和 SSH config","comments":true,"published":true,"date":"2022-12-22T10:53:04.000Z","updated":"","tags":[{"id":"765553e6c7ac8592c389acb9878a050a","name":"SSH","postCount":1,"postIds":[]}],"categories":[{"id":"edc9f0a5a5d57797bf68e37364743831","name":"Linux","slug":"categories/Linux","path":"/categories/Linux","parentId":"","postCount":4,"postIds":[]}],"excerpt":"<p>不知道有多少人和我一样，对 SSH key 的接触起始于 Git 的使用，反正是啥也不懂，跟着教程一顿敲：</p>\n<pre class=\"hljs language-bash\" hljs-language=\"bash\"><code style=\"display:block;\">$ ssh-keygen -t rsa -b 2048 -C <span class=\"hljs-string\">&quot;xxxxxxxxxx@qq.com&quot;</span></code></pre><p>一路回车，然后把 <code>id_rsa.pub</code> 的内容填入到 Github/Gitlab 的设置里，就转头去使用 Git 了。</p>\n","more":"","hash":"764b88a83225c7530143ae3dec7d28ee","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""},"next":{"id":"electron-file-association","slug":"post/electron-file-association","path":"/post/electron-file-association","title":"Electron 实现文件关联","comments":true,"published":true,"date":"2023-05-04T11:45:57.000Z","updated":"","tags":[{"id":"ad7123e6c402c7d6c71d0a1032463ea3","name":"桌面开发","postCount":1,"postIds":[]},{"id":"0df2da9cf88450e6758356da45b4d04f","name":"Electron","postCount":1,"postIds":[]},{"id":"9c7fbd4a02af897333481b3df892fddf","name":"Inno Setup","postCount":1,"postIds":[]}],"categories":[],"excerpt":"<p>最近在做一个 Electron 桌面应用，需要实现文件关联，把特定后缀的文件关联到应用上，双击文件可以直接打开应用并读取文件。</p>\n<p>文件关联与操作系统相关性比较大，不同的操作系统实现方式也会不同。不过如果使用 <a href=\"https://www.electron.build/\">electron-builder</a> 进行应用打包，可以直接通过 <a href=\"configuration/configuration.html#overridable-per-platform-options\">fileAssociations</a> 配置来实现文件关联。</p>\n<p>而我这边使用 <a href=\"https://github.com/electron/electron-packager\">electron-packager</a> 打包，不会直接产出安装程序，所以需要自行实现文件关联，同时可以借机进一步了解 Windows 和 Mac 实现文件关联的细节。</p>\n","more":"","hash":"69a815e27e40b55a29f295a0dfa087c3","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""}}},"tocHtml":"","simplePages":[{"id":"41a3cc43f8af362b82fbe2aa97817528","slug":"resume","path":"/resume"},{"id":"fabb5629b694584be9ff314ab8187577","slug":"resume-v2","path":"/resume-v2"},{"id":"34787f8e18c76ce0f4c3cc680ab728ef","slug":"resume-v1","path":"/resume-v1"},{"id":"ac298b1fdf5a34ac83bb9376ccdde006","slug":"about","path":"/about"}],"simplePageDetail":{"post":null}},"labels":{"labels":[],"postPagination":{"current":1,"pageSize":10,"totalPages":0,"result":[]}}}</script>
    <script>
      if (/MSIE \d|Trident.*rv:/.test(navigator.userAgent)) {
        // redirect IE to Edge
        // This browser is no longer supported
        window.location.href = 'microsoft-edge:' + window.location.href;
        alert('请使用 Chrome/Edge/Firefox/Safari 等现代浏览器。');
        throw new Error('请使用 Chrome/Edge/Firefox/Safari 等现代浏览器。');
      }
    </script>
    <script type="module" crossorigin src="/assets/index.bf8c73c6.js"></script>
    <link rel="stylesheet" href="/assets/index.48ca4a1c.css">
  </head>
  <body  data-head-attrs="">
    <div id="app"><!--[--><div class="m-4 max-w-screen-xl flex flex-wrap md:m-6 xl:mx-auto md:flex-nowrap"><div class="w-full flex-shrink-0 self-start md:sticky md:top-6 md:w-48"><div class="blog-base-area-box py-6 mb-4"><img class="block w-24 h-24 rounded-full mx-auto" src="https://avatars.githubusercontent.com/u/19222089?v=4"><div class="mt-5 px-3 text-center"><h1 class="text-c-title font-normal"><a href="" class="unset">daief的个人日志</a></h1><p class="mt-2 text-sm text-c-secondary break-words">遇见你，遇见幸运💫</p><div class="mt-3 text-xs flex justify-center"><a href="/" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-wenzhang" data-v-43154e2c></use></svg>(51) </a><span class="mx-1 text-c-secondary">|</span><a href="/tags" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg>(42) </a><span class="mx-1 text-c-secondary">|</span><a href="/categories" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-category" data-v-43154e2c></use></svg>(16) </a></div><div class="mt-6 flex justify-center"><a to="https://github.com/daief" replace="false" href="https://github.com/daief" target="_blank" class="unset cursor-pointer"><!--[--><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-github" data-v-43154e2c></use></svg><!--]--></a><span class="mx-2"></span><a to="mailto:defeng_mail@163.com" replace="false" href="mailto:defeng_mail@163.com" target="_blank" class="unset cursor-pointer"><!--[--><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-email" data-v-43154e2c></use></svg><!--]--></a></div></div><div class="mt-6"><div class="text-center" data-v-73630894><!--[--><a href="/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>首页</a><a href="/categories/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>分类</a><a href="/tags/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>标签</a><a href="/about/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>关于</a><!--]--></div></div></div><div class="hidden md:block mt-2"><div class="footer text-center text-sm" data-v-8b3f10e8><div data-v-8b3f10e8><div data-v-8b3f10e8>© 2017-2025</div></div><div class="flex items-center justify-center" data-v-8b3f10e8>By <a href="https://github.com/daief/blog/tree/master/packages/gugu" target="_blank" data-v-8b3f10e8>gugu</a>  &amp; daief - <span class="picker-wrap" data-v-7aa3923e data-v-8b3f10e8><span data-v-7aa3923e></span></span></div><!----><!----><div data-v-8b3f10e8><a href="/sitemap.xml" target="_blank" data-v-8b3f10e8>站点地图</a></div></div></div></div><div class="w-full md:w-0 md:flex-grow md:mx-5"><div><!--[--><div class="blog-base-area-box px-4 py-8 md:px-8"><div><h1 class="text-2xl font-normal break-words">Inno Setup</h1><div class="my-4 text-xs text-c-secondary"><div class="flex items-center flex-wrap"><!----><!----><div class="whitespace-nowrap"><svg class="if-icon text-c-secondary mx-1 text-c-secondary mx-1" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-calendar" data-v-43154e2c></use></svg>2023-04-07</div><!--[--><span class="mx-1">|</span><div class="whitespace-nowrap"><svg class="if-icon text-c-secondary mx-1 text-c-secondary mx-1" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-folder" data-v-43154e2c></use></svg><!--[--><!--[--><a href="/categories/桌面开发" class="unset">桌面开发</a><span></span><!--]--><!--]--></div><!--]--><!----></div></div><!-- content --><div class="markdown-body text-sm text-gray-800 leading-loose"><p>最近工作上遇到了 Inno Setup，这对于我来说是个新东西，看不懂，那么就学一下吧。</p>

<a id="more" class="h-0 mt-3 block"></a>


<h1 id="安装 &amp; 起步">安装 &amp; 起步<a name="安装 &amp; 起步" class="headerlink" href="#安装 &amp; 起步"></a></h1><blockquote>
<p>当前所使用的 Inno Setup 版本是 6.2.2</p>
</blockquote>
<p>Inno Setup（后文将简称为 Inno） 是一个开源的安装包制作工具，小巧但强大，官网下载地址：<a href="https://jrsoftware.org/isinfo.php">https://jrsoftware.org/isinfo.php</a>。</p>
<p>官方文档：<a href="https://jrsoftware.org/ishelp/">https://jrsoftware.org/ishelp/</a></p>
<p>下载安装之后打开 Inno，实际上是一个编辑器，可以直接编辑脚本，可以编译、运行脚本，生成安装程序。</p>
<p>选择新建脚本，写入以下内容：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Setup]</span>
<span class="hljs-attr">AppName</span>=My Program
<span class="hljs-attr">AppVersion</span>=<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>
<span class="hljs-attr">DefaultDirName</span>=<span class="hljs-string">&quot;{userdesktop}\hello&quot;</span></code></pre><p>点击编译（Compile），在对话框中选择保存脚本（比如 hello.iss），之后在脚本的同级会生成一个 <code>Output</code>，里面有一个 <code>mysetup.exe</code>。</p>
<p>双击 <code>mysetup.exe</code> 就开始安装引导了：</p>
<p><img alt="01-hello-installer.png" loading="lazy" title="01-hello-installer.png" class="post-image " src="/images/d63e5c4d496d5cbc50b06f875ba776b7.01-hello-installer.png" onerror="this.onerror=null;this.src='/images/image-error.jpg';"></p>
<p>回顾上述脚本：</p>
<ul>
<li><code>[Setup]</code>：此部分包含安装程序和卸载程序使用的全局设置，该 <code>Section</code> 是必须的</li>
<li><code>AppName</code> 和 <code>AppVersion</code> 分别定义应用程序的名称和版本</li>
<li><code>DefaultDirName</code> 是默认的安装目录，这里使用了一个<strong>常量</strong> <code>userdesktop</code>，表示用户桌面的路径</li>
</ul>
<p>根据安装引导的提示完成安装，最终会在指定路径创建一个文件夹，包含如下卸载程序：</p>
<ul>
<li>unins000.dat</li>
<li>unins000.exe</li>
</ul>
<p>除了手写脚本，Inno 本身自带可视化的界面去制作安装程序，在可视化界面中一步步进行下去，最后可以将一系列操作保存为一份脚本。可视化的操作很方便易学，不过这里不对可视化操作进行过多介绍了，主要还是学习一下脚本的编写。</p>
<h1 id="脚本学习">脚本学习<a name="脚本学习" class="headerlink" href="#脚本学习"></a></h1><h2 id="iss 脚本概览">iss 脚本概览<a name="iss 脚本概览" class="headerlink" href="#iss 脚本概览"></a></h2><p>每一个 iss 脚本由若干个 <code>Section</code> 组成，每个 <code>Section</code> 有各自的职责。一个 <code>Section</code> 由方括号 <code>[]</code> 包裹，其中包含 <code>Section</code> 的名称。在每个 <code>Section</code> 内可以包含任意数量的条目。</p>
<p><code>Section</code> 可以分为两类：</p>
<ul>
<li>像 <code>[Setup]</code> 这样，它的条目由指令名称和值（形式为 Directive=Value）构成</li>
<li>以及像 <code>[Files]</code> 这样，它的条目是由多个键值对通过分号连接而成，这种形式下的键值对又称为参数（Parameter）</li>
</ul>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Setup]</span>
<span class="hljs-attr">AppName</span>=My Program

<span class="hljs-section">[Files]</span>
Source: &quot;MYPROG.EXE&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;</span></code></pre><blockquote>
<p>注意：</p>
<ul>
<li>每个 <code>Section</code> 内部的条目可以使用相同的名称</li>
<li>可以存在多个同名 <code>Section</code></li>
<li>默认情况下，指令值中的任何前导或尾随空格都将被删除。可以通过在指令值周围加上双引号 <code>&quot;</code> 来避免</li>
<li>iss 本身大小写不敏感，但是需要注意有些“值”的书写方式，比如应用名称会在某些地方直接展示给用户，故不可随意书写</li>
</ul>
</blockquote>
<p>iss 的注释由 <code>;</code> 开头，<code>[Code]</code> 部分的注释另有两种方式：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Setup]</span>
<span class="hljs-comment">; AppName 指定应用程序的名称，这是一条注释</span>
<span class="hljs-attr">AppName</span>=My Program

<span class="hljs-section">[Code]</span>
// 单行注释
(* 多行注释 *)</code></pre><p>支持类似 C 语言的 <code>#include</code> 指令，它可以将另一个文件中的内容插入到脚本中指令所在的位置。</p>
<pre class="hljs language-c" hljs-language="c"><code style="display:block;"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;filename.txt&quot;</span></span></code></pre><p>如果文件名不是绝对路径，编译器将在 iss 文件所在目录中查找。文件名可以以 <code>compiler:</code> 为前缀，在这种情况下，它会在编译器目录中查找该文件。</p>
<blockquote>
<p><code>compiler:</code> 为前缀时，查找编译器目录，指的就是 Inno Setup 的安装目录。</p>
</blockquote>
<p>支持 <code>#preproc</code> 指令，该指令指定是否使用内置预处理器（仅支持上述 #include 指令）或使用 Inno 预处理器 (ISPP)，后者支持更多的指令。</p>
<pre class="hljs language-text" hljs-language="text"><code style="display:block;">#preproc builtin
#preproc ispp</code></pre><p>默认情况下，iss 脚本使用 ISPP（如果可用），而 .isl 文件使用内置（built-in）预处理器。</p>
<h2 id="多语言">多语言<a name="多语言" class="headerlink" href="#多语言"></a></h2><p>Inno 官方自带一部分多语言，可以在 Inno 安装目录下的 <code>Languages</code> 文件夹中找到。</p>
<p>对于官方未支持的多语言（比如中文），可以在 <a href="https://jrsoftware.org/files/istrans/">https://jrsoftware.org/files/istrans/</a> 下载，下载之后保存到 Inno 的 <code>Languages</code> 文件夹中，命名为 <code>ChineseSimplified.isl</code>。</p>
<blockquote>
<p>注意：文件格式不能是 UTF-8，需要是 UTF-8 with BOM 或者是 GBK 编码（可能还有其他可行的编码，但没尝试过），否则会出现中文乱码。</p>
</blockquote>
<p>针对最开始的脚本，添加中文支持，重新编译并运行：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Setup]</span>
<span class="hljs-attr">AppName</span>=My Program
<span class="hljs-attr">AppVersion</span>=<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>
<span class="hljs-attr">DefaultDirName</span>=<span class="hljs-string">&quot;{userdesktop}\hello&quot;</span>
<span class="hljs-attr">WizardStyle</span>=modern

<span class="hljs-comment">; 新增 Languages Section，指定为中文</span>
<span class="hljs-section">[Languages]</span>
Name: chinesesimp<span class="hljs-comment">; MessagesFile: &quot;compiler:Languages\ChineseSimplified.isl&quot;</span></code></pre><p><img alt="02-hello-installer-chinese.png" loading="lazy" title="02-hello-installer-chinese.png" class="post-image " src="/images/85d0dbbe3d52136ba35b6988deddf206.02-hello-installer-chinese.png" onerror="this.onerror=null;this.src='/images/image-error.jpg';"></p>
<h2 id="常量（Constants）">常量（Constants）<a name="常量（Constants）" class="headerlink" href="#常量（Constants）"></a></h2><p>前文 <code>DefaultDirName=&quot;{userdesktop}\hello&quot;</code>、<code>Source: &quot;MYPROG.EXE&quot;; DestDir: &quot;{app}&quot;</code> 中的 <code>userdesktop</code> 和 <code>app</code> 都是常量，安装和卸载的过程中，常量会被替换为用户选择的值或系统配置中的值。</p>
<p>比如，<code>{app}</code> 常量会被替换为应用程序的安装目录，<code>{userdesktop}</code> 常量会被替换为用户桌面的路径。</p>
<p>完整的常量列表可以参考官方文档的常量章节。</p>
<h2 id="公共参数（Common Parameters）">公共参数（Common Parameters）<a name="公共参数（Common Parameters）" class="headerlink" href="#公共参数（Common Parameters）"></a></h2><p>公共参数是指能在所有 <code>Section</code> 中都能被使用的参数，共有三条：</p>
<ul>
<li><code>Languages</code></li>
<li><code>MinVersion</code></li>
<li><code>OnlyBelowVersion</code></li>
</ul>
<blockquote>
<p>TODO 待完善</p>
</blockquote>
<h2 id="Components 和 Tasks 参数">Components 和 Tasks 参数<a name="Components 和 Tasks 参数" class="headerlink" href="#Components 和 Tasks 参数"></a></h2><p>除了 <code>[Types]</code>、<code>[Components]</code> 和 <code>[Tasks]</code>，其他 <code>Section</code> 都支持 <code>Components</code> 和 <code>Tasks</code> 两个可选参数。</p>
<h3 id="Components 参数">Components 参数<a name="Components 参数" class="headerlink" href="#Components 参数"></a></h3><p>一个由空格分隔的组件名称列表，告诉安装程序该条目属于哪些组件。如果最终用户从此列表中选择了一个组件，则会处理该条目（例如：安装文件）。</p>
<p>没有 <code>Components</code> 参数的条目始终会被处理，除非有其他参数（比如后文的 Check）指示不应该这样做。</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Files]</span>
Source: &quot;MYPROG.EXE&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; Components: main</span>
Source: &quot;MYPROG.CHM&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; Components: help</span>
Source: &quot;README.TXT&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;</span></code></pre><h3 id="Tasks 参数">Tasks 参数<a name="Tasks 参数" class="headerlink" href="#Tasks 参数"></a></h3><p>一个以空格分隔的任务名称列表，告诉安装程序该条目属于哪个任务。如果最终用户从此列表中选择了一个任务，则会处理该条目（例如：安装文件）。</p>
<p>没有 <code>Tasks</code> 参数的条目始终会被处理，除非其他参数说明不应该这样做。</p>
<blockquote>
<p>请注意，在“选择开始菜单文件夹”向导页面上的“不创建开始菜单文件夹”复选框不影响具有 Tasks 参数的 <code>[Icons]</code> 条目，因为它们有自己的复选框。</p>
</blockquote>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Icons]</span>
Name: &quot;{group}\My Program&quot;<span class="hljs-comment">; Filename: &quot;{app}\MyProg.exe&quot;; Components: main; Tasks: startmenu</span>
Name: &quot;{group}\My Program Help&quot;<span class="hljs-comment">; Filename: &quot;{app}\MyProg.chm&quot;; Components: help; Tasks: startmenu</span>
Name: &quot;{commondesktop}\My Program&quot;<span class="hljs-comment">; Filename: &quot;{app}\MyProg.exe&quot;; Components: main; Tasks: desktopicon</span></code></pre><p>除了空格分隔的列表，还可以将布尔表达式用作组件和任务参数。支持的运算符包括 <code>not</code>、<code>and</code> 和 <code>or</code>。</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Components]</span>
Name: a<span class="hljs-comment">; Description: a</span>
Name: b<span class="hljs-comment">; Description: b</span>

<span class="hljs-section">[Tasks]</span>
Name: p<span class="hljs-comment">; Description: a or b; Components: a or b</span>
Name: q<span class="hljs-comment">; Description: a and b; Components: a and b</span>
Name: r<span class="hljs-comment">; Description: not a or b; Components: not a or b</span>
Name: s<span class="hljs-comment">; Description: not (a or b); Components: not (a or b)</span>
Name: t<span class="hljs-comment">; Description: a or b - old style; Components: a b</span></code></pre><h3 id="尝试">尝试<a name="尝试" class="headerlink" href="#尝试"></a></h3><p>上面都是摘自官方的解释，但到底是什么表现呢？</p>
<p>在脚本中新增 <code>Components</code> 和 <code>Tasks</code> 的相关内容，重新编译并运行：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Setup]</span>
<span class="hljs-attr">AppName</span>=My Program
<span class="hljs-attr">AppVersion</span>=<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>
<span class="hljs-attr">DefaultDirName</span>=<span class="hljs-string">&quot;{userdesktop}\hello&quot;</span>
<span class="hljs-attr">WizardStyle</span>=modern

<span class="hljs-section">[Languages]</span>
Name: chinesesimp<span class="hljs-comment">; MessagesFile: &quot;compiler:Languages\ChineseSimplified.isl&quot;</span>

<span class="hljs-section">[Components]</span>
Name: a<span class="hljs-comment">; Description: a</span>
Name: b<span class="hljs-comment">; Description: b</span>

<span class="hljs-section">[Tasks]</span>
Name: p<span class="hljs-comment">; Description: a or b; Components: a or b</span>
Name: q<span class="hljs-comment">; Description: a and b; Components: a and b</span>
Name: r<span class="hljs-comment">; Description: not a or b; Components: not a or b</span>
Name: s<span class="hljs-comment">; Description: not (a or b); Components: not (a or b)</span>
Name: t<span class="hljs-comment">; Description: a or b - old style; Components: a b</span></code></pre><ul>
<li><p><img alt="03-hello-components-tasks.png" loading="lazy" title="03-hello-components-tasks.png" class="post-image " src="/images/f095aa13400ed3a2b7db95dd6a3938a7.03-hello-components-tasks.png" onerror="this.onerror=null;this.src='/images/image-error.jpg';"></p>
</li>
<li><p><img alt="04-hello-components-tasks-2.png" loading="lazy" title="04-hello-components-tasks-2.png" class="post-image " src="/images/be4a4d753aca575578d3a2019fe3d009.04-hello-components-tasks-2.png" onerror="this.onerror=null;this.src='/images/image-error.jpg';"></p>
</li>
<li><p><img alt="05-hello-components-tasks-3.png" loading="lazy" title="05-hello-components-tasks-3.png" class="post-image " src="/images/d1650c75b5fba7e17c4fdc5611d29925.05-hello-components-tasks-3.png" onerror="this.onerror=null;this.src='/images/image-error.jpg';"></p>
</li>
<li><p><code>[Components]</code>、<code>[Tasks]</code> 定义了组件和任务（选项）</p>
</li>
<li><p><code>Components</code>、<code>Tasks</code> 参数就是根据条件（用户实际的选择组件或任务）来控制条目是否被处理</p>
</li>
</ul>
<h1 id="Sections 学习">Sections 学习<a name="Sections 学习" class="headerlink" href="#Sections 学习"></a></h1><h2 id="[Setup]">[Setup]<a name="[Setup]" class="headerlink" href="#[Setup]"></a></h2><p>文档：<a href="https://jrsoftware.org/ishelp/topic_setupsection.htm">https://jrsoftware.org/ishelp/topic_setupsection.htm</a></p>
<p><code>[Setup]</code> 包含安装程序和卸载程序使用的全局设置，是必须的。同时 <code>[Setup]</code> 下的 <code>AppName</code>、<code>AppVersion</code> 和 <code>DefaultDirName</code> 指令也是必填的。</p>
<p><code>[Setup]</code> 包含多达 150+ 的指令，这里只挑几个过一过，实际则用到的时候再对照文档去看了。</p>
<p>指令大体分为三类：</p>
<ul>
<li>编译相关（Compiler-related），可以理解为会影响编译行为的指令，如：<ul>
<li>Output：可以设置为 <code>yes</code> 或 <code>no</code>，默认为 <code>yes</code>，如果设置为 <code>no</code>，编译器将仅检查脚本中的错误并跳过创建安装文件</li>
<li>OutputDir：指定输出目录，默认为 <code>Output</code>，可以设置为绝对路径或相对路径</li>
</ul>
</li>
<li>安装相关（Installer-related），影响安装/卸载程序的操作，如：<ul>
<li>AppName：该指令是必须，指定正在安装的应用程序名称。<strong>不要包括版本号，因为这由 AppVersion 和/或 AppVerName 指令定义</strong>。AppName 会显示在窗口标题、向导页面和对话框中</li>
<li>AppVerName：该指令包含应用的名称和版本号，默认由 AppName 与 AppVersion 拼接而成，如果未设置 AppVersion 则该指令是必须的</li>
</ul>
</li>
<li>和修饰类（Cosmetic），只影响安装程序的外观，如：<ul>
<li>SetupIconFile：指定安装/卸载程序的图标，编译器会在源目录中查找图标文件，除非是绝对路径或以 <code>compiler:</code> 开头的路径</li>
</ul>
</li>
</ul>
<h2 id="[Types]">[Types]<a name="[Types]" class="headerlink" href="#[Types]"></a></h2><p>需要与 <code>[Components]</code> 配合使用，相当于预定义一组集合，方便用户选择组件：</p>
<p>唯一 Flags 参数的值是 <code>iscustom</code>，表示该类型是自定义类型，如果不定义自定义类型，则只允许用户选择预定义的类型，并且无法再手动选择/取消选择组件。</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Types]</span>
Name: &quot;a&quot;<span class="hljs-comment">; Description: &quot;Full installation&quot;</span>
Name: &quot;b&quot;<span class="hljs-comment">; Description: &quot;Compact installation&quot;</span>
Name: &quot;c&quot;<span class="hljs-comment">; Description: &quot;Custom installation&quot;; Flags: iscustom</span></code></pre><h2 id="[Components]">[Components]<a name="[Components]" class="headerlink" href="#[Components]"></a></h2><p>前文已有介绍，这里只说明与 <code>[Types]</code> 配合的使用：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Components]</span>
Name: &quot;c1&quot;<span class="hljs-comment">; Description: &quot;c1&quot;; Types: a b c; Flags: fixed</span>
Name: &quot;c2&quot;<span class="hljs-comment">; Description: &quot;c2&quot;; Types: a b</span>
Name: &quot;c3&quot;<span class="hljs-comment">; Description: &quot;c3&quot;; Types: a</span></code></pre><p>因为定义了 <code>[Types]</code>，组件选择时会有三个选项，分别是 <code>Full installation</code>、<code>Compact installation</code> 和 <code>Custom installation</code>：</p>
<ul>
<li>选择 <code>Full installation</code> 会自动勾上 <code>c1</code>、<code>c2</code> 和 <code>c3</code></li>
<li>选择 <code>Compact installation</code> 会自动勾上 <code>c1</code> 和 <code>c2</code></li>
<li>若用户选择 <code>Custom installation</code>，则可以手动勾选 <code>c2</code> 和 <code>c3</code></li>
<li><code>c1</code> 指定了 fixed，因此用户无法手动修改该选项</li>
</ul>
<h2 id="[Dirs]">[Dirs]<a name="[Dirs]" class="headerlink" href="#[Dirs]"></a></h2><p><code>[Dirs]</code> 定义了除用户选择的应用程序目录（自动创建）之外，安装程序需要创建的其他目录。在主应用程序目录下创建子目录是该 Section 常见的使用方式。</p>
<p>请注意，在使用 [Files] 部分安装文件时，不必显式地创建目录，因此该 Section 主要用于创建空目录。</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Dirs]</span>
Name: &quot;{app}\data&quot;
Name: &quot;{app}\bin&quot;</code></pre><h2 id="[Files]">[Files]<a name="[Files]" class="headerlink" href="#[Files]"></a></h2><p>该 Section 定义了安装程序需要安装的文件。换句话说，就是将定义的 Source 文件打包到安装程序中，安装的时候根据配置分别解压到特定目录。</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Files]</span>
Source: &quot;README.TXT&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; Flags: isreadme</span>
<span class="hljs-comment">; 支持通配符</span>
Source: &quot;subdir\*&quot;<span class="hljs-comment">; DestDir: &quot;{app}\subdir&quot;; Flags: isreadme</span></code></pre><h2 id="[Icons]">[Icons]<a name="[Icons]" class="headerlink" href="#[Icons]"></a></h2><p>该 Section 定义了安装程序如何在开始菜单或其他位置（如桌面）创建快捷方式。</p>
<blockquote>
<p>myapp.exe 是最终的可执行程序，也可以使用 Inno 自带的 demo 程序：<code>Inno 安装目录\Examples\MyProg.exe</code>。</p>
</blockquote>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Icons]</span>
<span class="hljs-comment">; 创建桌面快捷方式</span>
Name: &quot;{group}\My Program&quot;<span class="hljs-comment">; Filename: &quot;{app}\myapp.exe&quot;; WorkingDir: &quot;{app}&quot;</span></code></pre><h2 id="[Registry]">[Registry]<a name="[Registry]" class="headerlink" href="#[Registry]"></a></h2><p>该 Section 定义了安装程序如何在注册表中创建、修改或删除键/值。</p>
<blockquote>
<p>默认情况下，安装程序创建的注册表键和值在卸载时不会被删除。如果希望卸载程序的同时删除键或值，则 Flags 中须至少包含 uninsdelete、uninsdeletekeyifempty、uninsdeletevalue 中的一个。</p>
</blockquote>
<p>下面是注册伪协议的例子，可通过在浏览器中输入 <code>myapp://</code> 来打开应用程序：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Registry]</span>
Root: HKCR<span class="hljs-comment">; SubKey: Myapp; ValueData: &quot;MyappProtocol&quot;; ValueType: string; Flags: createvalueifdoesntexist uninsdeletekey noerror;</span>
Root: HKCR<span class="hljs-comment">; SubKey: Myapp; ValueName: &quot;URL Protocol&quot;; ValueData: &quot;{app}\myapp.exe&quot;; ValueType: string; Flags: createvalueifdoesntexist uninsdeletekey noerror;</span>
Root: HKCR<span class="hljs-comment">; SubKey: Myapp\DefaultIcon; ValueData: &quot;{app}\myapp.exe&quot;; ValueType: string; Flags: createvalueifdoesntexist uninsdeletekey noerror;</span>
Root: HKCR<span class="hljs-comment">; SubKey: Myapp\shell\open\command; ValueData: &quot;{app}\myapp.exe --open-url=&quot;&quot;%1&quot;&quot;&quot;; Flags: uninsdeletekey noerror; ValueType: string;</span></code></pre><p>Flags 说明：</p>
<ul>
<li>createvalueifdoesntexist：注册表中不存在时才创建相应条目</li>
<li>uninsdeletekey：卸载时删除该键</li>
<li>noerror：不展示注册表键或值设置失败的信息</li>
</ul>
<blockquote>
<p>官方不建议直接操作注册表 HKCR，而是使用 <code>HKA\Software\Classes</code> 作为替代。理由暂时不清楚，同时注册表的相关知识也只了解了零星半点，边学边搞吧。</p>
</blockquote>
<h2 id="[Run] &amp; [UninstallRun]">[Run] &amp; [UninstallRun]<a name="[Run] &amp; [UninstallRun]" class="headerlink" href="#[Run] &amp; [UninstallRun]"></a></h2><ul>
<li><code>[Run]</code> 定义了在安装完成之后需要执行的程序</li>
<li><code>[UninstallRun]</code> 定义了在卸载第一步需要执行的程序</li>
</ul>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Run]</span>
<span class="hljs-comment">; 安装完成最后一步，关闭安装向导后是否允许 myapp.exe</span>
Filename: &quot;{app}\myapp.exe&quot;<span class="hljs-comment">; Description: &quot;Run myapp&quot;; Flags: nowait postinstall skipifsilent</span></code></pre><h1 id="Pascal 脚本">Pascal 脚本<a name="Pascal 脚本" class="headerlink" href="#Pascal 脚本"></a></h1><p>除了上面看起来像是”配置式”的内容，Inno 还支持添加脚本（语法为 <a href="https://zh.wikipedia.org/zh-sg/Object_Pascal">Object Pascal</a>）以实现自定义的逻辑，具有更多的创造性，比如：</p>
<ul>
<li>支持在自定义条件下中止安装或卸载</li>
<li>支持在运行时添加自定义引导页面</li>
<li>支持在安装之前、期间或之后通过 Pascal 脚本来提取、调用 DLL 或其他文件</li>
<li>支持编写常量，这些常量可以执行普通常量、从注册表读取、从 ini 读取和从命令行读取等操作</li>
<li>支持在运行时根据自定义条件删除 <code>[Types]</code>、<code>[Components]</code> 或 <code>[Tasks]</code></li>
<li>基于自定义条件，支持有条件地安装 <code>[Files]</code>、<code>[Registry]</code>、<code>[Run]</code> 等条目</li>
<li>提供了大量辅助函数，可通过 Pascal 脚本完成 Inno Setup 所能做到的几乎所有事情</li>
</ul>
<blockquote>
<p>注意：从这里开始，若无特殊说明，脚本特指 <code>[Code]</code> 中的 Pascal 脚本，脚本仅在运行时执行，因此不能干涉 iss 本身的编译</p>
</blockquote>
<h2 id="[Code]">[Code]<a name="[Code]" class="headerlink" href="#[Code]"></a></h2><p>所有脚本内容的定义需要位于该 Section。</p>
<h3 id="事件函数">事件函数<a name="事件函数" class="headerlink" href="#事件函数"></a></h3><p>可以在 <code>[Code]</code> 定义事件回调函数，在适当的时机会被执行，例：</p>
<pre class="hljs language-pascal" hljs-language="pascal"><code style="display:block;">[Code]
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InitializeSetup</span><span class="hljs-params">()</span>:</span> Boolean;
  <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (Msgbox(<span class="hljs-string">&#x27;是否继续安装&#x27;</span>, mbConfirmation, MB_YESNO) = IDYES) <span class="hljs-keyword">then</span>
      Result := True
    <span class="hljs-keyword">else</span>
      Result := False
    <span class="hljs-keyword">end</span>;
  <span class="hljs-keyword">end</span>.</code></pre><p>定义事件函数 InitializeSetup，该函数会在安装初始化的时候被调用，返回值为 Boolean，如果返回 True 则继续安装，否则中止安装。上面的例子中，在初始化过程中加入了“弹出确认框”的逻辑，询问用户是否继续安装。</p>
<p>通常情况下，同一个事件只能定义一个回调函数的实现。但使用事件属性（Event Attributes）可以在脚本中拥有同一事件函数的多个实现。这在包含了实现事件函数的外部脚本中特别有用，以避免与主要脚本发生冲突。</p>
<p>以下是一个示例脚本，其中包含三个 InitializeWizard 事件函数的实现，每次触发会弹一个提示框，一共会弹三次：</p>
<pre class="hljs language-pascal" hljs-language="pascal"><code style="display:block;"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">InitializeWizard</span>;</span>
<span class="hljs-keyword">begin</span>
  SuppressibleMsgBox(<span class="hljs-string">&#x27;InitializeWizard called 1&#x27;</span>, mbInformation, MB_OK, IDOK);
<span class="hljs-keyword">end</span>;

&lt;event(<span class="hljs-string">&#x27;InitializeWizard&#x27;</span>)&gt;
<span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">InitializeWizard2</span>;</span>
<span class="hljs-keyword">begin</span>
  SuppressibleMsgBox(<span class="hljs-string">&#x27;InitializeWizard called 2&#x27;</span>, mbInformation, MB_OK, IDOK);
<span class="hljs-keyword">end</span>;

&lt;event(<span class="hljs-string">&#x27;InitializeWizard&#x27;</span>)&gt;
<span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">InitializeWizard3</span>;</span>
<span class="hljs-keyword">begin</span>
  SuppressibleMsgBox(<span class="hljs-string">&#x27;InitializeWizard called 3&#x27;</span>, mbInformation, MB_OK, IDOK);
<span class="hljs-keyword">end</span>;</code></pre><p>注意到，第二个定义需要使用了 <code>procedure</code> 关键字，而不是 <code>function</code>，两者都是子程序，但又有区别，简单来说：</p>
<ul>
<li><code>procedure</code> 表示过程，不会直接返回值</li>
<li><code>function</code> 是函数，返回单个值</li>
</ul>
<h3 id="脚本常量">脚本常量<a name="脚本常量" class="headerlink" href="#脚本常量"></a></h3><p>这个例子演示了如何在脚本中使用常量，同时脚本中定义的函数也可以在其他地方使用，比如：</p>
<pre class="hljs language-pascal" hljs-language="pascal"><code style="display:block;">[Setup]
DefaultDirName=&quot;<span class="hljs-comment">{code:MyConst}</span>&quot;

[Code]
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyConst</span><span class="hljs-params">(Param: <span class="hljs-keyword">String</span>)</span>:</span> <span class="hljs-keyword">String</span>;
<span class="hljs-keyword">begin</span>
  Result := ExpandConstant(<span class="hljs-string">&#x27;{userdesktop}&#x27;</span>) + <span class="hljs-string">&#x27;/appdest&#x27;</span>;
<span class="hljs-keyword">end</span>;</code></pre><p>注意，<code>MyConst</code> 函数必须要定义一个参数。</p>
<p>同时，Inno <a href="https://jrsoftware.org/ishelp/topic_scriptfunctions.htm">内置了许多函数</a>可以被直接使用：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[INI]</span>
<span class="hljs-comment">; GetShortName</span>
FileName: &quot;{app}\MyIni.ini&quot;<span class="hljs-comment">; Section: &quot;MySettings&quot;; Key: &quot;ShortApp&quot;; String: &quot;{code:GetShortName|{app}}&quot;</span></code></pre><h3 id="Check 参数">Check 参数<a name="Check 参数" class="headerlink" href="#Check 参数"></a></h3><p>所有参数形式的 Section 都支持 <code>Check</code> 参数，可以在程序过程中根据条件决定是否生效，比如：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Files]</span>
Source: &quot;MYPROG.EXE&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; Check: MyProgCheck</span>
Source: &quot;A\MYFILE.TXT&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; Check: MyDirCheck(ExpandConstant(&#x27;{app}\A&#x27;))</span>
Source: &quot;B\MYFILE.TXT&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; Check: DirExists(ExpandConstant(&#x27;{app}\B&#x27;))</span>

<span class="hljs-section">[Code]</span>
var
  MyProgChecked: Boolean<span class="hljs-comment">;</span>
  MyProgCheckResult: Boolean<span class="hljs-comment">;</span>

function MyProgCheck(): Boolean<span class="hljs-comment">;</span>
begin
  if not MyProgChecked then begin
    MyProgCheckResult := MsgBox(&#x27;Do you want to install MyProg.exe to &#x27; + ExtractFilePath(CurrentFileName) + &#x27;?&#x27;, mbConfirmation, MB_YESNO) = idYes<span class="hljs-comment">;</span>
    MyProgChecked := True<span class="hljs-comment">;</span>
  end<span class="hljs-comment">;</span>
  Result := MyProgCheckResult<span class="hljs-comment">;</span>
end<span class="hljs-comment">;</span>

function MyDirCheck(DirName: String): Boolean<span class="hljs-comment">;</span>
begin
  Result := DirExists(DirName)<span class="hljs-comment">;</span>
end<span class="hljs-comment">;</span></code></pre><p>注意：</p>
<ul>
<li><code>[Files]</code> 中的条目如果包含通配符，<code>Check</code> 会对每一个文件都执行一次，而不是整个条目</li>
</ul>
<h3 id="BeforeInstall &amp; AfterInstall 参数">BeforeInstall &amp; AfterInstall 参数<a name="BeforeInstall &amp; AfterInstall 参数" class="headerlink" href="#BeforeInstall &amp; AfterInstall 参数"></a></h3><p>所有参数形式的 Section 也都支持 <code>BeforeInstall</code> 和 <code>AfterInstall</code>，分别是在条目安装之前、之后执行：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Files]</span>
Source: &quot;MYPROG.EXE&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; BeforeInstall: MyBeforeInstall</span>
Source: &quot;A\MYFILE.TXT&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; BeforeInstall: MyBeforeInstall2(&#x27;{app}\A\MYFILE.TXT&#x27;)</span>
Source: &quot;B\MYFILE.TXT&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; BeforeInstall: MyBeforeInstall2(&#x27;{app}\B\MYFILE.TXT&#x27;)</span>
Source: &quot;MYPROG.CHM&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; BeforeInstall: Log(&#x27;Before MYPROG.CHM Install&#x27;)</span>

Source: &quot;MYPROG.EXE&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; AfterInstall: MyAfterInstall</span>
Source: &quot;A\MYFILE.TXT&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; AfterInstall: MyAfterInstall2(&#x27;{app}\A\MYFILE.TXT&#x27;)</span>
Source: &quot;B\MYFILE.TXT&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; AfterInstall: MyAfterInstall2(&#x27;{app}\B\MYFILE.TXT&#x27;)</span>
Source: &quot;MYPROG.CHM&quot;<span class="hljs-comment">; DestDir: &quot;{app}&quot;; AfterInstall: Log(&#x27;After MYPROG.CHM Install&#x27;)</span>

<span class="hljs-section">[Code]</span>
procedure MyBeforeInstall()<span class="hljs-comment">;</span>
begin
  MsgBox(&#x27;About to install MyProg.exe as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class="hljs-comment">;</span>
end<span class="hljs-comment">;</span>

procedure MyBeforeInstall2(FileName: String)<span class="hljs-comment">;</span>
begin
  MsgBox(&#x27;About to install &#x27; + FileName + &#x27; as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class="hljs-comment">;</span>
end<span class="hljs-comment">;</span>

procedure MyAfterInstall()<span class="hljs-comment">;</span>
begin
  MsgBox(&#x27;Just installed MyProg.exe as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class="hljs-comment">;</span>
end<span class="hljs-comment">;</span>

procedure MyAfterInstall2(FileName: String)<span class="hljs-comment">;</span>
begin
  MsgBox(&#x27;Just installed &#x27; + FileName + &#x27; as &#x27; + CurrentFileName + &#x27;.&#x27;, mbInformation, MB_OK)<span class="hljs-comment">;</span>
end<span class="hljs-comment">;</span></code></pre><p>注意：</p>
<ul>
<li>所有 BeforeInstall 和 AfterInstall 的函数不应该拥有返回值</li>
<li>如果安装程序已确定不应处理该条目，则不会调用 BeforeInstall 或 AfterInstall 函数</li>
<li><code>[Files]</code> 中的条目如果包含通配符，BeforeInstall 和 AfterInstall 会对每一个文件都执行一次，而不是整个条目</li>
</ul>
<h3 id="调用 DLLs 和 .Net 程序集">调用 DLLs 和 .Net 程序集<a name="调用 DLLs 和 .Net 程序集" class="headerlink" href="#调用 DLLs 和 .Net 程序集"></a></h3><p>脚本可以调用外部 DLL 中的函数，这包括标准 Windows DLL 中的标准 Win32 API 函数和自定义制作的 DLL 中的自定义函数。此外，还可以调用 .NET 程序集。</p>
<blockquote>
<p>先知道有这么个能力吧，实际还没用到过</p>
</blockquote>
<h3 id="使用 COM Automation Objects">使用 COM Automation Objects<a name="使用 COM Automation Objects" class="headerlink" href="#使用 COM Automation Objects"></a></h3><blockquote>
<p>这些概念属实没接触过，感觉上也是能直接调用一些系统或系统库的能力</p>
</blockquote>
<p>脚本可以通过 COM Automation 对象支持来访问 COM（也称为 OLE 或 ActiveX）方法和属性。这使得可以访问标准 Windows COM 服务器、自定义 COM 服务器、Visual Basic ActiveX DLL 和 .NET 程序集，可以通过 COM Interop 进行交互。</p>
<ul>
<li>IDispatch based COM<ul>
<li>可通过 CreateOleObject 和 GetActiveOleObject 来初始化基于 IDispatch 的 COM</li>
</ul>
</li>
<li>IUnknown based COM<ul>
<li>如果对象没有实现 IDispatch 接口，可以使用 CreateComObject 来初始化基于 IUnknown 的 COM</li>
</ul>
</li>
</ul>
<p>如下是一个通过 WinHttpRequest 发送 HTTP 请求的例子：</p>
<pre class="hljs language-ini" hljs-language="ini"><code style="display:block;"><span class="hljs-section">[Code]</span>
procedure SendHttp<span class="hljs-comment">;</span>
  begin
    WinHttpReq := CreateOleObject(&#x27;WinHttp.WinHttpRequest.5.1&#x27;)<span class="hljs-comment">;</span>
    WinHttpReq.Open(&#x27;POST&#x27;, &#x27;https://api.exapmle.com&#x27;, false)<span class="hljs-comment">;</span>
    WinHttpReq.SetRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)<span class="hljs-comment">;</span>
    WinHttpReq.Send(&#x27;{&quot;key&quot;:&quot;value&quot;}&#x27;)<span class="hljs-comment">;</span>
  end<span class="hljs-comment">;</span></code></pre><h1 id="结语">结语<a name="结语" class="headerlink" href="#结语"></a></h1><p>根据文档说明，每个 Section 逐步试验下来，基本上浅浅了解了下 Inno 的各个方面。Inno 本身不难，就是各种指令、参数、Flags 以及内置函数比较多，想要全盘熟悉、用得顺手也不容易。对于 Pascal 语言，虽然没接触过，但有编程经验学点简单的写法很轻松。</p>
<p>个人而言，最棘手的还是 Windows 平台开发相关的内容，比如注册表的修改，为什么改这个键，为什么设置这个值，这需要查询另外的资料；比如 <code>[Code]</code> 脚本中，可以调用哪些能力，这也需要额外的知识和经验，这些都是我目前未接触的领域。</p>
<p>总之，Inno 不难，以后随着实际使用再慢慢深入吧。</p>
<hr>
<p>参考资料：</p>
<ul>
<li>官方文档：<a href="https://jrsoftware.org/ishelp/">https://jrsoftware.org/ishelp/</a></li>
<li>Object Pascal：<a href="https://zh.wikipedia.org/zh-sg/Object_Pascal">https://zh.wikipedia.org/zh-sg/Object_Pascal</a></li>
<li>Pascal 教程：<a href="https://www.jc2182.com/pascal/pascal-jiaocheng.html">https://www.jc2182.com/pascal/pascal-jiaocheng.html</a></li>
</ul>
</div><div class="mt-6 has-child mt-6 mt-6" data-v-3adb2250><!--[-->☘️<!--]--></div><!----></div></div><!-- 上下篇 --><div class="blog-base-area-box px-4 py-4 my-8 flex justify-between md:px-8"><!--[--><div class="pr-3 w-0 flex-grow break-words"><!--[--><div class="text-c-secondary text-xs mb-1">上一篇 </div><div class="text-sm"><a href="/post/further-knowledge-of-ssh-and-ssh-config" class="unset">进一步认识 SSH 和 SSH config</a></div><!--]--></div><div class="text-right pl-3 w-0 flex-grow break-words"><!--[--><div class="text-c-secondary text-xs mb-1">下一篇 </div><div class="text-sm"><a href="/post/electron-file-association" class="unset">Electron 实现文件关联</a></div><!--]--></div><!--]--></div><!-- 评论 --><div id="comment" class="blog-base-area-box p-4 my-8 md:px-8"><h1 class="text-c-title text-xl block font-normal mb-5"><a href="#comment" class="unset text-c-title hover:text-c-title hover:underline"> 留言板 </a></h1><div class="utterances"></div></div><!--]--></div></div><div class="blog-base-area-box hidden md:block w-48 sticky top-6"><div style="display:none;" class="site-toc-wrap leading-6 break-all text-sm p-3"></div></div></div><div class="block mb-4 md:hidden"><div class="footer text-center text-sm" data-v-8b3f10e8><div data-v-8b3f10e8><div data-v-8b3f10e8>© 2017-2025</div></div><div class="flex items-center justify-center" data-v-8b3f10e8>By <a href="https://github.com/daief/blog/tree/master/packages/gugu" target="_blank" data-v-8b3f10e8>gugu</a>  &amp; daief - <span class="picker-wrap" data-v-7aa3923e data-v-8b3f10e8><span data-v-7aa3923e></span></span></div><!----><!----><div data-v-8b3f10e8><a href="/sitemap.xml" target="_blank" data-v-8b3f10e8>站点地图</a></div></div></div><div class="fixed z-100 right-8 bottom-14" data-v-49aec8bc><div class="blog-base-area-box action-btn opacity-0 pointer-events-none" data-v-49aec8bc><svg class="if-icon" aria-hidden="true" data-v-43154e2c data-v-49aec8bc><use xlink:href="#if-top" data-v-43154e2c></use></svg></div></div><!--]--></div>
    
  </body>
</html>
