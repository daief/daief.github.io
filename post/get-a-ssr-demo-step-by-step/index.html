<!DOCTYPE html>
<html  data-head-attrs="">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>从零搭建 SSR | daief的个人日志</title><meta property="og:title" content="从零搭建 SSR | daief的个人日志"><meta property="author" content="daief"><meta name="head:count" content="2">
<script>window.__INITIAL_STATE__={"global":{"site":{"postCount":51,"tagCount":42,"categoryCount":16,"site_pv":0,"page_pv":0,"site_uv":0},"indexPostPagination":{"current":1,"pageSize":10,"totalPages":0,"result":[]},"postDetail":{"post":{"id":"get-a-ssr-demo-step-by-step","slug":"post/get-a-ssr-demo-step-by-step","path":"/post/get-a-ssr-demo-step-by-step","title":"从零搭建 SSR","comments":true,"published":true,"date":"2019-07-02T17:10:37.000Z","updated":"","tags":[{"id":"1c16e694abe7b18f52484174b0aa3c87","name":"SSR","postCount":2,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<p>在上一季度中接触并使用了 Next.js，实践了一把 SSR。期间遇见了不少问题，详情可见：{% post_link use-summary-of-next-js-and-graphql %}。</p>\n<p>实际上是打算先写那篇文章，但这里还是来写这个了，这样能先从零开始认识 SSR。</p>\n<p>先放上 demo 地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo\">https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo</a>。</p>\n","more":"\n\n<h2 id=\"简介\">简介<a name=\"简介\" class=\"headerlink\" href=\"#简介\"></a></h2><p>简单列一下三种渲染方式：</p>\n<ul>\n<li>客户端渲染（CSR - Client-side Rendering）：常见的 SPA 应用，浏览器加载 HTML、JS 文件，接着执行脚本，构建虚拟 DOM（如 Vue、React），最后再将应用挂载到真实节点上。</li>\n<li>后端渲染：服务器收到请求时，预先进行处理，最后生成一份 HTML 返回给浏览器。</li>\n<li>同构（SSR - Server-Side Rendering）：这里将 SSR 认为是同构。同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。</li>\n</ul>\n<p>在同构应用中，写一份代码，在服务端和浏览器都会执行。我们知道（以 React 为例），React 应用中会构建出虚拟 DOM 再挂载到页面上；虚拟 DOM 是内存中的 JS 对象，得益于虚拟 DOM，Node 层也能运行 React。SSR 中 Node 层的一大作用：页面请求来临时，现在 Node 层运行 React 生成虚拟 DOM，再导出成字符串，而后注入到 HTML 返回给浏览器，这一步的同时还能够预先请求数据；浏览器接收 HTML、JS 后运行 React 应用，并能够根据服务端返回的 HTML 快速生成一颗浏览器端的树，同时进行相应的事件绑定。下面借用一张图来展现这整个流程：</p>\n<p><a href=\"http://blog.poetries.top/2018/11/18/react-ssr/?utm_source=tuicool&amp;utm_medium=referral\"><img alt=\"HTB1X2wve.uF3KVjSZK9762VtXXaQ.png\" loading=\"lazy\" title=\"HTB1X2wve.uF3KVjSZK9762VtXXaQ.png\" class=\"post-image \" src=\"https://ae01.alicdn.com/kf/HTB1X2wve.uF3KVjSZK9762VtXXaQ.png\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></a></p>\n<p>而下文将要实现的就是这样一个使用了 React 的同构应用 demo。</p>\n<h2 id=\"实现\">实现<a name=\"实现\" class=\"headerlink\" href=\"#实现\"></a></h2><p>在真正开始之前需要牢记，Node.js 和浏览器虽然都能运行 JS，但其实是要差异的。Node 层没有 DOM，没有 window，不能处理样式，一旦使用都会报错。</p>\n<p>框架选择：</p>\n<ul>\n<li>express@^4.17.1</li>\n<li>react@^16.8.0</li>\n<li>webpack@^4.35.0</li>\n<li>typescript@^3.5.0</li>\n</ul>\n<p>表面上说是一份代码会在双端执行，但实际上是有两份代码的，不过绝大部分相同。所以，从两份代码的 webpack 配置开始。</p>\n<h3 id=\"webpack 配置\">webpack 配置<a name=\"webpack 配置\" class=\"headerlink\" href=\"#webpack 配置\"></a></h3><p>简单抽离了两者的共同配置，做到项目的基本支持，能够处理 less、images、ts。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-keyword\">const</span> merge = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack-merge&quot;</span>);\n<span class=\"hljs-keyword\">const</span> nodeExternals = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack-node-externals&quot;</span>);\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MiniCssExtractPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;mini-css-extract-plugin&quot;</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ManifestPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack-manifest-plugin&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> commonCfg = {\n  <span class=\"hljs-attr\">mode</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">NODE_ENV</span>,\n  <span class=\"hljs-attr\">context</span>: process.<span class=\"hljs-title function_\">cwd</span>(),\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;[name].js&quot;</span>\n  },\n  <span class=\"hljs-attr\">resolve</span>: {\n    <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-string\">&quot;.js&quot;</span>, <span class=\"hljs-string\">&quot;.json&quot;</span>, <span class=\"hljs-string\">&quot;.ts&quot;</span>, <span class=\"hljs-string\">&quot;.tsx&quot;</span>],\n    <span class=\"hljs-attr\">alias</span>: {\n      <span class=\"hljs-string\">&quot;@&quot;</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;./src/&quot;</span>)\n    }\n  },\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n      <span class=\"hljs-comment\">// 处理 less 文件</span>\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.less$/i</span>,\n        <span class=\"hljs-attr\">use</span>: [\n          <span class=\"hljs-comment\">// 本意不想在服务端配置进行拆离的，但不加的时候，服务端 CSS modules 会有问题</span>\n          <span class=\"hljs-comment\">// 所以干脆都加上 MiniCssExtractPlugin 了</span>\n          {\n            <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-title class_\">MiniCssExtractPlugin</span>.<span class=\"hljs-property\">loader</span>\n          },\n          {\n            <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;css-loader&quot;</span>,\n            <span class=\"hljs-attr\">options</span>: {\n              <span class=\"hljs-attr\">modules</span>: {\n                <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;global&quot;</span>,\n                <span class=\"hljs-attr\">localIdentName</span>: <span class=\"hljs-string\">&quot;[local]--[hash:base64:5]&quot;</span>\n              }\n            }\n          },\n          {\n            <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;less-loader&quot;</span>,\n            <span class=\"hljs-attr\">options</span>: {\n              <span class=\"hljs-attr\">javascriptEnabled</span>: <span class=\"hljs-literal\">true</span>\n            }\n          }\n        ]\n      },\n      <span class=\"hljs-comment\">// 处理图片静态资源，这里其实可以做个优化，让 Server 只需要解析得到路径即可</span>\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(png|jpe?g|gif|webp)(\\?.*)?$/</span>,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;url-loader/&quot;</span>,\n        <span class=\"hljs-attr\">options</span>: {\n          <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">4096</span>,\n          <span class=\"hljs-attr\">fallback</span>: {\n            <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;file-loader&quot;</span>,\n            <span class=\"hljs-attr\">options</span>: {\n              <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;static/[name].[hash:8].[ext]&quot;</span>\n            }\n          }\n        }\n      },\n      <span class=\"hljs-comment\">// 解析 ts</span>\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.tsx?$/</span>,\n        <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;ts-loader&quot;</span>,\n        <span class=\"hljs-attr\">options</span>: {\n          <span class=\"hljs-attr\">happyPackMode</span>: <span class=\"hljs-literal\">true</span>\n        }\n      }\n    ]\n  },\n  <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MiniCssExtractPlugin</span>()]\n};</code></pre><p>然后来看 Server 和 Client 的配置，您会发现也十分简单，主要区分了 entry 和 output。</p>\n<p>注意 Server 端的 target 配置以及 externals。<strong>Server 代码运行于服务器，相应的依赖也都在 node_modules 当中，所以服务端部分只把自己写的部分代码打包在一起。</strong> <code>target</code> 设置为 <code>node</code> 告诉 webpack 这份代码运行于 Node.js，自动排除一些 Node 依赖；<code>externals: [nodeExternals()]</code> 的配置会排除掉所有 node_modules 的依赖。</p>\n<blockquote>\n<p>注意，如果您使用了类似 yarn workspaces 的功能，那么您需要像我这样配置 webpack-node-externals，因为该插件默认只会在同级寻找 node_modules 的目录，而在 workspaces 的情况下，node_modules 往往在根目录级别。题外话：webpack-node-externals 寻找 node_modules 的原因是预先读取第三方依赖列表，从而作为判断模块引用是否属于依赖，<a href=\"https://github.com/liady/webpack-node-externals/blob/cfa1c5b33752fb8cb72360167ae89b23816cdefe/index.js#L36\">详情参照源码</a>。</p>\n</blockquote>\n<p><code>output.libraryTarget</code> 设置为 <code>commonjs</code> 是因为服务端的结果是要被调用的，接下来会看到。</p>\n<p>Client 端需要添加一个 ManifestPlugin，来获取 Client 打包的结果，会在下文中使用到。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-keyword\">const</span> serverCfg = {\n  <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&quot;node&quot;</span>,\n  <span class=\"hljs-attr\">entry</span>: {\n    <span class=\"hljs-attr\">index</span>: <span class=\"hljs-string\">&quot;./src/server&quot;</span>\n  },\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">libraryTarget</span>: <span class=\"hljs-string\">&quot;commonjs&quot;</span>,\n    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;./distServer&quot;</span>)\n  },\n  <span class=\"hljs-attr\">externals</span>: [\n    <span class=\"hljs-comment\">// 同级寻找</span>\n    <span class=\"hljs-title function_\">nodeExternals</span>(),\n    <span class=\"hljs-comment\">// 指定到根目录寻找</span>\n    <span class=\"hljs-title function_\">nodeExternals</span>({\n      <span class=\"hljs-attr\">modulesDir</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;../../node_modules&quot;</span>)\n    })\n  ]\n};\n\n<span class=\"hljs-keyword\">const</span> clientCfg = {\n  <span class=\"hljs-attr\">entry</span>: {\n    <span class=\"hljs-attr\">index</span>: <span class=\"hljs-string\">&quot;./src/client&quot;</span>\n  },\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;./distClient&quot;</span>)\n  },\n  <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ManifestPlugin</span>()]\n};\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = [<span class=\"hljs-title function_\">merge</span>(commonCfg, serverCfg), <span class=\"hljs-title function_\">merge</span>(commonCfg, clientCfg)];</code></pre><p>一些其他的类似文章，会把服务端对样式的配置作为内联，这里的内联指 <code>CSS in JS</code>。因为这样一来服务端就不会出现引用样式文件的情况了，不过这不是一直有用的，有一章会专门说明。</p>\n<h3 id=\"添加页面路由和组件\">添加页面路由和组件<a name=\"添加页面路由和组件\" class=\"headerlink\" href=\"#添加页面路由和组件\"></a></h3><p>创建 <code>src</code> 目录及各自的入口文件 <code>src/server.tsx</code> 和 <code>src/client.tsx</code>，目录结构大概是这样的。比较简单，相信每个目录、文件的作用可以轻易猜到，不过还是附上注释。</p>\n<pre class=\"hljs language-bash\" hljs-language=\"bash\"><code style=\"display:block;\">.\n├── src\n│   ├── assets          <span class=\"hljs-comment\"># 存放静态资源</span>\n│   │   └── gift.png\n│   ├── client.tsx      <span class=\"hljs-comment\"># Client 入口文件</span>\n│   ├── global.less     <span class=\"hljs-comment\"># 全局的样式</span>\n│   ├── pages           <span class=\"hljs-comment\"># 存放页面组件</span>\n│   │   ├── About.tsx\n│   │   ├── Home.tsx\n│   │   └── home.less\n│   ├── routes.tsx      <span class=\"hljs-comment\"># 路由配置</span>\n│   ├── server.tsx      <span class=\"hljs-comment\"># Server 入口文件</span>\n│   └── store           <span class=\"hljs-comment\"># 简单的 store</span>\n│       └── index.ts\n├── tsconfig.json       <span class=\"hljs-comment\"># TS 配置文件</span>\n└── webpack.config.js   <span class=\"hljs-comment\"># webpack 配置文件</span></code></pre><p>在这里告诉需要告知您 Server 端和 Client 端的一大不同。两端的路由是截然不同的，在 Server 端，通过请求的路由找到对应的组件；在浏览器，通过地址栏中的 URL 渲染对应组件。而且，当浏览器请求到页面后，此时的路由会转交给浏览器。另外，两端最大的不同就在这里了，下面来看具体的实现。</p>\n<p>来看 <code>routes.tsx</code>，该文件配置了路由信息，这是相同的，可一笔带过。</p>\n<pre class=\"hljs language-tsx\" hljs-language=\"tsx\"><code style=\"display:block;\"><span class=\"hljs-comment\">// routes.tsx</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;@/global.less&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">About</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/pages/About&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Home</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/pages/Home&quot;</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Route</span>, <span class=\"hljs-title class_\">Switch</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Routes</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">SFC</span> = <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Switch</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Route</span> <span class=\"hljs-attr\">exact</span> <span class=\"hljs-attr\">path</span>=<span class=\"hljs-string\">&quot;/&quot;</span> <span class=\"hljs-attr\">component</span>=<span class=\"hljs-string\">{Home}</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Route</span> <span class=\"hljs-attr\">path</span>=<span class=\"hljs-string\">&quot;/about&quot;</span> <span class=\"hljs-attr\">component</span>=<span class=\"hljs-string\">{About}</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Switch</span>&gt;</span></span>\n  );\n};</code></pre><p>先来看熟悉的 Client 入口。使用 BrowserRouter 将路由包裹，并将 React 应用挂载到 div。这里使用了 <code>hydrate</code>，因为在服务端渲染的情况下能提前得到初次渲染的 HTML，而<strong>hydrate 描述的是 ReactDOM 复用 ReactDOMServer 服务端渲染的内容时尽可能保留结构，并补充事件绑定等 Client 特有内容的过程</strong>（参考 <a href=\"https://zh-hans.reactjs.org/docs/react-dom.html#hydrate\">[1]</a> <a href=\"https://www.zhihu.com/question/66068748\">[2]</a>）。</p>\n<pre class=\"hljs language-tsx\" hljs-language=\"tsx\"><code style=\"display:block;\"><span class=\"hljs-comment\">// client.tsx</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Routes</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/routes&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BrowserRouter</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ClientRender</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BrowserRouter</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Routes</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">BrowserRouter</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">hydrate</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ClientRender</span> /&gt;</span></span>, <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#root&quot;</span>));</code></pre><p>Server 端入口，整个文件导出了一个工厂函数，返回的是一个组件。注意这里没有浏览器 API，<a href=\"https://reacttraining.com/react-router/web/guides/server-rendering\">使用了 StaticRouter</a>，通过传入的 URL 来选择对应的组件。</p>\n<pre class=\"hljs language-tsx\" hljs-language=\"tsx\"><code style=\"display:block;\"><span class=\"hljs-comment\">// server.tsx</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Routes</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/routes&quot;</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">StaticRouter</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router&quot;</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ServerRender</span>(<span class=\"hljs-params\">req, context</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StaticRouter</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">{req.url}</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">{context}</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Routes</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StaticRouter</span>&gt;</span></span>\n    );\n  };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ServerRender</span>;</code></pre><p>页面组件就很常规，这里不再叙述。</p>\n<h3 id=\"添加 express\">添加 express<a name=\"添加 express\" class=\"headerlink\" href=\"#添加 express\"></a></h3><p>目前为止，项目还不能完整运行。在这一步之后，添加 express 的使用后，就能查看效果了。添加新的目录 <code>server</code> 以及脚本，目录结构会是这样。</p>\n<blockquote>\n<p>这里添加 tsconfig.json 的原因：上一级的配置用于编译整个 src/，而在 src/ 您可能用到 import() 语法，此时需要在 tsconfig.json 中配置 <code>module: exnext</code> 来支持；而 server/ 这里只使用原始 tsc 来编译，内层配置 <code>module: commonjs</code> 使 server/ 的运行免去一些麻烦。</p>\n</blockquote>\n<pre class=\"hljs language-bash\" hljs-language=\"bash\"><code style=\"display:block;\">.\n...\n├── server\n│   ├── index.ts        <span class=\"hljs-comment\"># 只要一个脚本</span>\n│   └── tsconfig.json   <span class=\"hljs-comment\"># 专门用于编译 server 代码的配置</span>\n├── src\n...\n</code></pre><p>进入 Server 端脚本正题，详情见注释。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-keyword\">import</span> express <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;express&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { resolve } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;path&quot;</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOMServer</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom/server&quot;</span>;\n<span class=\"hljs-comment\">// 引用 Server 端打包结果</span>\n<span class=\"hljs-keyword\">const</span> serverBuild = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;../distServer&quot;</span>).<span class=\"hljs-property\">default</span>;\n<span class=\"hljs-comment\">// 引用 Client manifest</span>\n<span class=\"hljs-keyword\">const</span> manifest = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;../distClient/manifest.json&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n\n<span class=\"hljs-comment\">// 将 Client 输出目录作为静态资源目录</span>\napp.<span class=\"hljs-title function_\">use</span>(express.<span class=\"hljs-title function_\">static</span>(<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;../distClient&quot;</span>)));\n\n<span class=\"hljs-comment\">// `/` `/about` 是支持 SSR 的路由</span>\napp.<span class=\"hljs-title function_\">get</span>([<span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-string\">&quot;/about&quot;</span>], <span class=\"hljs-keyword\">async</span> (req, res) =&gt; {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">context</span>: <span class=\"hljs-built_in\">any</span> = {};\n\n  <span class=\"hljs-comment\">// 已经渲染过的页面，这里不再渲染</span>\n  <span class=\"hljs-keyword\">if</span> (context.<span class=\"hljs-property\">url</span>) {\n    res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">302</span>, {\n      <span class=\"hljs-title class_\">Location</span>: context.<span class=\"hljs-property\">url</span>\n    });\n    res.<span class=\"hljs-title function_\">end</span>();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 这里模拟在 Server 端请求数据的延迟</span>\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">setTimeout</span>(_, <span class=\"hljs-number\">500</span>);\n    });\n    <span class=\"hljs-comment\">// 这里把数据先传进去了，现在没用，稍后说明</span>\n    <span class=\"hljs-title function_\">render</span>(req, res, context, { <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">10</span> });\n  }\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">req, res, ctx, data</span>) {\n  <span class=\"hljs-comment\">// 通过 renderToString 将组件转换成 HTML 字符串</span>\n  <span class=\"hljs-keyword\">const</span> contentHtml = <span class=\"hljs-title class_\">ReactDOMServer</span>.<span class=\"hljs-title function_\">renderToString</span>(\n    <span class=\"hljs-comment\">// 在服务端运行 React</span>\n    <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-title function_\">serverBuild</span>(req, ctx, data))\n  );\n\n  <span class=\"hljs-comment\">// 下面的是拼接出一个完整的 HTML 并发送给浏览器</span>\n  <span class=\"hljs-keyword\">const</span> renderLink = (): <span class=\"hljs-function\"><span class=\"hljs-params\">string</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(manifest)\n      .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> <span class=\"hljs-regexp\">/\\.css$/</span>.<span class=\"hljs-title function_\">test</span>(key))\n      .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> <span class=\"hljs-string\">`&lt;link rel=&quot;stylesheet&quot; href=&quot;<span class=\"hljs-subst\">${manifest[key]}</span>&quot;&gt;`</span>)\n      .<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\n  };\n\n  <span class=\"hljs-keyword\">const</span> renderScripts = (): <span class=\"hljs-function\"><span class=\"hljs-params\">string</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(manifest)\n      .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> <span class=\"hljs-regexp\">/\\.js$/</span>.<span class=\"hljs-title function_\">test</span>(key))\n      .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> <span class=\"hljs-string\">`&lt;script src=&quot;<span class=\"hljs-subst\">${manifest[key]}</span>&quot;&gt;&lt;/script&gt;`</span>)\n      .<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\n  };\n\n  res.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">`\n    &lt;!DOCTYPE html&gt;\n    &lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n      &lt;meta charset=&quot;UTF-8&quot;&gt;\n      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n      &lt;title&gt;Document&lt;/title&gt;\n      <span class=\"hljs-subst\">${renderLink()}</span>\n    &lt;/head&gt;\n    &lt;body&gt;\n      &lt;div id=&quot;root&quot;&gt;<span class=\"hljs-subst\">${contentHtml}</span>&lt;/div&gt;\n      &lt;script&gt;\n        window.__INIT_STORE__ = <span class=\"hljs-subst\">${<span class=\"hljs-built_in\">JSON</span>.stringify(data)}</span>\n      &lt;/script&gt;\n      <span class=\"hljs-subst\">${renderScripts()}</span>\n    &lt;/body&gt;\n    &lt;/html&gt;\n  `</span>);\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PORT</span> = <span class=\"hljs-number\">5000</span>;\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-variable constant_\">PORT</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-comment\">// tslint:disable-next-line: no-console</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`http://localhost:<span class=\"hljs-subst\">${PORT}</span>`</span>);\n});</code></pre><p>到这里基本差不多了，打开两个终端，切到 express-ssr-demo 的路径，分别执行 <code>yarn watch:web</code> &amp; <code>yarn dev:s</code>，顺利的话，在 <a href=\"http://localhost:5000\">http://localhost:5000</a> 就能看到效果，修改页面需要手动刷新一下浏览器。</p>\n<p>细心的同学在 Server 端脚本已经看到了模拟请求延迟、数据获取的部分，如果运行了 demo 也能直接看到效果了。接下来就进行这一部分的补充。</p>\n<h3 id=\"数据渲染\">数据渲染<a name=\"数据渲染\" class=\"headerlink\" href=\"#数据渲染\"></a></h3><p>Server 端脚本如上述即可，接下来只需添加状态管理、修改入口部分即可。</p>\n<p>添加状态管理，遵循简单的原则，这里直接在 hooks 的基础上模拟了一个状态管理，若使用 redux 等可自行扩展。</p>\n<p><code>createStore</code>，其实这是个 hook，使用时还请注意。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-comment\">// src/store/index.ts</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">StoreCtx</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">createContext</span>&lt;{ <span class=\"hljs-attr\">store</span>: <span class=\"hljs-built_in\">any</span>; <span class=\"hljs-attr\">dispatch</span>: <span class=\"hljs-built_in\">any</span> }&gt;(\n  <span class=\"hljs-literal\">null</span>\n);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">useStore</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">StoreCtx</span>);\n  <span class=\"hljs-keyword\">if</span> (!result) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;Cannot get a store context&quot;</span>);\n  }\n  <span class=\"hljs-keyword\">return</span> result;\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createStore</span>(<span class=\"hljs-params\">initStore</span>) {\n  <span class=\"hljs-keyword\">const</span> [store, setStore] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">useState</span>&lt;<span class=\"hljs-built_in\">any</span>&gt;(initStore);\n  <span class=\"hljs-keyword\">return</span> {\n    store,\n    <span class=\"hljs-attr\">dispatch</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">payload</span> =&gt;</span> <span class=\"hljs-title function_\">setStore</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">pre</span> =&gt;</span> ({ ...pre, ...payload }))\n  };\n}</code></pre><p>分别修改入口。</p>\n<pre class=\"hljs language-tsx\" hljs-language=\"tsx\"><code style=\"display:block;\"><span class=\"hljs-comment\">// src/server.tsx</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Routes</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/routes&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { createStore, <span class=\"hljs-title class_\">StoreCtx</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/store&quot;</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">StaticRouter</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router&quot;</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ServerRender</span>(<span class=\"hljs-params\">req, context, initStore</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// hook 要在这、函数组件内部调用</span>\n    <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title function_\">createStore</span>(initStore);\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StoreCtx.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{value}</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StaticRouter</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">{req.url}</span> <span class=\"hljs-attr\">context</span>=<span class=\"hljs-string\">{context}</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Routes</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StaticRouter</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StoreCtx.Provider</span>&gt;</span></span>\n    );\n  };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ServerRender</span>;</code></pre><pre class=\"hljs language-tsx\" hljs-language=\"tsx\"><code style=\"display:block;\"><span class=\"hljs-comment\">// src/client.tsx</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Routes</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/routes&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { createStore, <span class=\"hljs-title class_\">StoreCtx</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/store&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BrowserRouter</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;\n\n<span class=\"hljs-comment\">// @ts-ignore 这里是浏览器获取初始数据的地方</span>\n<span class=\"hljs-keyword\">const</span> initStore = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">__INIT_STORE__</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ClientRender</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title function_\">createStore</span>(initStore);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StoreCtx.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{value}</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BrowserRouter</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Routes</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">BrowserRouter</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StoreCtx.Provider</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">hydrate</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ClientRender</span> /&gt;</span></span>, <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#root&quot;</span>));</code></pre><p>组件内的使用，也十分简单，比如。</p>\n<pre class=\"hljs language-tsx\" hljs-language=\"tsx\"><code style=\"display:block;\"><span class=\"hljs-comment\">// src/pages/Home.tsx</span>\n<span class=\"hljs-keyword\">import</span> { useStore } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/store&quot;</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./home.less&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Home</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">SFC</span>&lt;{}&gt; = <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> { store, dispatch } = <span class=\"hljs-title function_\">useStore</span>();\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{styles.home}</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> dispatch({ count: store.count + 1 })}&gt;\n        click to add:\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span>\n      {store.count}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;</code></pre><h2 id=\"样式问题\">样式问题<a name=\"样式问题\" class=\"headerlink\" href=\"#样式问题\"></a></h2><p>Client 端没问题，这里只针对 Server 端。</p>\n<p>上文有提到会把样式文件内联的处理，因为如此一来 Server 端就不会出现引用样式的情况。但是这只对自己项目下的那部分样式。来仔细分析一下 Server 端的打包结果（distServer 是 Server 端打包的输出目录）。</p>\n<ul>\n<li>distServer/<ul>\n<li>pages/home</li>\n<li>pages/about</li>\n<li>global.less</li>\n<li>store</li>\n<li>...</li>\n</ul>\n</li>\n<li>依赖部分（node_modules）<ul>\n<li>react</li>\n<li>react-dom</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n<p>在 distServer 只会包含 src/ 的部分，因为在 webpack 明确排除了所有依赖。这一部分中的样式无论是内联还是如上文所述的拆离，都能正常使用。</p>\n<ul>\n<li>样式内联的情况，没有 <code>require less</code> 的情况</li>\n<li>样式拆离后，代码中也没有引用样式（因为这种情况往往在 Client，是需要在 HTML 额外使用 link 引入的）</li>\n</ul>\n<p>这时候添加一些组件库，比如 antd，引入组件和样式。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Button</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;antd&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;antd/dist/antd.less&quot;</span>;\n\n<span class=\"hljs-comment\">// 或</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Button</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;antd/lib/button&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;antd/lib/button/style&quot;</span>;</code></pre><p>一跑就报错了，无论内联还是拆离，都出现了 <code>require less</code> 的情况。打包结果会是这样的。当 Server 端脚本运行、执行 <code>require(&#39;../distServer&#39;)</code> 时，就发生了在 Node 层直接引用 less 的情况，接着就直接报错了。</p>\n<ul>\n<li>distServer/<ul>\n<li>...</li>\n</ul>\n</li>\n<li>依赖部分（node_modules）<ul>\n<li>antd/dist/antd.less</li>\n<li>antd/lib/button/style<ul>\n<li>index.less</li>\n<li>...</li>\n</ul>\n</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n<p>这时候去搜索解决方案时，会看到有这样的措施。这样的方案很简单，也很有效，这告诉 require 如何去处理样式文件，这里直接返回一个空的对象。这么一来 Node.js 直接引用样式文件也是 OK 的，因为对于 Node 层来讲样式文件的内容并不重要，只是因为 Client 引用了、因为我们运行同一份代码才导致我也引用了，只有不破坏依赖关系即可。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// 只需将如下代码添加到 Node.js 脚本执行的前面</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">require</span> !== <span class=\"hljs-string\">&quot;undefined&quot;</span>) {\n  <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-property\">extensions</span>[<span class=\"hljs-string\">&quot;.css&quot;</span>] = <span class=\"hljs-function\"><span class=\"hljs-params\">file</span> =&gt;</span> {};\n  <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-property\">extensions</span>[<span class=\"hljs-string\">&quot;.less&quot;</span>] = <span class=\"hljs-function\"><span class=\"hljs-params\">file</span> =&gt;</span> {};\n}</code></pre><p>细心的同学可能发现了，上面指的样式文件内容不重要，那是因为这样使用的，如果是 <code>CSS modules</code> 会怎么样呢。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// 不关心样式内容的引用</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;antd/dist/antd.less&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;antd/lib/button/style&quot;</span>;\n\n<span class=\"hljs-comment\">// CSS modules 开启</span>\n<span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./module.less&quot;</span>;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(styles.<span class=\"hljs-property\">classNameA</span>);</code></pre><p>这一点倒是不用担心，观察 <code>distServer/index.js</code> 可以发现，模块已经被替换成了对象（{&quot;home&quot;:&quot;home--1AXZn&quot;}）。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">/***/</span> <span class=\"hljs-string\">&quot;./src/pages/home.less&quot;</span>:\n<span class=\"hljs-comment\">/*!*****************************!*\\\n  !*** ./src/pages/home.less ***!\n  \\*****************************/</span>\n<span class=\"hljs-comment\">/*! no static exports found */</span>\n<span class=\"hljs-comment\">/***/</span> (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">module</span>, <span class=\"hljs-built_in\">exports</span>, __webpack_require__</span>) {\n\n<span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">&quot;// extracted by mini-css-extract-plugin\\nmodule.exports = {\\&quot;home\\&quot;:\\&quot;home--1AXZn\\&quot;};\\n\\n//# sourceURL=webpack:///./src/pages/home.less?&quot;</span>);\n\n<span class=\"hljs-comment\">/***/</span> }),</code></pre><p><code>require.extensions</code> 虽然好用，但我还是遇见了为难的地方，在使用 <code>next export</code>（Next.js 框架的一个命令） 的时候。所幸，这时候遇见了<a href=\"https://github.com/zeit/next.js/blob/e00a2c5d64def08fc5c18c5262bfb52da7c87093/examples/with-ant-design/next.config.js#L11\">新的方案</a>，再加上 <code>require.extensions</code> 已经不再推荐使用，所以 demo 里也替换成了最终方案。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// 修改 Server 的 webpack 配置，如下</span>\n<span class=\"hljs-keyword\">const</span> antStyles = <span class=\"hljs-regexp\">/antd\\/.*?\\/style.*?/</span>;\n\n<span class=\"hljs-keyword\">const</span> serverCfg = {\n  <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;node&#x27;</span>,\n  <span class=\"hljs-attr\">entry</span>: {\n    <span class=\"hljs-attr\">index</span>: <span class=\"hljs-string\">&#x27;./src/server&#x27;</span>,\n  },\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">libraryTarget</span>: <span class=\"hljs-string\">&#x27;commonjs&#x27;</span>,\n    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;./distServer&#x27;</span>),\n  },\n  <span class=\"hljs-attr\">externals</span>: [\n    <span class=\"hljs-comment\">// 关键是这里，对应的样式不要排除，要交给后续的 loader 处理</span>\n    <span class=\"hljs-comment\">// 因为一旦排除就被放到 node_modules 里去了</span>\n    <span class=\"hljs-title function_\">nodeExternals</span>({\n      <span class=\"hljs-attr\">whitelist</span>: [antStyles],\n    }),\n    <span class=\"hljs-title function_\">nodeExternals</span>({\n      <span class=\"hljs-attr\">modulesDir</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;../../node_modules&#x27;</span>),\n      <span class=\"hljs-attr\">whitelist</span>: [antStyles],\n    }),\n  ],\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n      {\n        <span class=\"hljs-comment\">// null-loader 的作用是将一个模块静默化，可以看作会把每个作用的模块变成一个空文件再给其他文件去引用</span>\n        <span class=\"hljs-comment\">// 这里的 null-loader 其实不必要</span>\n        <span class=\"hljs-comment\">// 如果加了，需要注意匹配的范围</span>\n        <span class=\"hljs-comment\">// 如果不加只是样式文件会被后面的 loader 处理而已</span>\n        <span class=\"hljs-attr\">test</span>: antStyles,\n        <span class=\"hljs-attr\">use</span>: <span class=\"hljs-string\">&#x27;null-loader&#x27;</span>,\n        <span class=\"hljs-attr\">enforce</span>: <span class=\"hljs-string\">&#x27;pre&#x27;</span>,\n      },\n    ],\n  },\n};\n</code></pre><p>以上，就是我使用以来对样式文件的纠结。</p>\n<h2 id=\"结语\">结语<a name=\"结语\" class=\"headerlink\" href=\"#结语\"></a></h2><p>终于到了结束的时候，好久没扯这么长的皮了（字数不够、代码来凑），文中好多“后续、后文再讲”，不知道对读者来说是什么感受，还请见谅。</p>\n<p>现在看来 Server 端的依赖不打包，才扯出来这一套套的（指样式文件）；因为是 Server 端，不打包有它的道理，但如果 Server 端直接打包又如何呢？</p>\n<p>别当真，如果真尝试了请记得把 React 设置为 external。</p>\n<p>在这里十分感谢杰哥给我的耐心讲解，十分感谢点进此文的你！</p>\n<p>谨以此文帮助我们对 SSR 能有更好的理解。</p>\n<p>最后再放一遍 demo 地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo\">https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo</a>。</p>\n<p>完。</p>\n<hr>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5bc7ea48e51d450e46289eab\">React 中同构（SSR）原理脉络梳理</a></li>\n<li><a href=\"http://blog.poetries.top/2018/11/18/react-ssr/?utm_source=tuicool&amp;utm_medium=referral\">从零到一搭建 React SSR 工程架构(一)</a></li>\n</ul>\n","hash":"fa0d0cba2d5d35f73989221cb638cf4c","isArticle":true,"sort":0,"filename":"","raw":"","prev":{"id":"getting-started-with-docker","slug":"post/getting-started-with-docker","path":"/post/getting-started-with-docker","title":"Docker 入门笔记","comments":true,"published":true,"date":"2019-07-01T19:52:55.000Z","updated":"","tags":[{"id":"c5fd214cdd0d2b3b4272e73b022ba5c2","name":"Docker","postCount":1,"postIds":[]}],"categories":[{"id":"407432c641358300c37673ae96305f3a","name":"DevOps","slug":"categories/DevOps","path":"/categories/DevOps","parentId":"","postCount":1,"postIds":[]},{"id":"c5fd214cdd0d2b3b4272e73b022ba5c2","name":"Docker","slug":"categories/Docker","path":"/categories/Docker","parentId":"407432c641358300c37673ae96305f3a","postCount":1,"postIds":[]}],"excerpt":"<p>本文是学习 Docker 时的初学者记录，内容是关于 Docker 基本命令的使用。如果您对此已经熟悉，大可略过本文。</p>\n","more":"","hash":"a5f38dde31551ed59427987a0920095f","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""},"next":{"id":"use-summary-of-next-js-and-graphql","slug":"post/use-summary-of-next-js-and-graphql","path":"/post/use-summary-of-next-js-and-graphql","title":"Next.js、GraphQL 使用小结","comments":true,"published":true,"date":"2019-07-03T19:11:51.000Z","updated":"","tags":[{"id":"1c16e694abe7b18f52484174b0aa3c87","name":"SSR","postCount":2,"postIds":[]},{"id":"524de3d2ade4544176f60702b36fbfdf","name":"GraphQL","postCount":1,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<p>近段时间里使用 <a href=\"https://github.com/zeit/next.js\">Next.js</a> 搭建了两个后台，同时还使用了 GraphQL。期间匆匆忙忙，而且项目都是另一个前端老哥搭建的。所以，自己又抽空从头开始搭建了几个 demo，回顾一下知识，同时整理了一下当时遇见的问题、梳理下其中缘由。</p>\n<p>本文主要内容包括三个 demo 的介绍，并记录一些在开发过程中遇到的问题和解决，本文对应 Next.js 版本为 <del>v8.0.3</del>。写的时候发现 Next.js 升级到 v9.0.0 了，自带 TypeScript 支持了，果断把 demo 的版本也升级了。</p>\n<p>上一篇文章（《{% post_link get-a-ssr-demo-step-by-step %}》）介绍了从零搭建 SSR 的过程，并且附带了一些问题的讲解，推荐结合阅读。</p>\n<p>那么，按照惯例就先呈上 demo 地址：<a href=\"https://github.com/daief/react-ssr\">react-ssr</a>。</p>\n","more":"","hash":"3da5ab4c3075862ff93e4ccf40d1fbbb","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""}}},"tocHtml":"","simplePages":[{"id":"41a3cc43f8af362b82fbe2aa97817528","slug":"resume","path":"/resume"},{"id":"fabb5629b694584be9ff314ab8187577","slug":"resume-v2","path":"/resume-v2"},{"id":"34787f8e18c76ce0f4c3cc680ab728ef","slug":"resume-v1","path":"/resume-v1"},{"id":"ac298b1fdf5a34ac83bb9376ccdde006","slug":"about","path":"/about"}],"simplePageDetail":{"post":null}},"labels":{"labels":[],"postPagination":{"current":1,"pageSize":10,"totalPages":0,"result":[]}}}</script>
    <script>
      if (/MSIE \d|Trident.*rv:/.test(navigator.userAgent)) {
        // redirect IE to Edge
        // This browser is no longer supported
        window.location.href = 'microsoft-edge:' + window.location.href;
        alert('请使用 Chrome/Edge/Firefox/Safari 等现代浏览器。');
        throw new Error('请使用 Chrome/Edge/Firefox/Safari 等现代浏览器。');
      }
    </script>
    <script type="module" crossorigin src="/assets/index.bf8c73c6.js"></script>
    <link rel="stylesheet" href="/assets/index.48ca4a1c.css">
  </head>
  <body  data-head-attrs="">
    <div id="app"><!--[--><div class="m-4 max-w-screen-xl flex flex-wrap md:m-6 xl:mx-auto md:flex-nowrap"><div class="w-full flex-shrink-0 self-start md:sticky md:top-6 md:w-48"><div class="blog-base-area-box py-6 mb-4"><img class="block w-24 h-24 rounded-full mx-auto" src="https://avatars.githubusercontent.com/u/19222089?v=4"><div class="mt-5 px-3 text-center"><h1 class="text-c-title font-normal"><a href="" class="unset">daief的个人日志</a></h1><p class="mt-2 text-sm text-c-secondary break-words">遇见你，遇见幸运💫</p><div class="mt-3 text-xs flex justify-center"><a href="/" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-wenzhang" data-v-43154e2c></use></svg>(51) </a><span class="mx-1 text-c-secondary">|</span><a href="/tags" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg>(42) </a><span class="mx-1 text-c-secondary">|</span><a href="/categories" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-category" data-v-43154e2c></use></svg>(16) </a></div><div class="mt-6 flex justify-center"><a to="https://github.com/daief" replace="false" href="https://github.com/daief" target="_blank" class="unset cursor-pointer"><!--[--><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-github" data-v-43154e2c></use></svg><!--]--></a><span class="mx-2"></span><a to="mailto:defeng_mail@163.com" replace="false" href="mailto:defeng_mail@163.com" target="_blank" class="unset cursor-pointer"><!--[--><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-email" data-v-43154e2c></use></svg><!--]--></a></div></div><div class="mt-6"><div class="text-center" data-v-73630894><!--[--><a href="/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>首页</a><a href="/categories/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>分类</a><a href="/tags/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>标签</a><a href="/about/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>关于</a><!--]--></div></div></div><div class="hidden md:block mt-2"><div class="footer text-center text-sm" data-v-8b3f10e8><div data-v-8b3f10e8><div data-v-8b3f10e8>© 2017-2025</div></div><div class="flex items-center justify-center" data-v-8b3f10e8>By <a href="https://github.com/daief/blog/tree/master/packages/gugu" target="_blank" data-v-8b3f10e8>gugu</a>  &amp; daief - <span class="picker-wrap" data-v-7aa3923e data-v-8b3f10e8><span data-v-7aa3923e></span></span></div><!----><!----><div data-v-8b3f10e8><a href="/sitemap.xml" target="_blank" data-v-8b3f10e8>站点地图</a></div></div></div></div><div class="w-full md:w-0 md:flex-grow md:mx-5"><div><!--[--><div class="blog-base-area-box px-4 py-8 md:px-8"><div><h1 class="text-2xl font-normal break-words">从零搭建 SSR</h1><div class="my-4 text-xs text-c-secondary"><div class="flex items-center flex-wrap"><!----><!----><div class="whitespace-nowrap"><svg class="if-icon text-c-secondary mx-1 text-c-secondary mx-1" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-calendar" data-v-43154e2c></use></svg>2019-07-02</div><!--[--><span class="mx-1">|</span><div class="whitespace-nowrap"><svg class="if-icon text-c-secondary mx-1 text-c-secondary mx-1" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-folder" data-v-43154e2c></use></svg><!--[--><!--[--><a href="/categories/前端" class="unset">前端</a><span></span><!--]--><!--]--></div><!--]--><!----></div></div><!-- content --><div class="markdown-body text-sm text-gray-800 leading-loose"><p>在上一季度中接触并使用了 Next.js，实践了一把 SSR。期间遇见了不少问题，详情可见：{% post_link use-summary-of-next-js-and-graphql %}。</p>
<p>实际上是打算先写那篇文章，但这里还是来写这个了，这样能先从零开始认识 SSR。</p>
<p>先放上 demo 地址：<a href="https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo">https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo</a>。</p>

<a id="more" class="h-0 mt-3 block"></a>


<h2 id="简介">简介<a name="简介" class="headerlink" href="#简介"></a></h2><p>简单列一下三种渲染方式：</p>
<ul>
<li>客户端渲染（CSR - Client-side Rendering）：常见的 SPA 应用，浏览器加载 HTML、JS 文件，接着执行脚本，构建虚拟 DOM（如 Vue、React），最后再将应用挂载到真实节点上。</li>
<li>后端渲染：服务器收到请求时，预先进行处理，最后生成一份 HTML 返回给浏览器。</li>
<li>同构（SSR - Server-Side Rendering）：这里将 SSR 认为是同构。同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。</li>
</ul>
<p>在同构应用中，写一份代码，在服务端和浏览器都会执行。我们知道（以 React 为例），React 应用中会构建出虚拟 DOM 再挂载到页面上；虚拟 DOM 是内存中的 JS 对象，得益于虚拟 DOM，Node 层也能运行 React。SSR 中 Node 层的一大作用：页面请求来临时，现在 Node 层运行 React 生成虚拟 DOM，再导出成字符串，而后注入到 HTML 返回给浏览器，这一步的同时还能够预先请求数据；浏览器接收 HTML、JS 后运行 React 应用，并能够根据服务端返回的 HTML 快速生成一颗浏览器端的树，同时进行相应的事件绑定。下面借用一张图来展现这整个流程：</p>
<p><a href="http://blog.poetries.top/2018/11/18/react-ssr/?utm_source=tuicool&amp;utm_medium=referral"><img alt="HTB1X2wve.uF3KVjSZK9762VtXXaQ.png" loading="lazy" title="HTB1X2wve.uF3KVjSZK9762VtXXaQ.png" class="post-image " src="https://ae01.alicdn.com/kf/HTB1X2wve.uF3KVjSZK9762VtXXaQ.png" onerror="this.onerror=null;this.src='/images/image-error.jpg';"></a></p>
<p>而下文将要实现的就是这样一个使用了 React 的同构应用 demo。</p>
<h2 id="实现">实现<a name="实现" class="headerlink" href="#实现"></a></h2><p>在真正开始之前需要牢记，Node.js 和浏览器虽然都能运行 JS，但其实是要差异的。Node 层没有 DOM，没有 window，不能处理样式，一旦使用都会报错。</p>
<p>框架选择：</p>
<ul>
<li>express@^4.17.1</li>
<li>react@^16.8.0</li>
<li>webpack@^4.35.0</li>
<li>typescript@^3.5.0</li>
</ul>
<p>表面上说是一份代码会在双端执行，但实际上是有两份代码的，不过绝大部分相同。所以，从两份代码的 webpack 配置开始。</p>
<h3 id="webpack 配置">webpack 配置<a name="webpack 配置" class="headerlink" href="#webpack 配置"></a></h3><p>简单抽离了两者的共同配置，做到项目的基本支持，能够处理 less、images、ts。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-merge&quot;</span>);
<span class="hljs-keyword">const</span> nodeExternals = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-node-externals&quot;</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ManifestPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-manifest-plugin&quot;</span>);

<span class="hljs-keyword">const</span> commonCfg = {
  <span class="hljs-attr">mode</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span>,
  <span class="hljs-attr">context</span>: process.<span class="hljs-title function_">cwd</span>(),
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].js&quot;</span>
  },
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>, <span class="hljs-string">&quot;.ts&quot;</span>, <span class="hljs-string">&quot;.tsx&quot;</span>],
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-string">&quot;@&quot;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./src/&quot;</span>)
    }
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      <span class="hljs-comment">// 处理 less 文件</span>
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/i</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-comment">// 本意不想在服务端配置进行拆离的，但不加的时候，服务端 CSS modules 会有问题</span>
          <span class="hljs-comment">// 所以干脆都加上 MiniCssExtractPlugin 了</span>
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>
          },
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;css-loader&quot;</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">modules</span>: {
                <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;global&quot;</span>,
                <span class="hljs-attr">localIdentName</span>: <span class="hljs-string">&quot;[local]--[hash:base64:5]&quot;</span>
              }
            }
          },
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;less-loader&quot;</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">javascriptEnabled</span>: <span class="hljs-literal">true</span>
            }
          }
        ]
      },
      <span class="hljs-comment">// 处理图片静态资源，这里其实可以做个优化，让 Server 只需要解析得到路径即可</span>
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif|webp)(\?.*)?$/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;url-loader/&quot;</span>,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">limit</span>: <span class="hljs-number">4096</span>,
          <span class="hljs-attr">fallback</span>: {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;file-loader&quot;</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;static/[name].[hash:8].[ext]&quot;</span>
            }
          }
        }
      },
      <span class="hljs-comment">// 解析 ts</span>
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.tsx?$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;ts-loader&quot;</span>,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">happyPackMode</span>: <span class="hljs-literal">true</span>
        }
      }
    ]
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()]
};</code></pre><p>然后来看 Server 和 Client 的配置，您会发现也十分简单，主要区分了 entry 和 output。</p>
<p>注意 Server 端的 target 配置以及 externals。<strong>Server 代码运行于服务器，相应的依赖也都在 node_modules 当中，所以服务端部分只把自己写的部分代码打包在一起。</strong> <code>target</code> 设置为 <code>node</code> 告诉 webpack 这份代码运行于 Node.js，自动排除一些 Node 依赖；<code>externals: [nodeExternals()]</code> 的配置会排除掉所有 node_modules 的依赖。</p>
<blockquote>
<p>注意，如果您使用了类似 yarn workspaces 的功能，那么您需要像我这样配置 webpack-node-externals，因为该插件默认只会在同级寻找 node_modules 的目录，而在 workspaces 的情况下，node_modules 往往在根目录级别。题外话：webpack-node-externals 寻找 node_modules 的原因是预先读取第三方依赖列表，从而作为判断模块引用是否属于依赖，<a href="https://github.com/liady/webpack-node-externals/blob/cfa1c5b33752fb8cb72360167ae89b23816cdefe/index.js#L36">详情参照源码</a>。</p>
</blockquote>
<p><code>output.libraryTarget</code> 设置为 <code>commonjs</code> 是因为服务端的结果是要被调用的，接下来会看到。</p>
<p>Client 端需要添加一个 ManifestPlugin，来获取 Client 打包的结果，会在下文中使用到。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-keyword">const</span> serverCfg = {
  <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;node&quot;</span>,
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">&quot;./src/server&quot;</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./distServer&quot;</span>)
  },
  <span class="hljs-attr">externals</span>: [
    <span class="hljs-comment">// 同级寻找</span>
    <span class="hljs-title function_">nodeExternals</span>(),
    <span class="hljs-comment">// 指定到根目录寻找</span>
    <span class="hljs-title function_">nodeExternals</span>({
      <span class="hljs-attr">modulesDir</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../../node_modules&quot;</span>)
    })
  ]
};

<span class="hljs-keyword">const</span> clientCfg = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">&quot;./src/client&quot;</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./distClient&quot;</span>)
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">ManifestPlugin</span>()]
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = [<span class="hljs-title function_">merge</span>(commonCfg, serverCfg), <span class="hljs-title function_">merge</span>(commonCfg, clientCfg)];</code></pre><p>一些其他的类似文章，会把服务端对样式的配置作为内联，这里的内联指 <code>CSS in JS</code>。因为这样一来服务端就不会出现引用样式文件的情况了，不过这不是一直有用的，有一章会专门说明。</p>
<h3 id="添加页面路由和组件">添加页面路由和组件<a name="添加页面路由和组件" class="headerlink" href="#添加页面路由和组件"></a></h3><p>创建 <code>src</code> 目录及各自的入口文件 <code>src/server.tsx</code> 和 <code>src/client.tsx</code>，目录结构大概是这样的。比较简单，相信每个目录、文件的作用可以轻易猜到，不过还是附上注释。</p>
<pre class="hljs language-bash" hljs-language="bash"><code style="display:block;">.
├── src
│   ├── assets          <span class="hljs-comment"># 存放静态资源</span>
│   │   └── gift.png
│   ├── client.tsx      <span class="hljs-comment"># Client 入口文件</span>
│   ├── global.less     <span class="hljs-comment"># 全局的样式</span>
│   ├── pages           <span class="hljs-comment"># 存放页面组件</span>
│   │   ├── About.tsx
│   │   ├── Home.tsx
│   │   └── home.less
│   ├── routes.tsx      <span class="hljs-comment"># 路由配置</span>
│   ├── server.tsx      <span class="hljs-comment"># Server 入口文件</span>
│   └── store           <span class="hljs-comment"># 简单的 store</span>
│       └── index.ts
├── tsconfig.json       <span class="hljs-comment"># TS 配置文件</span>
└── webpack.config.js   <span class="hljs-comment"># webpack 配置文件</span></code></pre><p>在这里告诉需要告知您 Server 端和 Client 端的一大不同。两端的路由是截然不同的，在 Server 端，通过请求的路由找到对应的组件；在浏览器，通过地址栏中的 URL 渲染对应组件。而且，当浏览器请求到页面后，此时的路由会转交给浏览器。另外，两端最大的不同就在这里了，下面来看具体的实现。</p>
<p>来看 <code>routes.tsx</code>，该文件配置了路由信息，这是相同的，可一笔带过。</p>
<pre class="hljs language-tsx" hljs-language="tsx"><code style="display:block;"><span class="hljs-comment">// routes.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@/global.less&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/pages/About&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/pages/Home&quot;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Route</span>, <span class="hljs-title class_">Switch</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Routes</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">SFC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Home}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{About}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span>
  );
};</code></pre><p>先来看熟悉的 Client 入口。使用 BrowserRouter 将路由包裹，并将 React 应用挂载到 div。这里使用了 <code>hydrate</code>，因为在服务端渲染的情况下能提前得到初次渲染的 HTML，而<strong>hydrate 描述的是 ReactDOM 复用 ReactDOMServer 服务端渲染的内容时尽可能保留结构，并补充事件绑定等 Client 特有内容的过程</strong>（参考 <a href="https://zh-hans.reactjs.org/docs/react-dom.html#hydrate">[1]</a> <a href="https://www.zhihu.com/question/66068748">[2]</a>）。</p>
<pre class="hljs language-tsx" hljs-language="tsx"><code style="display:block;"><span class="hljs-comment">// client.tsx</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Routes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/routes&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BrowserRouter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientRender</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span>
  );
}

<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">hydrate</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ClientRender</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>));</code></pre><p>Server 端入口，整个文件导出了一个工厂函数，返回的是一个组件。注意这里没有浏览器 API，<a href="https://reacttraining.com/react-router/web/guides/server-rendering">使用了 StaticRouter</a>，通过传入的 URL 来选择对应的组件。</p>
<pre class="hljs language-tsx" hljs-language="tsx"><code style="display:block;"><span class="hljs-comment">// server.tsx</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Routes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/routes&quot;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">StaticRouter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ServerRender</span>(<span class="hljs-params">req, context</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StaticRouter</span> <span class="hljs-attr">location</span>=<span class="hljs-string">{req.url}</span> <span class="hljs-attr">context</span>=<span class="hljs-string">{context}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">StaticRouter</span>&gt;</span></span>
    );
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ServerRender</span>;</code></pre><p>页面组件就很常规，这里不再叙述。</p>
<h3 id="添加 express">添加 express<a name="添加 express" class="headerlink" href="#添加 express"></a></h3><p>目前为止，项目还不能完整运行。在这一步之后，添加 express 的使用后，就能查看效果了。添加新的目录 <code>server</code> 以及脚本，目录结构会是这样。</p>
<blockquote>
<p>这里添加 tsconfig.json 的原因：上一级的配置用于编译整个 src/，而在 src/ 您可能用到 import() 语法，此时需要在 tsconfig.json 中配置 <code>module: exnext</code> 来支持；而 server/ 这里只使用原始 tsc 来编译，内层配置 <code>module: commonjs</code> 使 server/ 的运行免去一些麻烦。</p>
</blockquote>
<pre class="hljs language-bash" hljs-language="bash"><code style="display:block;">.
...
├── server
│   ├── index.ts        <span class="hljs-comment"># 只要一个脚本</span>
│   └── tsconfig.json   <span class="hljs-comment"># 专门用于编译 server 代码的配置</span>
├── src
...
</code></pre><p>进入 Server 端脚本正题，详情见注释。</p>
<pre class="hljs language-ts" hljs-language="ts"><code style="display:block;"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>;
<span class="hljs-keyword">import</span> { resolve } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOMServer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/server&quot;</span>;
<span class="hljs-comment">// 引用 Server 端打包结果</span>
<span class="hljs-keyword">const</span> serverBuild = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../distServer&quot;</span>).<span class="hljs-property">default</span>;
<span class="hljs-comment">// 引用 Client manifest</span>
<span class="hljs-keyword">const</span> manifest = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../distClient/manifest.json&quot;</span>);

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

<span class="hljs-comment">// 将 Client 输出目录作为静态资源目录</span>
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../distClient&quot;</span>)));

<span class="hljs-comment">// `/` `/about` 是支持 SSR 的路由</span>
app.<span class="hljs-title function_">get</span>([<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/about&quot;</span>], <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">context</span>: <span class="hljs-built_in">any</span> = {};

  <span class="hljs-comment">// 已经渲染过的页面，这里不再渲染</span>
  <span class="hljs-keyword">if</span> (context.<span class="hljs-property">url</span>) {
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">302</span>, {
      <span class="hljs-title class_">Location</span>: context.<span class="hljs-property">url</span>
    });
    res.<span class="hljs-title function_">end</span>();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 这里模拟在 Server 端请求数据的延迟</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
      <span class="hljs-built_in">setTimeout</span>(_, <span class="hljs-number">500</span>);
    });
    <span class="hljs-comment">// 这里把数据先传进去了，现在没用，稍后说明</span>
    <span class="hljs-title function_">render</span>(req, res, context, { <span class="hljs-attr">count</span>: <span class="hljs-number">10</span> });
  }
});

<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">req, res, ctx, data</span>) {
  <span class="hljs-comment">// 通过 renderToString 将组件转换成 HTML 字符串</span>
  <span class="hljs-keyword">const</span> contentHtml = <span class="hljs-title class_">ReactDOMServer</span>.<span class="hljs-title function_">renderToString</span>(
    <span class="hljs-comment">// 在服务端运行 React</span>
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-title function_">serverBuild</span>(req, ctx, data))
  );

  <span class="hljs-comment">// 下面的是拼接出一个完整的 HTML 并发送给浏览器</span>
  <span class="hljs-keyword">const</span> renderLink = (): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(manifest)
      .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-regexp">/\.css$/</span>.<span class="hljs-title function_">test</span>(key))
      .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-string">`&lt;link rel=&quot;stylesheet&quot; href=&quot;<span class="hljs-subst">${manifest[key]}</span>&quot;&gt;`</span>)
      .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;\n&quot;</span>);
  };

  <span class="hljs-keyword">const</span> renderScripts = (): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(manifest)
      .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-regexp">/\.js$/</span>.<span class="hljs-title function_">test</span>(key))
      .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-string">`&lt;script src=&quot;<span class="hljs-subst">${manifest[key]}</span>&quot;&gt;&lt;/script&gt;`</span>)
      .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;\n&quot;</span>);
  };

  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`
    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
      &lt;title&gt;Document&lt;/title&gt;
      <span class="hljs-subst">${renderLink()}</span>
    &lt;/head&gt;
    &lt;body&gt;
      &lt;div id=&quot;root&quot;&gt;<span class="hljs-subst">${contentHtml}</span>&lt;/div&gt;
      &lt;script&gt;
        window.__INIT_STORE__ = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(data)}</span>
      &lt;/script&gt;
      <span class="hljs-subst">${renderScripts()}</span>
    &lt;/body&gt;
    &lt;/html&gt;
  `</span>);
}

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">5000</span>;
app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// tslint:disable-next-line: no-console</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`http://localhost:<span class="hljs-subst">${PORT}</span>`</span>);
});</code></pre><p>到这里基本差不多了，打开两个终端，切到 express-ssr-demo 的路径，分别执行 <code>yarn watch:web</code> &amp; <code>yarn dev:s</code>，顺利的话，在 <a href="http://localhost:5000">http://localhost:5000</a> 就能看到效果，修改页面需要手动刷新一下浏览器。</p>
<p>细心的同学在 Server 端脚本已经看到了模拟请求延迟、数据获取的部分，如果运行了 demo 也能直接看到效果了。接下来就进行这一部分的补充。</p>
<h3 id="数据渲染">数据渲染<a name="数据渲染" class="headerlink" href="#数据渲染"></a></h3><p>Server 端脚本如上述即可，接下来只需添加状态管理、修改入口部分即可。</p>
<p>添加状态管理，遵循简单的原则，这里直接在 hooks 的基础上模拟了一个状态管理，若使用 redux 等可自行扩展。</p>
<p><code>createStore</code>，其实这是个 hook，使用时还请注意。</p>
<pre class="hljs language-ts" hljs-language="ts"><code style="display:block;"><span class="hljs-comment">// src/store/index.ts</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">StoreCtx</span> = <span class="hljs-title class_">React</span>.<span class="hljs-property">createContext</span>&lt;{ <span class="hljs-attr">store</span>: <span class="hljs-built_in">any</span>; <span class="hljs-attr">dispatch</span>: <span class="hljs-built_in">any</span> }&gt;(
  <span class="hljs-literal">null</span>
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useStore</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">StoreCtx</span>);
  <span class="hljs-keyword">if</span> (!result) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Cannot get a store context&quot;</span>);
  }
  <span class="hljs-keyword">return</span> result;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createStore</span>(<span class="hljs-params">initStore</span>) {
  <span class="hljs-keyword">const</span> [store, setStore] = <span class="hljs-title class_">React</span>.<span class="hljs-property">useState</span>&lt;<span class="hljs-built_in">any</span>&gt;(initStore);
  <span class="hljs-keyword">return</span> {
    store,
    <span class="hljs-attr">dispatch</span>: <span class="hljs-function"><span class="hljs-params">payload</span> =&gt;</span> <span class="hljs-title function_">setStore</span>(<span class="hljs-function"><span class="hljs-params">pre</span> =&gt;</span> ({ ...pre, ...payload }))
  };
}</code></pre><p>分别修改入口。</p>
<pre class="hljs language-tsx" hljs-language="tsx"><code style="display:block;"><span class="hljs-comment">// src/server.tsx</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Routes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/routes&quot;</span>;
<span class="hljs-keyword">import</span> { createStore, <span class="hljs-title class_">StoreCtx</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store&quot;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">StaticRouter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ServerRender</span>(<span class="hljs-params">req, context, initStore</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
    <span class="hljs-comment">// hook 要在这、函数组件内部调用</span>
    <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">createStore</span>(initStore);
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StoreCtx.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">StaticRouter</span> <span class="hljs-attr">location</span>=<span class="hljs-string">{req.url}</span> <span class="hljs-attr">context</span>=<span class="hljs-string">{context}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">StaticRouter</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">StoreCtx.Provider</span>&gt;</span></span>
    );
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ServerRender</span>;</code></pre><pre class="hljs language-tsx" hljs-language="tsx"><code style="display:block;"><span class="hljs-comment">// src/client.tsx</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Routes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/routes&quot;</span>;
<span class="hljs-keyword">import</span> { createStore, <span class="hljs-title class_">StoreCtx</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BrowserRouter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;

<span class="hljs-comment">// @ts-ignore 这里是浏览器获取初始数据的地方</span>
<span class="hljs-keyword">const</span> initStore = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__INIT_STORE__</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientRender</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">createStore</span>(initStore);
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StoreCtx.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">StoreCtx.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">hydrate</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ClientRender</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>));</code></pre><p>组件内的使用，也十分简单，比如。</p>
<pre class="hljs language-tsx" hljs-language="tsx"><code style="display:block;"><span class="hljs-comment">// src/pages/Home.tsx</span>
<span class="hljs-keyword">import</span> { useStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store&quot;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./home.less&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">SFC</span>&lt;{}&gt; = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> { store, dispatch } = <span class="hljs-title function_">useStore</span>();
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.home}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ count: store.count + 1 })}&gt;
        click to add:
      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
      {store.count}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span>;</code></pre><h2 id="样式问题">样式问题<a name="样式问题" class="headerlink" href="#样式问题"></a></h2><p>Client 端没问题，这里只针对 Server 端。</p>
<p>上文有提到会把样式文件内联的处理，因为如此一来 Server 端就不会出现引用样式的情况。但是这只对自己项目下的那部分样式。来仔细分析一下 Server 端的打包结果（distServer 是 Server 端打包的输出目录）。</p>
<ul>
<li>distServer/<ul>
<li>pages/home</li>
<li>pages/about</li>
<li>global.less</li>
<li>store</li>
<li>...</li>
</ul>
</li>
<li>依赖部分（node_modules）<ul>
<li>react</li>
<li>react-dom</li>
<li>...</li>
</ul>
</li>
</ul>
<p>在 distServer 只会包含 src/ 的部分，因为在 webpack 明确排除了所有依赖。这一部分中的样式无论是内联还是如上文所述的拆离，都能正常使用。</p>
<ul>
<li>样式内联的情况，没有 <code>require less</code> 的情况</li>
<li>样式拆离后，代码中也没有引用样式（因为这种情况往往在 Client，是需要在 HTML 额外使用 link 引入的）</li>
</ul>
<p>这时候添加一些组件库，比如 antd，引入组件和样式。</p>
<pre class="hljs language-ts" hljs-language="ts"><code style="display:block;"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.less&quot;</span>;

<span class="hljs-comment">// 或</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd/lib/button&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/lib/button/style&quot;</span>;</code></pre><p>一跑就报错了，无论内联还是拆离，都出现了 <code>require less</code> 的情况。打包结果会是这样的。当 Server 端脚本运行、执行 <code>require(&#39;../distServer&#39;)</code> 时，就发生了在 Node 层直接引用 less 的情况，接着就直接报错了。</p>
<ul>
<li>distServer/<ul>
<li>...</li>
</ul>
</li>
<li>依赖部分（node_modules）<ul>
<li>antd/dist/antd.less</li>
<li>antd/lib/button/style<ul>
<li>index.less</li>
<li>...</li>
</ul>
</li>
<li>...</li>
</ul>
</li>
</ul>
<p>这时候去搜索解决方案时，会看到有这样的措施。这样的方案很简单，也很有效，这告诉 require 如何去处理样式文件，这里直接返回一个空的对象。这么一来 Node.js 直接引用样式文件也是 OK 的，因为对于 Node 层来讲样式文件的内容并不重要，只是因为 Client 引用了、因为我们运行同一份代码才导致我也引用了，只有不破坏依赖关系即可。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// 只需将如下代码添加到 Node.js 脚本执行的前面</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) {
  <span class="hljs-built_in">require</span>.<span class="hljs-property">extensions</span>[<span class="hljs-string">&quot;.css&quot;</span>] = <span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> {};
  <span class="hljs-built_in">require</span>.<span class="hljs-property">extensions</span>[<span class="hljs-string">&quot;.less&quot;</span>] = <span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> {};
}</code></pre><p>细心的同学可能发现了，上面指的样式文件内容不重要，那是因为这样使用的，如果是 <code>CSS modules</code> 会怎么样呢。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// 不关心样式内容的引用</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.less&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/lib/button/style&quot;</span>;

<span class="hljs-comment">// CSS modules 开启</span>
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.less&quot;</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(styles.<span class="hljs-property">classNameA</span>);</code></pre><p>这一点倒是不用担心，观察 <code>distServer/index.js</code> 可以发现，模块已经被替换成了对象（{&quot;home&quot;:&quot;home--1AXZn&quot;}）。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">/***/</span> <span class="hljs-string">&quot;./src/pages/home.less&quot;</span>:
<span class="hljs-comment">/*!*****************************!*\
  !*** ./src/pages/home.less ***!
  \*****************************/</span>
<span class="hljs-comment">/*! no static exports found */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, __webpack_require__</span>) {

<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;// extracted by mini-css-extract-plugin\nmodule.exports = {\&quot;home\&quot;:\&quot;home--1AXZn\&quot;};\n\n//# sourceURL=webpack:///./src/pages/home.less?&quot;</span>);

<span class="hljs-comment">/***/</span> }),</code></pre><p><code>require.extensions</code> 虽然好用，但我还是遇见了为难的地方，在使用 <code>next export</code>（Next.js 框架的一个命令） 的时候。所幸，这时候遇见了<a href="https://github.com/zeit/next.js/blob/e00a2c5d64def08fc5c18c5262bfb52da7c87093/examples/with-ant-design/next.config.js#L11">新的方案</a>，再加上 <code>require.extensions</code> 已经不再推荐使用，所以 demo 里也替换成了最终方案。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// 修改 Server 的 webpack 配置，如下</span>
<span class="hljs-keyword">const</span> antStyles = <span class="hljs-regexp">/antd\/.*?\/style.*?/</span>;

<span class="hljs-keyword">const</span> serverCfg = {
  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;node&#x27;</span>,
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/server&#x27;</span>,
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">&#x27;commonjs&#x27;</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./distServer&#x27;</span>),
  },
  <span class="hljs-attr">externals</span>: [
    <span class="hljs-comment">// 关键是这里，对应的样式不要排除，要交给后续的 loader 处理</span>
    <span class="hljs-comment">// 因为一旦排除就被放到 node_modules 里去了</span>
    <span class="hljs-title function_">nodeExternals</span>({
      <span class="hljs-attr">whitelist</span>: [antStyles],
    }),
    <span class="hljs-title function_">nodeExternals</span>({
      <span class="hljs-attr">modulesDir</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;../../node_modules&#x27;</span>),
      <span class="hljs-attr">whitelist</span>: [antStyles],
    }),
  ],
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-comment">// null-loader 的作用是将一个模块静默化，可以看作会把每个作用的模块变成一个空文件再给其他文件去引用</span>
        <span class="hljs-comment">// 这里的 null-loader 其实不必要</span>
        <span class="hljs-comment">// 如果加了，需要注意匹配的范围</span>
        <span class="hljs-comment">// 如果不加只是样式文件会被后面的 loader 处理而已</span>
        <span class="hljs-attr">test</span>: antStyles,
        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;null-loader&#x27;</span>,
        <span class="hljs-attr">enforce</span>: <span class="hljs-string">&#x27;pre&#x27;</span>,
      },
    ],
  },
};
</code></pre><p>以上，就是我使用以来对样式文件的纠结。</p>
<h2 id="结语">结语<a name="结语" class="headerlink" href="#结语"></a></h2><p>终于到了结束的时候，好久没扯这么长的皮了（字数不够、代码来凑），文中好多“后续、后文再讲”，不知道对读者来说是什么感受，还请见谅。</p>
<p>现在看来 Server 端的依赖不打包，才扯出来这一套套的（指样式文件）；因为是 Server 端，不打包有它的道理，但如果 Server 端直接打包又如何呢？</p>
<p>别当真，如果真尝试了请记得把 React 设置为 external。</p>
<p>在这里十分感谢杰哥给我的耐心讲解，十分感谢点进此文的你！</p>
<p>谨以此文帮助我们对 SSR 能有更好的理解。</p>
<p>最后再放一遍 demo 地址：<a href="https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo">https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo</a>。</p>
<p>完。</p>
<hr>
<p>参考链接：</p>
<ul>
<li><a href="https://juejin.im/post/5bc7ea48e51d450e46289eab">React 中同构（SSR）原理脉络梳理</a></li>
<li><a href="http://blog.poetries.top/2018/11/18/react-ssr/?utm_source=tuicool&amp;utm_medium=referral">从零到一搭建 React SSR 工程架构(一)</a></li>
</ul>
</div><div class="mt-6 has-child mt-6 mt-6" data-v-3adb2250><!--[-->☘️<!--]--></div><div class="flex flex-wrap justify-center text-c-secondary text-sm mt-6"><!--[--><a href="/tags/SSR" class="unset block my-1 mx-2"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg> SSR</a><!--]--></div></div></div><!-- 上下篇 --><div class="blog-base-area-box px-4 py-4 my-8 flex justify-between md:px-8"><!--[--><div class="pr-3 w-0 flex-grow break-words"><!--[--><div class="text-c-secondary text-xs mb-1">上一篇 </div><div class="text-sm"><a href="/post/getting-started-with-docker" class="unset">Docker 入门笔记</a></div><!--]--></div><div class="text-right pl-3 w-0 flex-grow break-words"><!--[--><div class="text-c-secondary text-xs mb-1">下一篇 </div><div class="text-sm"><a href="/post/use-summary-of-next-js-and-graphql" class="unset">Next.js、GraphQL 使用小结</a></div><!--]--></div><!--]--></div><!-- 评论 --><div id="comment" class="blog-base-area-box p-4 my-8 md:px-8"><h1 class="text-c-title text-xl block font-normal mb-5"><a href="#comment" class="unset text-c-title hover:text-c-title hover:underline"> 留言板 </a></h1><div class="utterances"></div></div><!--]--></div></div><div class="blog-base-area-box hidden md:block w-48 sticky top-6"><div style="display:none;" class="site-toc-wrap leading-6 break-all text-sm p-3"></div></div></div><div class="block mb-4 md:hidden"><div class="footer text-center text-sm" data-v-8b3f10e8><div data-v-8b3f10e8><div data-v-8b3f10e8>© 2017-2025</div></div><div class="flex items-center justify-center" data-v-8b3f10e8>By <a href="https://github.com/daief/blog/tree/master/packages/gugu" target="_blank" data-v-8b3f10e8>gugu</a>  &amp; daief - <span class="picker-wrap" data-v-7aa3923e data-v-8b3f10e8><span data-v-7aa3923e></span></span></div><!----><!----><div data-v-8b3f10e8><a href="/sitemap.xml" target="_blank" data-v-8b3f10e8>站点地图</a></div></div></div><div class="fixed z-100 right-8 bottom-14" data-v-49aec8bc><div class="blog-base-area-box action-btn opacity-0 pointer-events-none" data-v-49aec8bc><svg class="if-icon" aria-hidden="true" data-v-43154e2c data-v-49aec8bc><use xlink:href="#if-top" data-v-43154e2c></use></svg></div></div><!--]--></div>
    
  </body>
</html>
