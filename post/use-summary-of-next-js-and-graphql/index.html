<!DOCTYPE html>
<html  data-head-attrs="">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Next.js、GraphQL 使用小结 | daief的个人日志</title><meta property="og:title" content="Next.js、GraphQL 使用小结 | daief的个人日志"><meta property="author" content="daief"><meta name="head:count" content="2">
<script>window.__INITIAL_STATE__={"global":{"site":{"postCount":51,"tagCount":42,"categoryCount":16,"site_pv":0,"page_pv":0,"site_uv":0},"indexPostPagination":{"current":1,"pageSize":10,"totalPages":0,"result":[]},"postDetail":{"post":{"id":"use-summary-of-next-js-and-graphql","slug":"post/use-summary-of-next-js-and-graphql","path":"/post/use-summary-of-next-js-and-graphql","title":"Next.js、GraphQL 使用小结","comments":true,"published":true,"date":"2019-07-03T19:11:51.000Z","updated":"","tags":[{"id":"1c16e694abe7b18f52484174b0aa3c87","name":"SSR","postCount":2,"postIds":[]},{"id":"524de3d2ade4544176f60702b36fbfdf","name":"GraphQL","postCount":1,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<p>近段时间里使用 <a href=\"https://github.com/zeit/next.js\">Next.js</a> 搭建了两个后台，同时还使用了 GraphQL。期间匆匆忙忙，而且项目都是另一个前端老哥搭建的。所以，自己又抽空从头开始搭建了几个 demo，回顾一下知识，同时整理了一下当时遇见的问题、梳理下其中缘由。</p>\n<p>本文主要内容包括三个 demo 的介绍，并记录一些在开发过程中遇到的问题和解决，本文对应 Next.js 版本为 <del>v8.0.3</del>。写的时候发现 Next.js 升级到 v9.0.0 了，自带 TypeScript 支持了，果断把 demo 的版本也升级了。</p>\n<p>上一篇文章（《{% post_link get-a-ssr-demo-step-by-step %}》）介绍了从零搭建 SSR 的过程，并且附带了一些问题的讲解，推荐结合阅读。</p>\n<p>那么，按照惯例就先呈上 demo 地址：<a href=\"https://github.com/daief/react-ssr\">react-ssr</a>。</p>\n","more":"\n\n<h1 id=\"简介\">简介<a name=\"简介\" class=\"headerlink\" href=\"#简介\"></a></h1><p>本节对三个 demo 作个简单介绍。</p>\n<p>正常运行该项目需要配置本地 hosts。</p>\n<pre class=\"hljs language-bash\" hljs-language=\"bash\"><code style=\"display:block;\"><span class=\"hljs-comment\"># hosts</span>\n<span class=\"hljs-comment\"># 模拟 gql-server 的域名</span>\n127.0.0.1            gql-server.example.com\n<span class=\"hljs-comment\"># 模拟应用 account 的域名（nextjs-ssr 或 nextjs-static）</span>\n127.0.0.1            account.example.com\n<span class=\"hljs-comment\"># 模拟应用 customer 的域名（nextjs-ssr 或 nextjs-static）</span>\n127.0.0.1            customer.example.com</code></pre><p>或者在 <code>packages/shared/CONFIG.ts</code> 文件中修改成其他域名配置，然后通过域名 + 端口的形式访问本地开发环境。</p>\n<h2 id=\"nextjs-ssr\">nextjs-ssr<a name=\"nextjs-ssr\" class=\"headerlink\" href=\"#nextjs-ssr\"></a></h2><blockquote>\n<p>地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/nextjs-ssr\">https://github.com/daief/react-ssr/tree/master/packages/nextjs-ssr</a></p>\n</blockquote>\n<p>这第一个 demo 对应业务开发中的第一个后台，该后台是一个对内的、管理各种应用的后台，其中一个功能需要实现各个应用间的<a href=\"https://en.wikipedia.org/wiki/Single_sign-on\">单点登录（SSO）</a>。</p>\n<p>Java 端基于 <a href=\"https://en.wikipedia.org/wiki/JSON_Web_Token\">JWT（Json web token）</a> 实现授权认证，前端应用在请求时需要把 token 加到请求头当中，同时也会将 token 缓存于 localStorage。</p>\n<p>这里的每个应用都有一个不同的二级域名（如 a.example.com、b.example.com），而 localStorage 由于跨域限制，前端应用之间不能共享 token，在这种情况打开新的应用时就会需要重新登录。</p>\n<p>因此，新的方案是把 token 存储在 cookie 里，并设置 Domain 为根域名（.example.com）。如此一来各个应用之间直接就共享 token，而且每个应用不再需要维护 token。</p>\n<p>因为这是一个对内的应用，同时出于对技术的追求，该项目决定试用 SSR，选型 Next.js。同时前端组表示可以用中间层来做 cookie 的维护，而 Java 端一切保持不变。加上了 Node 层之后，又顺理成章地加上了 GraphQL Server。</p>\n<h2 id=\"gql-server\">gql-server<a name=\"gql-server\" class=\"headerlink\" href=\"#gql-server\"></a></h2><blockquote>\n<p>地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/gql-server\">https://github.com/daief/react-ssr/tree/master/packages/gql-server</a></p>\n</blockquote>\n<p>这是一个独立的中间层，主要作用是提供 GraphQL 服务、cookie 管理。</p>\n<p>其实上面选择用 Next.js 做 SSR 的时候就已经添加了一个 Node 服务，但这里还是另外再起了一个服务，依我的想法出于两个原因：Next.js 服务专门负责 SSR，这边专门提供 GraphQL 服务，职责会比较清晰；两者同一个服务时，Next.js 会作为一个中间来件运作，开发调试时若修改服务端部分代码调试工具会自动重启服务，这就会导致 next 部分也重启了、而且得重新编译，很费时间。</p>\n<p>该项目基于 <a href=\"https://www.apollographql.com/docs/\">Apollo GraphQL</a> 系列搭建。</p>\n<p>nextjs-ssr + gql-server + Java 的整体运作情况如下。</p>\n<p><img alt=\"sequence-chart.jpg\" loading=\"lazy\" title=\"sequence-chart.jpg\" class=\"post-image \" src=\"/images/bf96eaf446430d6d7053f2bc6f5bc836.sequence-chart.jpg\" onerror=\"this.onerror=null;this.src='/images/image-error.jpg';\"></p>\n<h2 id=\"nextjs-static\">nextjs-static<a name=\"nextjs-static\" class=\"headerlink\" href=\"#nextjs-static\"></a></h2><blockquote>\n<p>地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/nextjs-static\">https://github.com/daief/react-ssr/tree/master/packages/nextjs-static</a></p>\n</blockquote>\n<p>该 demo 也使用 Next.js 框架，但依赖的是 Prerender 的功能，最终是静态部署，所以项目中踢除、避免 Server 端的代码。（该 demo 对应第二个后台，只是个常规的管理后台）</p>\n<p>请求部分依旧使用了 GraphQL，不过该项目没有对应的 GraphQL 服务，API 是 REST 形式的。</p>\n<p>通过 <a href=\"https://www.apollographql.com/docs/link/\">apollo-link</a>（可看作是 apollo-client 的中间件）使得 GraphQL 变得十分灵活、不仅仅是依赖于 GraphQL 服务而使用。</p>\n<blockquote>\n<p>apollo-client 是用于发起 GraphQL 请求的一种客户端框架。</p>\n</blockquote>\n<p>这里的主角是 <a href=\"https://www.apollographql.com/docs/link/links/rest/\">apollo-link-rest</a>，让我们很轻易地通过 GraphQL 调用 REST API。</p>\n<p>这样可以在前端实现接口聚合、字段查询（基于真实接口的返回）等 GraphQL 的特色功能。</p>\n<h1 id=\"Next.js 使用问题\">Next.js 使用问题<a name=\"Next.js 使用问题\" class=\"headerlink\" href=\"#Next.js 使用问题\"></a></h1><p>下面把和 Next.js 有关的问题聚合在这一节。</p>\n<h2 id=\"样式文件的处理\">样式文件的处理<a name=\"样式文件的处理\" class=\"headerlink\" href=\"#样式文件的处理\"></a></h2><p>这个应该是使用 SSR 时候的经典问题了，不过有关样式文件在 SSR 中的问题在{% post_link get-a-ssr-demo-step-by-step %}有详细解读，这里只说明该问题在 Next.js 中的具体解决以及和 Next.js 有关的注意点。</p>\n<p>这个问题主要可概括为两点：一是缺少 webpack 对于 CSS、Less 的配置；二是 SSR 项目运行的特点。</p>\n<p>添加相应的 webpack 配置，可使用官方的配置扩展插件：<a href=\"https://github.com/zeit/next-plugins/tree/master/packages/next-css\">@zeit/next-css</a>、<a href=\"https://github.com/zeit/next-plugins/tree/master/packages/next-less\">@zeit/next-less</a>，然后在 <code>next.config.js</code> 中使用：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n<span class=\"hljs-keyword\">const</span> withCSS = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;@zeit/next-css&#x27;</span>);\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-title function_\">withCSS</span>(\n  <span class=\"hljs-title function_\">withLess</span>({\n    <span class=\"hljs-comment\">/* config options here */</span>\n    <span class=\"hljs-attr\">cssModules</span>: <span class=\"hljs-comment\">/* 开启 cssModules */</span> <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">lessLoaderOptions</span>: {\n      <span class=\"hljs-attr\">javascriptEnabled</span>: <span class=\"hljs-literal\">true</span>,\n    },\n    <span class=\"hljs-attr\">cssLoaderOptions</span>: {\n      <span class=\"hljs-attr\">importLoaders</span>: <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-attr\">localIdentName</span>: <span class=\"hljs-string\">&#x27;[local]_[hash:base64:5]&#x27;</span>,\n    },\n  }),\n);</code></pre><p>如此一来，项目中就能正常引用样式文件了。</p>\n<blockquote>\n<p>坑点：引入第三方组件库如 antd 时样式依旧会报错。</p>\n</blockquote>\n<p>最为简单的方式，在 <code>next.config.js</code> 顶部添加：</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">require</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>) {\n  <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-property\">extensions</span>[<span class=\"hljs-string\">&#x27;.css&#x27;</span>] = <span class=\"hljs-function\">(<span class=\"hljs-params\">file</span>) =&gt;</span> {};\n  <span class=\"hljs-built_in\">require</span>.<span class=\"hljs-property\">extensions</span>[<span class=\"hljs-string\">&#x27;.less&#x27;</span>] = <span class=\"hljs-function\">(<span class=\"hljs-params\">file</span>) =&gt;</span> {};\n}</code></pre><blockquote>\n<p>坑点：所有的样式文件都开启了 CSS modules；打包时样式依旧报错。</p>\n</blockquote>\n<p>尝试自定义 webpack 的样式配置，简单粗暴之处在于所有（Server &amp; Client）样式都过一遍 loader。在这样的配置下，只要在需要开启 CSS modules 的地方添加 <code>:local()</code> 即可。（以下配置基于 css-loader@^3，顺便一提官方插件所用的是 css-loader@1，两者配置之间会有差异）</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// withStyle.js</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MiniCssExtractPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;mini-css-extract-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">OptimizeCSSAssetsPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">nextConfig = {}</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>({}, nextConfig, {\n    <span class=\"hljs-title function_\">webpack</span>(<span class=\"hljs-params\">config, options</span>) {\n      <span class=\"hljs-keyword\">const</span> { dev, isServer } = options;\n      <span class=\"hljs-keyword\">const</span> {\n        cssLoaderOptions,\n        postcssLoaderOptions,\n        lessLoaderOptions = {},\n      } = nextConfig;\n\n      options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">css</span> = [\n        {\n          <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-title class_\">MiniCssExtractPlugin</span>.<span class=\"hljs-property\">loader</span>,\n        },\n        {\n          <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>,\n          <span class=\"hljs-attr\">options</span>: {\n            <span class=\"hljs-attr\">sourceMap</span>: dev,\n            <span class=\"hljs-attr\">modules</span>: {\n              <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;global&#x27;</span>,\n              <span class=\"hljs-attr\">localIdentName</span>: <span class=\"hljs-string\">&#x27;[local]--[hash:base64:5]&#x27;</span>,\n            },\n            ...cssLoaderOptions,\n          },\n        },\n      ];\n\n      options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">less</span> = [\n        ...options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">css</span>,\n        {\n          <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;less-loader&#x27;</span>,\n          <span class=\"hljs-attr\">options</span>: {\n            <span class=\"hljs-attr\">javascriptEnabled</span>: <span class=\"hljs-literal\">true</span>,\n            ...lessLoaderOptions,\n          },\n        },\n      ];\n\n      config.<span class=\"hljs-property\">module</span>.<span class=\"hljs-property\">rules</span>.<span class=\"hljs-title function_\">push</span>(\n        {\n          <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n          <span class=\"hljs-attr\">use</span>: options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">css</span>,\n        },\n        {\n          <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.less$/</span>,\n          <span class=\"hljs-attr\">use</span>: options.<span class=\"hljs-property\">defaultLoaders</span>.<span class=\"hljs-property\">less</span>,\n        },\n      );\n\n      config.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-title function_\">push</span>(\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MiniCssExtractPlugin</span>({\n          <span class=\"hljs-comment\">// 要加上 static，否则打包后 404</span>\n          <span class=\"hljs-attr\">filename</span>: dev\n            ? <span class=\"hljs-string\">&#x27;static/css/[name].css&#x27;</span>\n            : <span class=\"hljs-string\">&#x27;static/css/[name].[contenthash:8].css&#x27;</span>,\n          <span class=\"hljs-attr\">chunkFilename</span>: dev\n            ? <span class=\"hljs-string\">&#x27;static/css/[name].chunk.css&#x27;</span>\n            : <span class=\"hljs-string\">&#x27;static/css/[name].[contenthash:8].chunk.css&#x27;</span>,\n        }),\n        <span class=\"hljs-keyword\">new</span> (<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;webpack-filter-warnings-plugin&#x27;</span>))({\n          <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/mini-css-extract-plugin[^]*Conflicting order between:/</span>,\n        }),\n      );\n\n      <span class=\"hljs-keyword\">if</span> (!dev &amp;&amp; !isServer) {\n        <span class=\"hljs-comment\">// 构建模式 &amp; Client 才开启压缩</span>\n        config.<span class=\"hljs-property\">optimization</span>.<span class=\"hljs-property\">minimizer</span> = [\n          ...config.<span class=\"hljs-property\">optimization</span>.<span class=\"hljs-property\">minimizer</span>,\n          <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OptimizeCSSAssetsPlugin</span>({}),\n        ];\n      }\n\n      <span class=\"hljs-comment\">// ......</span>\n    },\n  });\n};</code></pre><p>最后再修改 externals 配置，放开 antd 的样式就能支持了。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n<span class=\"hljs-comment\">// 这种配置下就不需要在顶部添加对 require 的处理了</span>\n<span class=\"hljs-keyword\">const</span> withStyle = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;@react-ssr/shared/next-config/withStyle&#x27;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-title function_\">withStyle</span>({\n  <span class=\"hljs-title function_\">webpack</span>(<span class=\"hljs-params\">config, options</span>) {\n    <span class=\"hljs-keyword\">if</span> (isServer) {\n      <span class=\"hljs-comment\">// https://github.com/zeit/next.js/blob/canary/examples/with-ant-design/next.config.js</span>\n      <span class=\"hljs-comment\">// 如果有其他 UI 库的样式，在此补充</span>\n      <span class=\"hljs-keyword\">const</span> antStyles = <span class=\"hljs-regexp\">/antd\\/.*?\\/style.*?/</span>;\n      <span class=\"hljs-keyword\">const</span> origExternals = [...config.<span class=\"hljs-property\">externals</span>];\n      config.<span class=\"hljs-property\">externals</span> = [\n        <span class=\"hljs-function\">(<span class=\"hljs-params\">context, request, callback</span>) =&gt;</span> {\n          <span class=\"hljs-keyword\">if</span> (request.<span class=\"hljs-title function_\">match</span>(antStyles)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">callback</span>();\n          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> origExternals[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;function&#x27;</span>) {\n            origExternals[<span class=\"hljs-number\">0</span>](context, request, callback);\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-title function_\">callback</span>();\n          }\n        },\n        ...(<span class=\"hljs-keyword\">typeof</span> origExternals[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">&#x27;function&#x27;</span> ? [] : origExternals),\n      ];\n    }\n\n    <span class=\"hljs-keyword\">return</span> config;\n  },\n});</code></pre><blockquote>\n<p>坑点：打包后，前端路由切换页面时样式丢失。</p>\n</blockquote>\n<p>这是因为样式在打包后，根据页面被拆分开来。而当第一打开页面时，SSR 渲染的 HTML 文档中只包含当前页面的 CSS 链接，此时在前端切换页面时也不会去加载缺失的样式文件。目前为止的解决方式是将所有的样式打包在一起，添加对应的如下配置。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// withStyle.js</span>\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-function\">() =&gt;</span> ({\n  <span class=\"hljs-title function_\">webpack</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 把所有 css 合并，因为前端路由切换页面的时候不会拉取对应的 css 文件</span>\n    <span class=\"hljs-comment\">// 服务端配置走不走不影响</span>\n    config.<span class=\"hljs-property\">optimization</span>.<span class=\"hljs-property\">splitChunks</span>.<span class=\"hljs-property\">cacheGroups</span>.<span class=\"hljs-property\">styles</span> = {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;styles&#x27;</span>,\n      <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(css|less)$/</span>,\n      <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&#x27;all&#x27;</span>,\n      <span class=\"hljs-attr\">enforce</span>: <span class=\"hljs-literal\">true</span>,\n    };\n    <span class=\"hljs-comment\">// ...</span>\n  },\n});</code></pre><h2 id=\"图片等静态文件处理\">图片等静态文件处理<a name=\"图片等静态文件处理\" class=\"headerlink\" href=\"#图片等静态文件处理\"></a></h2><p>Next.js 对 <a href=\"https://github.com/zeit/next.js#static-file-serving-eg-images\"><code>static/</code> 目录有特殊的支持</a>，推荐将静态资源放在这个目录，通过 <code>/static/some/target.png</code> 的形式进行引用。而且在 v9.0.0 版本在打包时还会自动对 <code>static/</code> 目录内的文件进行压缩。</p>\n<p>但还是存在 <code>import img from &#39;./a.png&#39;</code> 的需求，这时同样进行 webpack 的配置作为支持即可。注意，如下配置 file-loader 实际上对图片处理了两遍，只是输出路径一致最终只有一份。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n\nconfig.<span class=\"hljs-property\">module</span>.<span class=\"hljs-property\">rules</span>.<span class=\"hljs-title function_\">push</span>({\n  <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(jpe?g|png|svg|gif|ico|webp)$/</span>,\n  <span class=\"hljs-attr\">use</span>: [\n    {\n      <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;url-loader&#x27;</span>,\n      <span class=\"hljs-attr\">options</span>: {\n        <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">8192</span>,\n        <span class=\"hljs-attr\">fallback</span>: <span class=\"hljs-string\">&#x27;file-loader&#x27;</span>,\n        <span class=\"hljs-attr\">publicPath</span>: <span class=\"hljs-string\">`/_next/static/images/`</span>,\n        <span class=\"hljs-attr\">outputPath</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${isServer ? <span class=\"hljs-string\">&#x27;../&#x27;</span> : <span class=\"hljs-string\">&#x27;&#x27;</span>}</span>static/images/`</span>,\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;[name]-[hash].[ext]&#x27;</span>,\n      },\n    },\n  ],\n});</code></pre><h2 id=\"Monorepo 中的 Babel 配置\">Monorepo 中的 Babel 配置<a name=\"Monorepo 中的 Babel 配置\" class=\"headerlink\" href=\"#Monorepo 中的 Babel 配置\"></a></h2><p>当项目以 <a href=\"https://en.wikipedia.org/wiki/Monorepo\">Monorepo</a> 方式组织，同时引用其他子包内容时，引用的部分是不会经过 Babel 处理的。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// Next.js 中 webpack 的 Babel 配置</span>\n<span class=\"hljs-comment\">// https://github.com/zeit/next.js/blob/aac4e21d46f300d8433b0bd94a7a0f51e443b7d4/packages/next/build/webpack-config.ts#L394</span>\n[\n  <span class=\"hljs-comment\">// ...</span>\n  {\n    <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(tsx|ts|js|mjs|jsx)$/</span>,\n    <span class=\"hljs-attr\">include</span>: [\n      dir,\n      <span class=\"hljs-regexp\">/next-server[\\\\/]dist[\\\\/]lib/</span>,\n      <span class=\"hljs-regexp\">/next[\\\\/]dist[\\\\/]client/</span>,\n      <span class=\"hljs-regexp\">/next[\\\\/]dist[\\\\/]pages/</span>,\n      <span class=\"hljs-regexp\">/[\\\\/](strip-ansi|ansi-regex)[\\\\/]/</span>,\n    ],\n    <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">path: string</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (\n        <span class=\"hljs-regexp\">/next-server[\\\\/]dist[\\\\/]lib/</span>.<span class=\"hljs-title function_\">test</span>(path) ||\n        <span class=\"hljs-regexp\">/next[\\\\/]dist[\\\\/]client/</span>.<span class=\"hljs-title function_\">test</span>(path) ||\n        <span class=\"hljs-regexp\">/next[\\\\/]dist[\\\\/]pages/</span>.<span class=\"hljs-title function_\">test</span>(path) ||\n        <span class=\"hljs-regexp\">/[\\\\/](strip-ansi|ansi-regex)[\\\\/]/</span>.<span class=\"hljs-title function_\">test</span>(path)\n      ) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n      }\n\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-regexp\">/node_modules/</span>.<span class=\"hljs-title function_\">test</span>(path);\n    },\n    <span class=\"hljs-attr\">use</span>: defaultLoaders.<span class=\"hljs-property\">babel</span>,\n  },\n  <span class=\"hljs-comment\">// ...</span>\n];</code></pre><p>插件 <a href=\"https://www.npmjs.com/package/next-transpile-modules\">next-transpile-modules</a> 可以很方便地解决这个问题。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n<span class=\"hljs-comment\">// https://github.com/zeit/next.js/blob/aac4e21d46f300d8433b0bd94a7a0f51e443b7d4/examples/with-yarn-workspaces/packages/web-app/next.config.js#L1</span>\n\n<span class=\"hljs-keyword\">const</span> withTM = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;next-transpile-modules&#x27;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-title function_\">withTM</span>({\n  <span class=\"hljs-comment\">// `@react-ssr/shared` 是 Monorepo 结构下的其他模块的包名</span>\n  <span class=\"hljs-attr\">transpileModules</span>: [<span class=\"hljs-string\">&#x27;@react-ssr/shared&#x27;</span>],\n});</code></pre><blockquote>\n<p>坑点：虽然经过如上改造，Babel 会对其他子包进行编译，但是发现 Next.js 项目模块下的 Babel 插件配置（.babelrc）对子包范围内的代码并不生效。</p>\n</blockquote>\n<p>其实这一点来源 Babel 7 对于配置的变化，Babel 7 新增了根（root）的概念，默认是当前工作目录，也就是 Next.js 项目模块的级别（packages/nextjs-ssr/），此时 Babel 缺少、也不会去读取他子包的插件配置。</p>\n<p>Babel 推荐在所有 Monorepo 项目的根目录添加 <code>babel.config.js</code>，以此建立了 Babel 的核心概念。但这对于上述问题的解决还不够，在这里我通过设置 <code>rootMode: upward</code> 告诉 Babel 向上级寻找，Babel 会自动寻找 <code>babel.config.js</code> 并将其设置为 root 的值（<a href=\"https://babeljs.io/docs/en/config-files#project-wide-configuration\">更多详细内容可查看官方文章 —— Config Files</a>）。</p>\n<p>具体配置如下。</p>\n<pre class=\"hljs language-js\" hljs-language=\"js\"><code style=\"display:block;\"><span class=\"hljs-comment\">// next.config.js</span>\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-title function_\">webpack</span>(<span class=\"hljs-params\">config</span>) {\n    config.<span class=\"hljs-property\">module</span>.<span class=\"hljs-property\">rules</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">rule</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的改动比较暴力，因为 Next.js 没有直接暴露更改内建 loader 参数的地方</span>\n      <span class=\"hljs-keyword\">if</span> (rule.<span class=\"hljs-property\">use</span> &amp;&amp; rule.<span class=\"hljs-property\">use</span>.<span class=\"hljs-property\">loader</span> === <span class=\"hljs-string\">&#x27;next-babel-loader&#x27;</span>) {\n        <span class=\"hljs-comment\">// 设置 babel 向上寻找 babel.config.js，然后将其所在的路径作为根（root）</span>\n        <span class=\"hljs-comment\">// 否则编译其他 package 时不会加载 babel 插件</span>\n        <span class=\"hljs-comment\">// https://babeljs.io/docs/en/config-files#project-wide-configuration</span>\n        rule.<span class=\"hljs-property\">use</span>.<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">rootMode</span> = <span class=\"hljs-string\">&#x27;upward&#x27;</span>;\n      }\n    });\n    <span class=\"hljs-comment\">// ...</span>\n  },\n};</code></pre><p>如此一来，再将 Babel 插件配置在 <code>babel.config.js</code>，那么 Babel 插件在其他模块也会起作用了。</p>\n<h2 id=\"国际化语言渲染问题\">国际化语言渲染问题<a name=\"国际化语言渲染问题\" class=\"headerlink\" href=\"#国际化语言渲染问题\"></a></h2><p>在 <code>nextjs-ssr</code> 中，项目以 SSR 方式运行，在页面请求来临的同时，读取 cookies 就能知晓当前浏览器的语言设置信息，接着就能渲染出对应语言的页面并返回。</p>\n<p>对于用户来说，当选择英文，首屏返回的页面就英文；选择了中文，返回的就是中文页面。</p>\n<p>而对于静态部署的 <code>nextjs-static</code>，并没有动态渲染的能力，页面只有在返回到浏览后才能从 cookies 中读取到语言设置信息，进而将页面切换成对应的语言。</p>\n<p>页面总有个初始语言，可是这样一来打开页面会有个语言切换的现象（默认语言与实际语言不符），但这个也不好避免。所以，<code>nextjs-static</code> 中的操作是一概将 Server 的国际化输出设置成 <code>...</code>，待脚本加载后会自动读取并切换成对应的语言。</p>\n<h1 id=\"其他问题\">其他问题<a name=\"其他问题\" class=\"headerlink\" href=\"#其他问题\"></a></h1><h2 id=\"SSR 部署期间的问题\">SSR 部署期间的问题<a name=\"SSR 部署期间的问题\" class=\"headerlink\" href=\"#SSR 部署期间的问题\"></a></h2><p>在部署期间发生了一个由 <code>host</code> 字段引发的问题，导致 SSR 层的请求发生错误。</p>\n<p>结合开头的时序图可以看到，发起 GraphQL 请求的角色有浏览器和 SSR 层，而 SSR 层发起请求时都来源于一个页面的访问。比如，访问主页 <code>/</code>（不是通过其他前端路由跳转来的），而且主页组件在 <code>getInitialProps</code> 生命周期中有请求，那么该请求会在 SSR 层发起。同样，这个请求需要携带 token、language 标识等信息，这些信息来源于页面请求的 Header，这步操作见代码。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-comment\">// `packages/shared/src/layouts/ApolloWrap/index.tsx`</span>\n\n<span class=\"hljs-keyword\">const</span> authLink = <span class=\"hljs-title function_\">setContext</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, { headers }</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 这里用于添加自定义的 headers 字段</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">reqHeaders</span>: <span class=\"hljs-built_in\">any</span> = process.<span class=\"hljs-property\">browser</span>\n    ? {}\n    : <span class=\"hljs-comment\">// 当在 Server 端的时候，将来自 browser 的 headers 携带过去</span>\n      <span class=\"hljs-comment\">// host 也被包含在内。</span>\n      <span class=\"hljs-title function_\">getProp</span>(<span class=\"hljs-function\">() =&gt;</span> ctx.<span class=\"hljs-property\">req</span>.<span class=\"hljs-property\">headers</span>, {});\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">headers</span>: {\n      ...headers,\n      ...reqHeaders,\n    },\n  };\n});</code></pre><p>这里的 <code>ctx.req</code> 具体指的就是 <code>访问主页 /</code> 这次请求。接着，请求被发往 gql-server。</p>\n<p>这里需要补充一下部署时候的具体情况，<code>nextjs-ssr</code> 和 <code>gql-server</code> 运行于 Docker 容器当中，同时在一个物理机上，通过 Nginx 转发请求。</p>\n<p>那么上述流程会是这样。</p>\n<pre class=\"hljs language-\" hljs-language=\"\"><code style=\"display:block;\">1. 访问主页 `http://customer.example.com/`，发送请求到 `nextjs-ssr`\n    请求内容：\n      url: http://customer.example.com/\n      headers:\n        host:  http://customer.example.com/\n\n\n2. Nginx 将请求转发到 nextjs-ssr，nextjs-ssr 发出 `getInitialProps` 中的请求\n    请求内容：\n      url: http://gql-server.example.com/\n      headers:\n        host:  http://customer.example.com/\n\n3. Nginx 收到请求，发现 host 字段，又将请求转发到 `http://customer.example.com/`\n    Nginx 默认配置在请求 URL 和 host 字段之间会以 host 优先\n\n4. ... 死循环了，最终因为重定向过多，Nginx 返回对应错误码</code></pre><p>上述问题的解决很简单，将 host 置空或设置成正确的值。关于 host 字段的作用，我的认识如下。</p>\n<p>一个域名会被解析成 IP 对应到一台服务器，但这一台服务器上可能存在多个服务，在内部可以通过端口来区分，但出于各种原因，这台服务器往往只对外暴露部分端口，外部访问者这时候就可以额外通过 host 字段告诉服务器想要访问的服务。</p>\n<h1 id=\"GraphQL 服务\">GraphQL 服务<a name=\"GraphQL 服务\" class=\"headerlink\" href=\"#GraphQL 服务\"></a></h1><p>GraphQL 的搭建基本是一个学习的过程，虽然写过一些 Node.js 脚本，但对于 Node.js Server 的应用还是知之甚少。</p>\n<p>在编写完 demo 之后，感觉这个 <code>gql-server</code> 不算复杂，可能因为这个服务做的事情还是比较纯粹，只提供 GraphQL 服务。</p>\n<p>各种框架都有对应的方案，可以是 express、koa 等等，这里选择了 fastify，再结合相应的 apollo-server，最后添加 GraphQL 的 schema 即可。</p>\n<p>以上，都是马后炮 😅。</p>\n<p>不过值得一提的是，这里有一个库，让 GraphQL 和 TypeScript 的结合变得十分美好。不过在介绍之前，先了解一下痛点。</p>\n<p>了解过 GraphQL 之后会知道，GraphQL 的一大特点是强类型依赖，所以需要为服务编写很多的类型定义。</p>\n<p>一开始的时候，老老实实在 graphql 文件中编写 GraphQL 的类型定义。然后，在 TypeScript 中又要写一遍类型定义，显得很重复。而且，写下来后会发现两者十分相似。</p>\n<p>于是，开始寻找优化方案，从而发现了 <a href=\"https://github.com/19majkel94/type-graphql\">type-graphql</a>，结合了两者的使用。</p>\n<blockquote>\n<p>提前说明注意点：该库十分依赖装饰器语法和元数据（Decorator Metadata），两者目前为止都还没成为标准，正式使用需慎重。</p>\n</blockquote>\n<p>在 type-graphql 的基础上，只需要在 TypeScript 中编写 class 即可，class 会被转化为对应的 GraphQL 类型。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-meta\">@ObjectType</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Recipe</span> {\n  <span class=\"hljs-meta\">@Field</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span></span>) =&gt;</span> <span class=\"hljs-variable constant_\">ID</span>)\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-meta\">@Field</span>()\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-meta\">@Field</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span></span>) =&gt;</span> [<span class=\"hljs-title class_\">Rate</span>])\n  <span class=\"hljs-attr\">ratings</span>: <span class=\"hljs-title class_\">Rate</span>[];\n\n  <span class=\"hljs-meta\">@Field</span>({ <span class=\"hljs-attr\">nullable</span>: <span class=\"hljs-literal\">true</span> })\n  averageRating?: <span class=\"hljs-built_in\">number</span>;\n}</code></pre><p>上面的 class 会被转换成如下的类型。</p>\n<pre class=\"hljs language-ts\" hljs-language=\"ts\"><code style=\"display:block;\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Recipe</span> {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-variable constant_\">ID</span>!\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span>!\n  <span class=\"hljs-attr\">ratings</span>: [<span class=\"hljs-title class_\">Rate</span>!]!\n  <span class=\"hljs-attr\">averageRating</span>: <span class=\"hljs-title class_\">Float</span>\n}</code></pre><p>剩余的、也是主要的工作就是编写 resolvers。</p>\n<h1 id=\"结语\">结语<a name=\"结语\" class=\"headerlink\" href=\"#结语\"></a></h1><p>本文也终于到了结束的时候，总感觉还有遗漏的地方，只怪总结得不够及时。</p>\n<p>本文的 demo 基本是在老大哥（没错，又是那个杰哥）的基础上复刻的，本文最大的意义就是尽可能地将上述内容消化成自己的东西。如果能帮到此时的您，那更是本文的荣幸。</p>\n<p>对于 SSR 感受还是不错的，首屏的体验也是实打实的；如果觉得添加一个 Node.js 有成本，也十分建议尝试 Prerender，同样能享受到首屏的效果。</p>\n<p>对于 GraphQL 中间层的感受就有点爱恨交加了。字段查询、接口聚合、返回体自定义（不用忍受后端 😜）等功能都很好用，但是，得有人去维护一个个接口的对接，这一步也只能前端去做。不过总体而言还是很乐意去使用的。</p>\n<p>本文罗里吧嗦地也写了不少，若发现不当之处，还望斧正，感激不尽！</p>\n<hr>\n<p>参考链接 &amp; 推荐阅读：</p>\n<ul>\n<li><a href=\"https://github.com/zeit/next.js\">Next.js</a><ul>\n<li><a href=\"https://github.com/zeit/next.js/tree/canary/examples\">Next.js 官方 examples，十分推荐</a></li>\n</ul>\n</li>\n<li><a href=\"https://graphql.org/\">GraphQL</a> - <a href=\"https://graphql.cn/\">中文</a></li>\n<li><a href=\"https://www.apollographql.com/docs/\">Apollo GraphQL</a><ul>\n<li><a href=\"https://github.com/apollographql/react-apollo/\">Apollo React</a></li>\n<li><a href=\"https://github.com/apollographql/apollo-client\">Apollo Client</a></li>\n<li><a href=\"https://github.com/apollographql/apollo-server\">Apollo Server</a></li>\n</ul>\n</li>\n<li><a href=\"https://babeljs.io/docs/en/config-files#project-wide-configuration\">Babel - Config Files</a></li>\n<li><a href=\"https://github.com/fastify/fastify\">Fastify</a></li>\n<li><a href=\"https://stackoverflow.com/questions/43156023/what-is-http-host-header\">what-is-http-host-header</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host\">Host - MDN</a></li>\n</ul>\n","hash":"3da5ab4c3075862ff93e4ccf40d1fbbb","isArticle":true,"sort":0,"filename":"","raw":"","prev":{"id":"get-a-ssr-demo-step-by-step","slug":"post/get-a-ssr-demo-step-by-step","path":"/post/get-a-ssr-demo-step-by-step","title":"从零搭建 SSR","comments":true,"published":true,"date":"2019-07-02T17:10:37.000Z","updated":"","tags":[{"id":"1c16e694abe7b18f52484174b0aa3c87","name":"SSR","postCount":2,"postIds":[]}],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<p>在上一季度中接触并使用了 Next.js，实践了一把 SSR。期间遇见了不少问题，详情可见：{% post_link use-summary-of-next-js-and-graphql %}。</p>\n<p>实际上是打算先写那篇文章，但这里还是来写这个了，这样能先从零开始认识 SSR。</p>\n<p>先放上 demo 地址：<a href=\"https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo\">https://github.com/daief/react-ssr/tree/master/packages/express-ssr-demo</a>。</p>\n","more":"","hash":"fa0d0cba2d5d35f73989221cb638cf4c","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""},"next":{"id":"troubles-with-web-developing-in-weixin","slug":"post/troubles-with-web-developing-in-weixin","path":"/post/troubles-with-web-developing-in-weixin","title":"微信网页开发踩坑记录","comments":true,"published":true,"date":"2019-09-07T14:51:32.000Z","updated":"","tags":[],"categories":[{"id":"9abfe4a03928eb88a75a5cd95822dfef","name":"前端","slug":"categories/前端","path":"/categories/前端","parentId":"","postCount":36,"postIds":[]}],"excerpt":"<p>如标题所示，本文用于记录在微信中开发页面时所遇到的坑。</p>\n","more":"","hash":"70d0620b5d217df4184ef01c9afc8c55","isArticle":true,"sort":0,"filename":"","raw":"","prev":null,"next":null,"tocHtml":""}}},"tocHtml":"","simplePages":[{"id":"41a3cc43f8af362b82fbe2aa97817528","slug":"resume","path":"/resume"},{"id":"fabb5629b694584be9ff314ab8187577","slug":"resume-v2","path":"/resume-v2"},{"id":"34787f8e18c76ce0f4c3cc680ab728ef","slug":"resume-v1","path":"/resume-v1"},{"id":"ac298b1fdf5a34ac83bb9376ccdde006","slug":"about","path":"/about"}],"simplePageDetail":{"post":null}},"labels":{"labels":[],"postPagination":{"current":1,"pageSize":10,"totalPages":0,"result":[]}}}</script>
    <script>
      if (/MSIE \d|Trident.*rv:/.test(navigator.userAgent)) {
        // redirect IE to Edge
        // This browser is no longer supported
        window.location.href = 'microsoft-edge:' + window.location.href;
        alert('请使用 Chrome/Edge/Firefox/Safari 等现代浏览器。');
        throw new Error('请使用 Chrome/Edge/Firefox/Safari 等现代浏览器。');
      }
    </script>
    <script type="module" crossorigin src="/assets/index.bf8c73c6.js"></script>
    <link rel="stylesheet" href="/assets/index.48ca4a1c.css">
  </head>
  <body  data-head-attrs="">
    <div id="app"><!--[--><div class="m-4 max-w-screen-xl flex flex-wrap md:m-6 xl:mx-auto md:flex-nowrap"><div class="w-full flex-shrink-0 self-start md:sticky md:top-6 md:w-48"><div class="blog-base-area-box py-6 mb-4"><img class="block w-24 h-24 rounded-full mx-auto" src="https://avatars.githubusercontent.com/u/19222089?v=4"><div class="mt-5 px-3 text-center"><h1 class="text-c-title font-normal"><a href="" class="unset">daief的个人日志</a></h1><p class="mt-2 text-sm text-c-secondary break-words">遇见你，遇见幸运💫</p><div class="mt-3 text-xs flex justify-center"><a href="/" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-wenzhang" data-v-43154e2c></use></svg>(51) </a><span class="mx-1 text-c-secondary">|</span><a href="/tags" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg>(42) </a><span class="mx-1 text-c-secondary">|</span><a href="/categories" class="unset"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-category" data-v-43154e2c></use></svg>(16) </a></div><div class="mt-6 flex justify-center"><a to="https://github.com/daief" replace="false" href="https://github.com/daief" target="_blank" class="unset cursor-pointer"><!--[--><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-github" data-v-43154e2c></use></svg><!--]--></a><span class="mx-2"></span><a to="mailto:defeng_mail@163.com" replace="false" href="mailto:defeng_mail@163.com" target="_blank" class="unset cursor-pointer"><!--[--><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-email" data-v-43154e2c></use></svg><!--]--></a></div></div><div class="mt-6"><div class="text-center" data-v-73630894><!--[--><a href="/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>首页</a><a href="/categories/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>分类</a><a href="/tags/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>标签</a><a href="/about/" class="unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link unset
            h-10
            flex
            items-center
            justify-center
            border-b border-gray-100
            text-sm text-c-text
            menu-link" data-v-73630894>关于</a><!--]--></div></div></div><div class="hidden md:block mt-2"><div class="footer text-center text-sm" data-v-8b3f10e8><div data-v-8b3f10e8><div data-v-8b3f10e8>© 2017-2025</div></div><div class="flex items-center justify-center" data-v-8b3f10e8>By <a href="https://github.com/daief/blog/tree/master/packages/gugu" target="_blank" data-v-8b3f10e8>gugu</a>  &amp; daief - <span class="picker-wrap" data-v-7aa3923e data-v-8b3f10e8><span data-v-7aa3923e></span></span></div><!----><!----><div data-v-8b3f10e8><a href="/sitemap.xml" target="_blank" data-v-8b3f10e8>站点地图</a></div></div></div></div><div class="w-full md:w-0 md:flex-grow md:mx-5"><div><!--[--><div class="blog-base-area-box px-4 py-8 md:px-8"><div><h1 class="text-2xl font-normal break-words">Next.js、GraphQL 使用小结</h1><div class="my-4 text-xs text-c-secondary"><div class="flex items-center flex-wrap"><!----><!----><div class="whitespace-nowrap"><svg class="if-icon text-c-secondary mx-1 text-c-secondary mx-1" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-calendar" data-v-43154e2c></use></svg>2019-07-03</div><!--[--><span class="mx-1">|</span><div class="whitespace-nowrap"><svg class="if-icon text-c-secondary mx-1 text-c-secondary mx-1" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-folder" data-v-43154e2c></use></svg><!--[--><!--[--><a href="/categories/前端" class="unset">前端</a><span></span><!--]--><!--]--></div><!--]--><!----></div></div><!-- content --><div class="markdown-body text-sm text-gray-800 leading-loose"><p>近段时间里使用 <a href="https://github.com/zeit/next.js">Next.js</a> 搭建了两个后台，同时还使用了 GraphQL。期间匆匆忙忙，而且项目都是另一个前端老哥搭建的。所以，自己又抽空从头开始搭建了几个 demo，回顾一下知识，同时整理了一下当时遇见的问题、梳理下其中缘由。</p>
<p>本文主要内容包括三个 demo 的介绍，并记录一些在开发过程中遇到的问题和解决，本文对应 Next.js 版本为 <del>v8.0.3</del>。写的时候发现 Next.js 升级到 v9.0.0 了，自带 TypeScript 支持了，果断把 demo 的版本也升级了。</p>
<p>上一篇文章（《{% post_link get-a-ssr-demo-step-by-step %}》）介绍了从零搭建 SSR 的过程，并且附带了一些问题的讲解，推荐结合阅读。</p>
<p>那么，按照惯例就先呈上 demo 地址：<a href="https://github.com/daief/react-ssr">react-ssr</a>。</p>

<a id="more" class="h-0 mt-3 block"></a>


<h1 id="简介">简介<a name="简介" class="headerlink" href="#简介"></a></h1><p>本节对三个 demo 作个简单介绍。</p>
<p>正常运行该项目需要配置本地 hosts。</p>
<pre class="hljs language-bash" hljs-language="bash"><code style="display:block;"><span class="hljs-comment"># hosts</span>
<span class="hljs-comment"># 模拟 gql-server 的域名</span>
127.0.0.1            gql-server.example.com
<span class="hljs-comment"># 模拟应用 account 的域名（nextjs-ssr 或 nextjs-static）</span>
127.0.0.1            account.example.com
<span class="hljs-comment"># 模拟应用 customer 的域名（nextjs-ssr 或 nextjs-static）</span>
127.0.0.1            customer.example.com</code></pre><p>或者在 <code>packages/shared/CONFIG.ts</code> 文件中修改成其他域名配置，然后通过域名 + 端口的形式访问本地开发环境。</p>
<h2 id="nextjs-ssr">nextjs-ssr<a name="nextjs-ssr" class="headerlink" href="#nextjs-ssr"></a></h2><blockquote>
<p>地址：<a href="https://github.com/daief/react-ssr/tree/master/packages/nextjs-ssr">https://github.com/daief/react-ssr/tree/master/packages/nextjs-ssr</a></p>
</blockquote>
<p>这第一个 demo 对应业务开发中的第一个后台，该后台是一个对内的、管理各种应用的后台，其中一个功能需要实现各个应用间的<a href="https://en.wikipedia.org/wiki/Single_sign-on">单点登录（SSO）</a>。</p>
<p>Java 端基于 <a href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWT（Json web token）</a> 实现授权认证，前端应用在请求时需要把 token 加到请求头当中，同时也会将 token 缓存于 localStorage。</p>
<p>这里的每个应用都有一个不同的二级域名（如 a.example.com、b.example.com），而 localStorage 由于跨域限制，前端应用之间不能共享 token，在这种情况打开新的应用时就会需要重新登录。</p>
<p>因此，新的方案是把 token 存储在 cookie 里，并设置 Domain 为根域名（.example.com）。如此一来各个应用之间直接就共享 token，而且每个应用不再需要维护 token。</p>
<p>因为这是一个对内的应用，同时出于对技术的追求，该项目决定试用 SSR，选型 Next.js。同时前端组表示可以用中间层来做 cookie 的维护，而 Java 端一切保持不变。加上了 Node 层之后，又顺理成章地加上了 GraphQL Server。</p>
<h2 id="gql-server">gql-server<a name="gql-server" class="headerlink" href="#gql-server"></a></h2><blockquote>
<p>地址：<a href="https://github.com/daief/react-ssr/tree/master/packages/gql-server">https://github.com/daief/react-ssr/tree/master/packages/gql-server</a></p>
</blockquote>
<p>这是一个独立的中间层，主要作用是提供 GraphQL 服务、cookie 管理。</p>
<p>其实上面选择用 Next.js 做 SSR 的时候就已经添加了一个 Node 服务，但这里还是另外再起了一个服务，依我的想法出于两个原因：Next.js 服务专门负责 SSR，这边专门提供 GraphQL 服务，职责会比较清晰；两者同一个服务时，Next.js 会作为一个中间来件运作，开发调试时若修改服务端部分代码调试工具会自动重启服务，这就会导致 next 部分也重启了、而且得重新编译，很费时间。</p>
<p>该项目基于 <a href="https://www.apollographql.com/docs/">Apollo GraphQL</a> 系列搭建。</p>
<p>nextjs-ssr + gql-server + Java 的整体运作情况如下。</p>
<p><img alt="sequence-chart.jpg" loading="lazy" title="sequence-chart.jpg" class="post-image " src="/images/bf96eaf446430d6d7053f2bc6f5bc836.sequence-chart.jpg" onerror="this.onerror=null;this.src='/images/image-error.jpg';"></p>
<h2 id="nextjs-static">nextjs-static<a name="nextjs-static" class="headerlink" href="#nextjs-static"></a></h2><blockquote>
<p>地址：<a href="https://github.com/daief/react-ssr/tree/master/packages/nextjs-static">https://github.com/daief/react-ssr/tree/master/packages/nextjs-static</a></p>
</blockquote>
<p>该 demo 也使用 Next.js 框架，但依赖的是 Prerender 的功能，最终是静态部署，所以项目中踢除、避免 Server 端的代码。（该 demo 对应第二个后台，只是个常规的管理后台）</p>
<p>请求部分依旧使用了 GraphQL，不过该项目没有对应的 GraphQL 服务，API 是 REST 形式的。</p>
<p>通过 <a href="https://www.apollographql.com/docs/link/">apollo-link</a>（可看作是 apollo-client 的中间件）使得 GraphQL 变得十分灵活、不仅仅是依赖于 GraphQL 服务而使用。</p>
<blockquote>
<p>apollo-client 是用于发起 GraphQL 请求的一种客户端框架。</p>
</blockquote>
<p>这里的主角是 <a href="https://www.apollographql.com/docs/link/links/rest/">apollo-link-rest</a>，让我们很轻易地通过 GraphQL 调用 REST API。</p>
<p>这样可以在前端实现接口聚合、字段查询（基于真实接口的返回）等 GraphQL 的特色功能。</p>
<h1 id="Next.js 使用问题">Next.js 使用问题<a name="Next.js 使用问题" class="headerlink" href="#Next.js 使用问题"></a></h1><p>下面把和 Next.js 有关的问题聚合在这一节。</p>
<h2 id="样式文件的处理">样式文件的处理<a name="样式文件的处理" class="headerlink" href="#样式文件的处理"></a></h2><p>这个应该是使用 SSR 时候的经典问题了，不过有关样式文件在 SSR 中的问题在{% post_link get-a-ssr-demo-step-by-step %}有详细解读，这里只说明该问题在 Next.js 中的具体解决以及和 Next.js 有关的注意点。</p>
<p>这个问题主要可概括为两点：一是缺少 webpack 对于 CSS、Less 的配置；二是 SSR 项目运行的特点。</p>
<p>添加相应的 webpack 配置，可使用官方的配置扩展插件：<a href="https://github.com/zeit/next-plugins/tree/master/packages/next-css">@zeit/next-css</a>、<a href="https://github.com/zeit/next-plugins/tree/master/packages/next-less">@zeit/next-less</a>，然后在 <code>next.config.js</code> 中使用：</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// next.config.js</span>
<span class="hljs-keyword">const</span> withCSS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@zeit/next-css&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">withCSS</span>(
  <span class="hljs-title function_">withLess</span>({
    <span class="hljs-comment">/* config options here */</span>
    <span class="hljs-attr">cssModules</span>: <span class="hljs-comment">/* 开启 cssModules */</span> <span class="hljs-literal">true</span>,
    <span class="hljs-attr">lessLoaderOptions</span>: {
      <span class="hljs-attr">javascriptEnabled</span>: <span class="hljs-literal">true</span>,
    },
    <span class="hljs-attr">cssLoaderOptions</span>: {
      <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">localIdentName</span>: <span class="hljs-string">&#x27;[local]_[hash:base64:5]&#x27;</span>,
    },
  }),
);</code></pre><p>如此一来，项目中就能正常引用样式文件了。</p>
<blockquote>
<p>坑点：引入第三方组件库如 antd 时样式依旧会报错。</p>
</blockquote>
<p>最为简单的方式，在 <code>next.config.js</code> 顶部添加：</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// next.config.js</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) {
  <span class="hljs-built_in">require</span>.<span class="hljs-property">extensions</span>[<span class="hljs-string">&#x27;.css&#x27;</span>] = <span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {};
  <span class="hljs-built_in">require</span>.<span class="hljs-property">extensions</span>[<span class="hljs-string">&#x27;.less&#x27;</span>] = <span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {};
}</code></pre><blockquote>
<p>坑点：所有的样式文件都开启了 CSS modules；打包时样式依旧报错。</p>
</blockquote>
<p>尝试自定义 webpack 的样式配置，简单粗暴之处在于所有（Server &amp; Client）样式都过一遍 loader。在这样的配置下，只要在需要开启 CSS modules 的地方添加 <code>:local()</code> 即可。（以下配置基于 css-loader@^3，顺便一提官方插件所用的是 css-loader@1，两者配置之间会有差异）</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// withStyle.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">nextConfig = {}</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, nextConfig, {
    <span class="hljs-title function_">webpack</span>(<span class="hljs-params">config, options</span>) {
      <span class="hljs-keyword">const</span> { dev, isServer } = options;
      <span class="hljs-keyword">const</span> {
        cssLoaderOptions,
        postcssLoaderOptions,
        lessLoaderOptions = {},
      } = nextConfig;

      options.<span class="hljs-property">defaultLoaders</span>.<span class="hljs-property">css</span> = [
        {
          <span class="hljs-attr">loader</span>: <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,
        },
        {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,
          <span class="hljs-attr">options</span>: {
            <span class="hljs-attr">sourceMap</span>: dev,
            <span class="hljs-attr">modules</span>: {
              <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;global&#x27;</span>,
              <span class="hljs-attr">localIdentName</span>: <span class="hljs-string">&#x27;[local]--[hash:base64:5]&#x27;</span>,
            },
            ...cssLoaderOptions,
          },
        },
      ];

      options.<span class="hljs-property">defaultLoaders</span>.<span class="hljs-property">less</span> = [
        ...options.<span class="hljs-property">defaultLoaders</span>.<span class="hljs-property">css</span>,
        {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;less-loader&#x27;</span>,
          <span class="hljs-attr">options</span>: {
            <span class="hljs-attr">javascriptEnabled</span>: <span class="hljs-literal">true</span>,
            ...lessLoaderOptions,
          },
        },
      ];

      config.<span class="hljs-property">module</span>.<span class="hljs-property">rules</span>.<span class="hljs-title function_">push</span>(
        {
          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
          <span class="hljs-attr">use</span>: options.<span class="hljs-property">defaultLoaders</span>.<span class="hljs-property">css</span>,
        },
        {
          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,
          <span class="hljs-attr">use</span>: options.<span class="hljs-property">defaultLoaders</span>.<span class="hljs-property">less</span>,
        },
      );

      config.<span class="hljs-property">plugins</span>.<span class="hljs-title function_">push</span>(
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({
          <span class="hljs-comment">// 要加上 static，否则打包后 404</span>
          <span class="hljs-attr">filename</span>: dev
            ? <span class="hljs-string">&#x27;static/css/[name].css&#x27;</span>
            : <span class="hljs-string">&#x27;static/css/[name].[contenthash:8].css&#x27;</span>,
          <span class="hljs-attr">chunkFilename</span>: dev
            ? <span class="hljs-string">&#x27;static/css/[name].chunk.css&#x27;</span>
            : <span class="hljs-string">&#x27;static/css/[name].[contenthash:8].chunk.css&#x27;</span>,
        }),
        <span class="hljs-keyword">new</span> (<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-filter-warnings-plugin&#x27;</span>))({
          <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/mini-css-extract-plugin[^]*Conflicting order between:/</span>,
        }),
      );

      <span class="hljs-keyword">if</span> (!dev &amp;&amp; !isServer) {
        <span class="hljs-comment">// 构建模式 &amp; Client 才开启压缩</span>
        config.<span class="hljs-property">optimization</span>.<span class="hljs-property">minimizer</span> = [
          ...config.<span class="hljs-property">optimization</span>.<span class="hljs-property">minimizer</span>,
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span>({}),
        ];
      }

      <span class="hljs-comment">// ......</span>
    },
  });
};</code></pre><p>最后再修改 externals 配置，放开 antd 的样式就能支持了。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// next.config.js</span>
<span class="hljs-comment">// 这种配置下就不需要在顶部添加对 require 的处理了</span>
<span class="hljs-keyword">const</span> withStyle = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@react-ssr/shared/next-config/withStyle&#x27;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">withStyle</span>({
  <span class="hljs-title function_">webpack</span>(<span class="hljs-params">config, options</span>) {
    <span class="hljs-keyword">if</span> (isServer) {
      <span class="hljs-comment">// https://github.com/zeit/next.js/blob/canary/examples/with-ant-design/next.config.js</span>
      <span class="hljs-comment">// 如果有其他 UI 库的样式，在此补充</span>
      <span class="hljs-keyword">const</span> antStyles = <span class="hljs-regexp">/antd\/.*?\/style.*?/</span>;
      <span class="hljs-keyword">const</span> origExternals = [...config.<span class="hljs-property">externals</span>];
      config.<span class="hljs-property">externals</span> = [
        <span class="hljs-function">(<span class="hljs-params">context, request, callback</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (request.<span class="hljs-title function_">match</span>(antStyles)) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>();
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> origExternals[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;function&#x27;</span>) {
            origExternals[<span class="hljs-number">0</span>](context, request, callback);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">callback</span>();
          }
        },
        ...(<span class="hljs-keyword">typeof</span> origExternals[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;function&#x27;</span> ? [] : origExternals),
      ];
    }

    <span class="hljs-keyword">return</span> config;
  },
});</code></pre><blockquote>
<p>坑点：打包后，前端路由切换页面时样式丢失。</p>
</blockquote>
<p>这是因为样式在打包后，根据页面被拆分开来。而当第一打开页面时，SSR 渲染的 HTML 文档中只包含当前页面的 CSS 链接，此时在前端切换页面时也不会去加载缺失的样式文件。目前为止的解决方式是将所有的样式打包在一起，添加对应的如下配置。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// withStyle.js</span>

<span class="hljs-comment">// ...</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">() =&gt;</span> ({
  <span class="hljs-title function_">webpack</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 把所有 css 合并，因为前端路由切换页面的时候不会拉取对应的 css 文件</span>
    <span class="hljs-comment">// 服务端配置走不走不影响</span>
    config.<span class="hljs-property">optimization</span>.<span class="hljs-property">splitChunks</span>.<span class="hljs-property">cacheGroups</span>.<span class="hljs-property">styles</span> = {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;styles&#x27;</span>,
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(css|less)$/</span>,
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,
      <span class="hljs-attr">enforce</span>: <span class="hljs-literal">true</span>,
    };
    <span class="hljs-comment">// ...</span>
  },
});</code></pre><h2 id="图片等静态文件处理">图片等静态文件处理<a name="图片等静态文件处理" class="headerlink" href="#图片等静态文件处理"></a></h2><p>Next.js 对 <a href="https://github.com/zeit/next.js#static-file-serving-eg-images"><code>static/</code> 目录有特殊的支持</a>，推荐将静态资源放在这个目录，通过 <code>/static/some/target.png</code> 的形式进行引用。而且在 v9.0.0 版本在打包时还会自动对 <code>static/</code> 目录内的文件进行压缩。</p>
<p>但还是存在 <code>import img from &#39;./a.png&#39;</code> 的需求，这时同样进行 webpack 的配置作为支持即可。注意，如下配置 file-loader 实际上对图片处理了两遍，只是输出路径一致最终只有一份。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// next.config.js</span>

config.<span class="hljs-property">module</span>.<span class="hljs-property">rules</span>.<span class="hljs-title function_">push</span>({
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpe?g|png|svg|gif|ico|webp)$/</span>,
  <span class="hljs-attr">use</span>: [
    {
      <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">limit</span>: <span class="hljs-number">8192</span>,
        <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#x27;file-loader&#x27;</span>,
        <span class="hljs-attr">publicPath</span>: <span class="hljs-string">`/_next/static/images/`</span>,
        <span class="hljs-attr">outputPath</span>: <span class="hljs-string">`<span class="hljs-subst">${isServer ? <span class="hljs-string">&#x27;../&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>}</span>static/images/`</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;[name]-[hash].[ext]&#x27;</span>,
      },
    },
  ],
});</code></pre><h2 id="Monorepo 中的 Babel 配置">Monorepo 中的 Babel 配置<a name="Monorepo 中的 Babel 配置" class="headerlink" href="#Monorepo 中的 Babel 配置"></a></h2><p>当项目以 <a href="https://en.wikipedia.org/wiki/Monorepo">Monorepo</a> 方式组织，同时引用其他子包内容时，引用的部分是不会经过 Babel 处理的。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// Next.js 中 webpack 的 Babel 配置</span>
<span class="hljs-comment">// https://github.com/zeit/next.js/blob/aac4e21d46f300d8433b0bd94a7a0f51e443b7d4/packages/next/build/webpack-config.ts#L394</span>
[
  <span class="hljs-comment">// ...</span>
  {
    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(tsx|ts|js|mjs|jsx)$/</span>,
    <span class="hljs-attr">include</span>: [
      dir,
      <span class="hljs-regexp">/next-server[\\/]dist[\\/]lib/</span>,
      <span class="hljs-regexp">/next[\\/]dist[\\/]client/</span>,
      <span class="hljs-regexp">/next[\\/]dist[\\/]pages/</span>,
      <span class="hljs-regexp">/[\\/](strip-ansi|ansi-regex)[\\/]/</span>,
    ],
    <span class="hljs-attr">exclude</span>: <span class="hljs-function">(<span class="hljs-params">path: string</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (
        <span class="hljs-regexp">/next-server[\\/]dist[\\/]lib/</span>.<span class="hljs-title function_">test</span>(path) ||
        <span class="hljs-regexp">/next[\\/]dist[\\/]client/</span>.<span class="hljs-title function_">test</span>(path) ||
        <span class="hljs-regexp">/next[\\/]dist[\\/]pages/</span>.<span class="hljs-title function_">test</span>(path) ||
        <span class="hljs-regexp">/[\\/](strip-ansi|ansi-regex)[\\/]/</span>.<span class="hljs-title function_">test</span>(path)
      ) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-regexp">/node_modules/</span>.<span class="hljs-title function_">test</span>(path);
    },
    <span class="hljs-attr">use</span>: defaultLoaders.<span class="hljs-property">babel</span>,
  },
  <span class="hljs-comment">// ...</span>
];</code></pre><p>插件 <a href="https://www.npmjs.com/package/next-transpile-modules">next-transpile-modules</a> 可以很方便地解决这个问题。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// next.config.js</span>
<span class="hljs-comment">// https://github.com/zeit/next.js/blob/aac4e21d46f300d8433b0bd94a7a0f51e443b7d4/examples/with-yarn-workspaces/packages/web-app/next.config.js#L1</span>

<span class="hljs-keyword">const</span> withTM = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;next-transpile-modules&#x27;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">withTM</span>({
  <span class="hljs-comment">// `@react-ssr/shared` 是 Monorepo 结构下的其他模块的包名</span>
  <span class="hljs-attr">transpileModules</span>: [<span class="hljs-string">&#x27;@react-ssr/shared&#x27;</span>],
});</code></pre><blockquote>
<p>坑点：虽然经过如上改造，Babel 会对其他子包进行编译，但是发现 Next.js 项目模块下的 Babel 插件配置（.babelrc）对子包范围内的代码并不生效。</p>
</blockquote>
<p>其实这一点来源 Babel 7 对于配置的变化，Babel 7 新增了根（root）的概念，默认是当前工作目录，也就是 Next.js 项目模块的级别（packages/nextjs-ssr/），此时 Babel 缺少、也不会去读取他子包的插件配置。</p>
<p>Babel 推荐在所有 Monorepo 项目的根目录添加 <code>babel.config.js</code>，以此建立了 Babel 的核心概念。但这对于上述问题的解决还不够，在这里我通过设置 <code>rootMode: upward</code> 告诉 Babel 向上级寻找，Babel 会自动寻找 <code>babel.config.js</code> 并将其设置为 root 的值（<a href="https://babeljs.io/docs/en/config-files#project-wide-configuration">更多详细内容可查看官方文章 —— Config Files</a>）。</p>
<p>具体配置如下。</p>
<pre class="hljs language-js" hljs-language="js"><code style="display:block;"><span class="hljs-comment">// next.config.js</span>

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-title function_">webpack</span>(<span class="hljs-params">config</span>) {
    config.<span class="hljs-property">module</span>.<span class="hljs-property">rules</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">rule</span>) =&gt;</span> {
      <span class="hljs-comment">// 这里的改动比较暴力，因为 Next.js 没有直接暴露更改内建 loader 参数的地方</span>
      <span class="hljs-keyword">if</span> (rule.<span class="hljs-property">use</span> &amp;&amp; rule.<span class="hljs-property">use</span>.<span class="hljs-property">loader</span> === <span class="hljs-string">&#x27;next-babel-loader&#x27;</span>) {
        <span class="hljs-comment">// 设置 babel 向上寻找 babel.config.js，然后将其所在的路径作为根（root）</span>
        <span class="hljs-comment">// 否则编译其他 package 时不会加载 babel 插件</span>
        <span class="hljs-comment">// https://babeljs.io/docs/en/config-files#project-wide-configuration</span>
        rule.<span class="hljs-property">use</span>.<span class="hljs-property">options</span>.<span class="hljs-property">rootMode</span> = <span class="hljs-string">&#x27;upward&#x27;</span>;
      }
    });
    <span class="hljs-comment">// ...</span>
  },
};</code></pre><p>如此一来，再将 Babel 插件配置在 <code>babel.config.js</code>，那么 Babel 插件在其他模块也会起作用了。</p>
<h2 id="国际化语言渲染问题">国际化语言渲染问题<a name="国际化语言渲染问题" class="headerlink" href="#国际化语言渲染问题"></a></h2><p>在 <code>nextjs-ssr</code> 中，项目以 SSR 方式运行，在页面请求来临的同时，读取 cookies 就能知晓当前浏览器的语言设置信息，接着就能渲染出对应语言的页面并返回。</p>
<p>对于用户来说，当选择英文，首屏返回的页面就英文；选择了中文，返回的就是中文页面。</p>
<p>而对于静态部署的 <code>nextjs-static</code>，并没有动态渲染的能力，页面只有在返回到浏览后才能从 cookies 中读取到语言设置信息，进而将页面切换成对应的语言。</p>
<p>页面总有个初始语言，可是这样一来打开页面会有个语言切换的现象（默认语言与实际语言不符），但这个也不好避免。所以，<code>nextjs-static</code> 中的操作是一概将 Server 的国际化输出设置成 <code>...</code>，待脚本加载后会自动读取并切换成对应的语言。</p>
<h1 id="其他问题">其他问题<a name="其他问题" class="headerlink" href="#其他问题"></a></h1><h2 id="SSR 部署期间的问题">SSR 部署期间的问题<a name="SSR 部署期间的问题" class="headerlink" href="#SSR 部署期间的问题"></a></h2><p>在部署期间发生了一个由 <code>host</code> 字段引发的问题，导致 SSR 层的请求发生错误。</p>
<p>结合开头的时序图可以看到，发起 GraphQL 请求的角色有浏览器和 SSR 层，而 SSR 层发起请求时都来源于一个页面的访问。比如，访问主页 <code>/</code>（不是通过其他前端路由跳转来的），而且主页组件在 <code>getInitialProps</code> 生命周期中有请求，那么该请求会在 SSR 层发起。同样，这个请求需要携带 token、language 标识等信息，这些信息来源于页面请求的 Header，这步操作见代码。</p>
<pre class="hljs language-ts" hljs-language="ts"><code style="display:block;"><span class="hljs-comment">// `packages/shared/src/layouts/ApolloWrap/index.tsx`</span>

<span class="hljs-keyword">const</span> authLink = <span class="hljs-title function_">setContext</span>(<span class="hljs-function">(<span class="hljs-params">_, { headers }</span>) =&gt;</span> {
  <span class="hljs-comment">// 这里用于添加自定义的 headers 字段</span>
  <span class="hljs-keyword">const</span> <span class="hljs-attr">reqHeaders</span>: <span class="hljs-built_in">any</span> = process.<span class="hljs-property">browser</span>
    ? {}
    : <span class="hljs-comment">// 当在 Server 端的时候，将来自 browser 的 headers 携带过去</span>
      <span class="hljs-comment">// host 也被包含在内。</span>
      <span class="hljs-title function_">getProp</span>(<span class="hljs-function">() =&gt;</span> ctx.<span class="hljs-property">req</span>.<span class="hljs-property">headers</span>, {});
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">headers</span>: {
      ...headers,
      ...reqHeaders,
    },
  };
});</code></pre><p>这里的 <code>ctx.req</code> 具体指的就是 <code>访问主页 /</code> 这次请求。接着，请求被发往 gql-server。</p>
<p>这里需要补充一下部署时候的具体情况，<code>nextjs-ssr</code> 和 <code>gql-server</code> 运行于 Docker 容器当中，同时在一个物理机上，通过 Nginx 转发请求。</p>
<p>那么上述流程会是这样。</p>
<pre class="hljs language-" hljs-language=""><code style="display:block;">1. 访问主页 `http://customer.example.com/`，发送请求到 `nextjs-ssr`
    请求内容：
      url: http://customer.example.com/
      headers:
        host:  http://customer.example.com/


2. Nginx 将请求转发到 nextjs-ssr，nextjs-ssr 发出 `getInitialProps` 中的请求
    请求内容：
      url: http://gql-server.example.com/
      headers:
        host:  http://customer.example.com/

3. Nginx 收到请求，发现 host 字段，又将请求转发到 `http://customer.example.com/`
    Nginx 默认配置在请求 URL 和 host 字段之间会以 host 优先

4. ... 死循环了，最终因为重定向过多，Nginx 返回对应错误码</code></pre><p>上述问题的解决很简单，将 host 置空或设置成正确的值。关于 host 字段的作用，我的认识如下。</p>
<p>一个域名会被解析成 IP 对应到一台服务器，但这一台服务器上可能存在多个服务，在内部可以通过端口来区分，但出于各种原因，这台服务器往往只对外暴露部分端口，外部访问者这时候就可以额外通过 host 字段告诉服务器想要访问的服务。</p>
<h1 id="GraphQL 服务">GraphQL 服务<a name="GraphQL 服务" class="headerlink" href="#GraphQL 服务"></a></h1><p>GraphQL 的搭建基本是一个学习的过程，虽然写过一些 Node.js 脚本，但对于 Node.js Server 的应用还是知之甚少。</p>
<p>在编写完 demo 之后，感觉这个 <code>gql-server</code> 不算复杂，可能因为这个服务做的事情还是比较纯粹，只提供 GraphQL 服务。</p>
<p>各种框架都有对应的方案，可以是 express、koa 等等，这里选择了 fastify，再结合相应的 apollo-server，最后添加 GraphQL 的 schema 即可。</p>
<p>以上，都是马后炮 😅。</p>
<p>不过值得一提的是，这里有一个库，让 GraphQL 和 TypeScript 的结合变得十分美好。不过在介绍之前，先了解一下痛点。</p>
<p>了解过 GraphQL 之后会知道，GraphQL 的一大特点是强类型依赖，所以需要为服务编写很多的类型定义。</p>
<p>一开始的时候，老老实实在 graphql 文件中编写 GraphQL 的类型定义。然后，在 TypeScript 中又要写一遍类型定义，显得很重复。而且，写下来后会发现两者十分相似。</p>
<p>于是，开始寻找优化方案，从而发现了 <a href="https://github.com/19majkel94/type-graphql">type-graphql</a>，结合了两者的使用。</p>
<blockquote>
<p>提前说明注意点：该库十分依赖装饰器语法和元数据（Decorator Metadata），两者目前为止都还没成为标准，正式使用需慎重。</p>
</blockquote>
<p>在 type-graphql 的基础上，只需要在 TypeScript 中编写 class 即可，class 会被转化为对应的 GraphQL 类型。</p>
<pre class="hljs language-ts" hljs-language="ts"><code style="display:block;"><span class="hljs-meta">@ObjectType</span>()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Recipe</span> {
  <span class="hljs-meta">@Field</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) =&gt;</span> <span class="hljs-variable constant_">ID</span>)
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>()
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Field</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) =&gt;</span> [<span class="hljs-title class_">Rate</span>])
  <span class="hljs-attr">ratings</span>: <span class="hljs-title class_">Rate</span>[];

  <span class="hljs-meta">@Field</span>({ <span class="hljs-attr">nullable</span>: <span class="hljs-literal">true</span> })
  averageRating?: <span class="hljs-built_in">number</span>;
}</code></pre><p>上面的 class 会被转换成如下的类型。</p>
<pre class="hljs language-ts" hljs-language="ts"><code style="display:block;"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Recipe</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-variable constant_">ID</span>!
  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>!
  <span class="hljs-attr">ratings</span>: [<span class="hljs-title class_">Rate</span>!]!
  <span class="hljs-attr">averageRating</span>: <span class="hljs-title class_">Float</span>
}</code></pre><p>剩余的、也是主要的工作就是编写 resolvers。</p>
<h1 id="结语">结语<a name="结语" class="headerlink" href="#结语"></a></h1><p>本文也终于到了结束的时候，总感觉还有遗漏的地方，只怪总结得不够及时。</p>
<p>本文的 demo 基本是在老大哥（没错，又是那个杰哥）的基础上复刻的，本文最大的意义就是尽可能地将上述内容消化成自己的东西。如果能帮到此时的您，那更是本文的荣幸。</p>
<p>对于 SSR 感受还是不错的，首屏的体验也是实打实的；如果觉得添加一个 Node.js 有成本，也十分建议尝试 Prerender，同样能享受到首屏的效果。</p>
<p>对于 GraphQL 中间层的感受就有点爱恨交加了。字段查询、接口聚合、返回体自定义（不用忍受后端 😜）等功能都很好用，但是，得有人去维护一个个接口的对接，这一步也只能前端去做。不过总体而言还是很乐意去使用的。</p>
<p>本文罗里吧嗦地也写了不少，若发现不当之处，还望斧正，感激不尽！</p>
<hr>
<p>参考链接 &amp; 推荐阅读：</p>
<ul>
<li><a href="https://github.com/zeit/next.js">Next.js</a><ul>
<li><a href="https://github.com/zeit/next.js/tree/canary/examples">Next.js 官方 examples，十分推荐</a></li>
</ul>
</li>
<li><a href="https://graphql.org/">GraphQL</a> - <a href="https://graphql.cn/">中文</a></li>
<li><a href="https://www.apollographql.com/docs/">Apollo GraphQL</a><ul>
<li><a href="https://github.com/apollographql/react-apollo/">Apollo React</a></li>
<li><a href="https://github.com/apollographql/apollo-client">Apollo Client</a></li>
<li><a href="https://github.com/apollographql/apollo-server">Apollo Server</a></li>
</ul>
</li>
<li><a href="https://babeljs.io/docs/en/config-files#project-wide-configuration">Babel - Config Files</a></li>
<li><a href="https://github.com/fastify/fastify">Fastify</a></li>
<li><a href="https://stackoverflow.com/questions/43156023/what-is-http-host-header">what-is-http-host-header</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host">Host - MDN</a></li>
</ul>
</div><div class="mt-6 has-child mt-6 mt-6" data-v-3adb2250><!--[-->☘️<!--]--></div><div class="flex flex-wrap justify-center text-c-secondary text-sm mt-6"><!--[--><a href="/tags/SSR" class="unset block my-1 mx-2"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg> SSR</a><a href="/tags/GraphQL" class="unset block my-1 mx-2"><svg class="if-icon" aria-hidden="true" data-v-43154e2c><use xlink:href="#if-tag" data-v-43154e2c></use></svg> GraphQL</a><!--]--></div></div></div><!-- 上下篇 --><div class="blog-base-area-box px-4 py-4 my-8 flex justify-between md:px-8"><!--[--><div class="pr-3 w-0 flex-grow break-words"><!--[--><div class="text-c-secondary text-xs mb-1">上一篇 </div><div class="text-sm"><a href="/post/get-a-ssr-demo-step-by-step" class="unset">从零搭建 SSR</a></div><!--]--></div><div class="text-right pl-3 w-0 flex-grow break-words"><!--[--><div class="text-c-secondary text-xs mb-1">下一篇 </div><div class="text-sm"><a href="/post/troubles-with-web-developing-in-weixin" class="unset">微信网页开发踩坑记录</a></div><!--]--></div><!--]--></div><!-- 评论 --><div id="comment" class="blog-base-area-box p-4 my-8 md:px-8"><h1 class="text-c-title text-xl block font-normal mb-5"><a href="#comment" class="unset text-c-title hover:text-c-title hover:underline"> 留言板 </a></h1><div class="utterances"></div></div><!--]--></div></div><div class="blog-base-area-box hidden md:block w-48 sticky top-6"><div style="display:none;" class="site-toc-wrap leading-6 break-all text-sm p-3"></div></div></div><div class="block mb-4 md:hidden"><div class="footer text-center text-sm" data-v-8b3f10e8><div data-v-8b3f10e8><div data-v-8b3f10e8>© 2017-2025</div></div><div class="flex items-center justify-center" data-v-8b3f10e8>By <a href="https://github.com/daief/blog/tree/master/packages/gugu" target="_blank" data-v-8b3f10e8>gugu</a>  &amp; daief - <span class="picker-wrap" data-v-7aa3923e data-v-8b3f10e8><span data-v-7aa3923e></span></span></div><!----><!----><div data-v-8b3f10e8><a href="/sitemap.xml" target="_blank" data-v-8b3f10e8>站点地图</a></div></div></div><div class="fixed z-100 right-8 bottom-14" data-v-49aec8bc><div class="blog-base-area-box action-btn opacity-0 pointer-events-none" data-v-49aec8bc><svg class="if-icon" aria-hidden="true" data-v-43154e2c data-v-49aec8bc><use xlink:href="#if-top" data-v-43154e2c></use></svg></div></div><!--]--></div>
    
  </body>
</html>
